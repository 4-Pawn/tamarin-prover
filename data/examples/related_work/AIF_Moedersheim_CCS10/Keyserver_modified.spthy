theory Keyserver begin

/*
 * Protocol:	The keyserver example from [1]
 * Modeler: 	Simon Meier
 * Date: 	June 2012
 *
 * Status: 	WIP (trying to make it more sensible wrt. access to private keys)

 [1] Sebastian Moedersheim: Abstraction by set-membership: verifying security
 protocols and web services with databases. ACM Conference on Computer and
 Communications Security 2010: 351-360
 */

/* Original input file from [1]

Problem: zebsKeyserver;

Types:
Agent  : {a,b,c,i,s};
U      : {a,b,c};
S      : {s};
H      : {a,b};
D      : {c,i};
DU     : {c};
Sts    : {valid,revoked};
PK,NPK : value;
M1,M2  : untyped;

Sets:
ring(U), db(S,U,Sts);

Functions:
public sign/2, pair/2;
private inv/1;

Facts:
iknows/1, attack/0;

Rules:

\Agent. => iknows(Agent);
iknows(sign(M1,M2)) => iknows(M2);
iknows(M1).iknows(M2) => iknows(sign(M1,M2));
iknows(pair(M1,M2)) => iknows(M1).iknows(M2);
iknows(M1).iknows(M2) => iknows(pair(M1,M2));
*/

builtins: signing

// The non-deterministic choice between the rules SetupHonestKey and
// SetupDishonestKey determines whether an agent is honest or not.

// \H,S. =[PK]=>iknows(PK).PK in ring(H).PK in db(S,H,valid);
rule SetupHonestKey:
    [ Fr(sk) ]
  --[ HonestKey(pk(sk)) ]->
    [ Out(pk(sk))
    , ClientKey($A, sk)
    , ServerDB($A, pk(sk)) ]

// \S,DU. =[PK]=>iknows(PK).iknows(inv(PK)).PK in db(S,DU,valid);
rule SetupDishonestKey:
    [ In(sk) ]
  -->
    [ ServerDB($A, sk) ]

// \H.
// iknows(PK).PK in ring(H)
// =[NPK]=>NPK in ring(H).iknows(sign(inv(PK),pair(H,NPK)));
rule RequestRenewKey:
  let msg = <'renew', $A, pk(skNew)>
  in
    [ ClientKey($A, sk), Fr(skNew) ]
  --[ HonestKey(pk(skNew)) ]->
    [ Out( <msg, sign{msg}sk> )
    , ClientKey($A, skNew)
    ]

// \S,U.
// iknows(sign(inv(PK),pair(U,NPK))).PK in db(S,U,valid).
// forall U,Sts. NPK notin db(S,U,Sts)
// =>PK in db(S,U,revoked).NPK in db(S,U,valid).iknows(inv(PK));
rule RenewKey:
  let msg = <'renew', A, pkNew>
  in
    [ In( <msg, signature> )
    , ServerDB(A, pkOld)
    ]
  --[ Eq(verify(signature, msg, pkOld),true()), Revoked(pkOld) ]->
    [ ServerDB(A, pkNew)
    , Out( pkOld )
    ]

axiom Eq_checks_succeed: "All x y #i. Eq(x,y)@i ==> x = y"

/*
lemma types [typing]:
  "All sk #i. Revoked(sk) @ i ==>
     ( (Ex #j. KU(sk) @ j & j < i)
     | (Ex #j. HonestKey(sk) @ j & j < i)
     )
  "
*/

/*
The following property proven in Moedersheim's paper is rather easy to
prove, as it depends only on the fact that secret keys are not leaked by
any other means than the "RenewKey" rule. The "RenewKey" rule always log's
that the key is "Revoked", which immediately implies the lemma below.

*/

// \S,H.
// iknows(inv(PK)).PK in db(S,H,valid)
// =>attack;
lemma In_Honest_Key_imp_Revoked [use_induction]:
  "All k #i #d. HonestKey(k) @ i & K(k) @ d ==>
      (Ex #r. Revoked(k) @ r)
  "

end
