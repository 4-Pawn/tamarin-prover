theory Keyserver begin

text{* The keyserver example from 
       "2010 - Moedersheim - Abstraction by Set-Membership". 
*}
 
/* Original Problem from

Problem: zebsKeyserver;

Types: 
Agent  : {a,b,c,i,s};
U      : {a,b,c};
S      : {s};
H      : {a,b};
D      : {c,i};
DU     : {c};
Sts    : {valid,revoked};
PK,NPK : value;
M1,M2  : untyped;

Sets:
ring(U), db(S,U,Sts);

Functions:
public sign/2, pair/2;
private inv/1;

Facts: 
iknows/1, attack/0;

Rules:

\Agent. => iknows(Agent);
iknows(sign(M1,M2)) => iknows(M2);
iknows(M1).iknows(M2) => iknows(sign(M1,M2));
iknows(pair(M1,M2)) => iknows(M1).iknows(M2);
iknows(M1).iknows(M2) => iknows(pair(M1,M2));
*/

builtin: signing

// The non-deterministic choice between the rules SetupHonestKey and
// SetupDishonestKey determines whether an agent is honest or not.

// \H,S. =[PK]=>iknows(PK).PK in ring(H).PK in db(S,H,valid);
rule SetupHonestKey:
    [ Fr(~sk)
    // , Fr(<'RegKey',$A>)  // every agent can setup at most one key
    ]
  --[ HonestKey(~sk) ]->
    [ Out(pk(~sk)), ClientKey($A, ~sk), ServerDB($A, ~sk) ]

// \S,DU. =[PK]=>iknows(PK).iknows(inv(PK)).PK in db(S,DU,valid);
rule SetupDishonestKey:
    [ In(sk)
    // , Fr(<'RegKey',$A>)  // every agent can setup at most one key
    ]
  -->
    [ ServerDB($A, sk) ]

// \H.
// iknows(PK).PK in ring(H)
// =[NPK]=>NPK in ring(H).iknows(sign(inv(PK),pair(H,NPK)));
rule RequestRenewKey:
    [ ClientKey($A, sk), Fr(~skNew) ]
  --[ HonestKey(~skNew) ]->
    [ Out( sign{'renew', $A, pk(~skNew)}sk )
    , ClientKey($A, ~skNew)
    ]

// \S,U.
// iknows(sign(inv(PK),pair(U,NPK))).PK in db(S,U,valid).
// forall U,Sts. NPK notin db(S,U,Sts)
// =>PK in db(S,U,revoked).NPK in db(S,U,valid).iknows(inv(PK));
rule RenewKey:
    [ In( sign{'renew', A, pk(skNew)}sk )
    , ServerDB(A, sk)
    ]
  --[ Revoked(sk) ]->
    [ ServerDB(A, skNew)
    , Out( sk )
    ]

// Typing lemma.
lemma types [typing]:
  "All sk #i. Revoked(sk) @ i ==>
     ( sk --| i 
     | (Ex #j. HonestKey(sk) @ j)
     )
  "
/*
The following property proven in Moedersheim's paper is rather easy to
prove, as it depends only on the fact that secret keys are not leaked by
any other means than the "RenewKey" rule. The "RenewKey" rule always log's
that the key is "Revoked", which directly implies the lemma below.

FIXME: Prove property that depends on ordering of revocation. For
example, DH-key exchange always succeeds for a protocol with an online
key-server. This crucially depends on the client not sending a renewal message
while he's waiting for the key confirmation.
*/


// \S,H.
// iknows(inv(PK)).PK in db(S,H,valid)
// =>attack;
lemma In_Honest_Key_imp_Revoked:
  "All sk #i #d. HonestKey(sk) @ i & K(sk) @ d ==>
      (Ex #r. Revoked(sk) @ r)
  "


end
