divert(-1)
changequote()
changequote(<!,!>)

dnl List of adversary capabilities
define(<!advCapabilities!>,<!
LKRothers
LKRactor
LKRafter 
LKRaftercorrect
SKR
RNR
SSR
!>)

define(<!firstElement!>,<!$1!>)
define(<!lastElement!>,<!ifelse($#,1,<!$1!>,<!lastElement(shift($@))!>)!>)

dnl Defaults
define(<!revealRNR!>,<!!>)
define(<!RealRevealRNR!>,<!, $1!>)	

dnl simpleIn
dnl
dnl is the second argument contained as a single word in the first?
dnl retrns -1 if not
dnl
dnl parameters: multiple word string, search string
define(<!simpleIn!>,<!regexp($1,<!\<$2\>!>)!>)

dnl occursIn
dnl
dnl does one of the arguments occur in the last?
dnl returns -1 if not, otherwise returns first element that does not
dnl
dnl note: needs to start with at least one argument
define(<!firstInLast!>,<!simpleIn(<!lastElement($@)!>,$1)!>)
define(<!occursIn!>,<!ifelse($#,1,-1,<!ifelse(firstInLast($@),-1,<!occursIn(shift($@))!>,$1)!>)!>)

dnl reduceEmpty
dnl
dnl if a string is visually empty, make it completely empty
define(<!reduceEmpty!>,<!ifelse(regexp(<!$1!>,<!^\s*$!>),-1,<!$1!>,<!!>)!>)

dnl joinWith
dnl
dnl Python like join function that inserts separators.
dnl
dnl parameters: separator, argument list
dnl
define(<!joinWithStarted!>,<!ifelse(eval($#<2),1,<!!>,
<!ifelse(<!reduceEmpty(<!$2!>)!>,<!!>,
<!joinWithStarted(<!$1!>,shift(shift($@)))!>,
<!<!$1!><!$2!>joinWithStarted(<!$1!>,shift(shift($@)))!>)!>)!>)

define(<!joinWith!>,<!ifelse(eval($#<2),1,<!!>,
<!ifelse(<!reduceEmpty($2)!>,<!!>,
<!joinWith(<!$1!>,shift(shift($@)))!>,
<!<!$2!>joinWithStarted(<!$1!>,shift(shift($@)))!>)!>)!>)

dnl is the security model known?
dnl
dnl return -1 if not present as single word
dnl
dnl parameters: rule name
dnl
define(<!advFind!>,<!simpleIn(advCapabilities,$1)!>)

dnl Add LKR post rule if needed
dnl
dnl parameters: security model string
define(<!addLKRconclusion!>,<!
ifelse(index(<!$1!>,LKR),-1, ,<!
// LKR rule is already implemented by default (hard-coded)
!>)!>)

dnl Add SKR post rule if needed
dnl
dnl parameters: security model string
define(<!addSKRconclusion!>,<!
ifelse(index(<!$1!>,SKR),-1, ,<!
Add SKR rule conclusion
TODO write
!>)!>)

dnl Add rules for correctly covering each capability's conclusion
dnl
dnl parameters: security model string
define(<!addAdversaryConclusions!>,<!
addLKRconclusion($1)
addSKRconclusion($1)
!>)

dnl Stacking rule premises parsing
dnl
dnl 1. LKRothers
dnl 2. LKRactor
dnl 3. LKRafter
dnl 4. LKRaftercorrect

dnl 4. Add LKR rule premises for LKRaftercorrect
dnl
dnl Final LKR rule
dnl
dnl TODO: Not correct yet (just identical to LKRafter for now)
dnl
dnl parameters: model, end of test node, actor, peer
define(<!addCondLKRafc!>,
<!ifelse(occursIn(<!LKRaftercorrect!>,$1),-1,<!!>, <! (#rN >+> $2 ) AND!>) !>)

dnl 3. Add LKR rule premises for LKRafter
dnl
dnl calls number 4: LKRaftercorrect
dnl
dnl parameters: model, end of test node, actor, peer
define(<!addCondLKRafter!>,
<!ifelse(occursIn(LKRafter,$1),-1,<!!>,
<! (#rN >+> $2 ) AND!>) addCondLKRafc($@) !>)

dnl 2. Add LKR rule premises for LKRactor
dnl
dnl calls number 3: LKRafter
dnl
dnl parameters: model, end of test node, actor, peer
define(<!addCondLKRactor!>,
<!ifelse(occursIn(LKRactor,$1),-1,<!!>,
<! not(Agv = $3) AND!>) addCondLKRafter($@) !>)

dnl 1. Add LKR rule premises for LKRothers
dnl
dnl calls number 2: LKRactor
dnl
dnl parameters: model, end of test node, actor, peer
define(<!addCondLKRothers!>,
<!ifelse(occursIn(LKRothers,$1),-1,<!!>,
<! ((Agv = $3) | (Agv = $4)) AND!>) addCondLKRactor($@) !>)

dnl Combine the previous
dnl 
dnl parameters: model, end of test node, actor, peer
define(<!addCondLKRall!>,<!addCondLKRothers($@)!>)


dnl Add LKR rule premises for properties
dnl
dnl Cut off any final comma
dnl
dnl parameters: model, end of test node, actor, peer
dnl
define(<!addLKRPremise!>,<!ifelse(index($1,LKR),-1, ,<!
(Ex #rN Agv. rN :> ( LTSR(Agv) AND 
addCondLKRall($@) CONJEND ) )!>)!>)

dnl Add rule premises for properties
dnl
dnl parameters: model, end of test node, actor, peer
dnl
define(<!addAdversaryPremise!>,<!patsubst(<!addLKRPremise($@)!>,<!AND\s*END!>,<!x!>)!>)
dnl define(<!addAdversaryPremise!>,<!addLKRPremise($@)!>)

dnl =============================================
dnl Testing goes below
dnl =============================================
dnl

define(<!mySecModel!>, <!LKRothers LKRaftercorrect LKRafter LKRactor SKR!>)
define(<!DolevYao!>, <!LKRothers!>)

dnl Test 0 (just add the relevant rules)
dnl ----------------
dnl addAdversaryConclusions(mySecModel)
dnl 
dnl Test 1 (complex)
dnl ----------------
dnl addAdversaryPremise(mySecModel,testEnd,A,B)
dnl 
dnl Test 2 (Dolev Yao)
dnl ----------------
dnl addAdversaryPremise(DolevYao,testEnd,A,B)
dnl 
dnl Test
dnl 
dnl addLKRPremise(mySecModel,v,A,B)
dnl patsubst(<!addLKRPremise(mySecModel,v,A,B)!>,<!AND\s*CONJEND!>,<!x!>)

dnl ******************************
dnl I give up.
dnl Hardcoding.
dnl ******************************
dnl External
dnl No rules
dnl ******************************
define(<!useModelEXT!>,<!
define(<!addAdversaryConclusions!>,<!!>)
define(<!addAdversaryPremise!>,<! (Ex #rN Agv. (rN :> LTSR(Agv))) !>)
!>)

dnl ******************************
dnl Dolev-Yao
dnl LKRothers
dnl ******************************
define(<!aapDY!>,<! (Ex #rN Agv. ( rN :> LTSR(Agv) & ((Agv = $2) | (Agv = $3)))) !>)

define(<!useModelDY!>,<!
define(<!addAdversaryConclusions!>,<!!>)
define(<!addAdversaryPremise!>,defn(<!aapDY!>))
!>)

dnl ******************************
dnl Dolev-Yao and KCI
dnl LKRothers LKRactor
dnl ******************************
define(<!aapDYKCI!>,<! (Ex #rN . rN :> LTSR($3) ) !>)

define(<!useModelDYKCI!>,<!
define(<!addAdversaryConclusions!>,<!!>)
define(<!addAdversaryPremise!>,defn(<!aapDYKCI!>))
!>)


dnl ******************************
dnl PFS
dnl LKRafter
dnl ******************************
define(<!aapPFS!>,<! (Ex Agv . LTSR(Agv) >+> $1 ) !>)

define(<!useModelPFS!>,<!
define(<!addAdversaryConclusions!>,<!!>)
define(<!addAdversaryPremise!>,defn(<!aapPFS!>))
!>)

dnl ******************************
dnl RNR
dnl RNR
dnl ******************************
define(<!useModelRNR
define(<!revealRNR!>,defn(<!RealRevealRNR!>))
define(<!addAdversaryConclusions!>,<!  !>)
define(<!addAdversaryPremise!>,<! (Ex Agv #u. u :> LTSR(Agv) ) !>)
!>)

dnl ******************************
dnl SKR
dnl SKR
dnl ******************************
define(<!aapSKR!>,<! dnl
  ( (Ex #u. u :> SeKeyCompr(k,< $2,$3,$4,$5 >))	
  | (Ex Agv #u. u :> LTSR(Agv) )		
  ) !>)

define(<!useModelSKR!>,<!
define(<!addAdversaryConclusions!>,<!
rule SeKey_compr: 
   [ SeKey(k, params) ]
   -->
   [ SeKeyCompr(k, params), Out(k) ]
!>)
define(<!addAdversaryPremise!>,defn(<!aapSKR!>))
!>)

dnl Options:
dnl
dnl useModelDY
dnl useModelDYKCI
dnl useModelPFS
dnl useModelRNR
dnl useModelSKR
dnl useModelEXT
dnl
useModelDY

divert
