theory Signed_DH
begin

section{* A Simple Signed Diffie-Hellman Key-Exchange Protocol *}

/* 
  Syntax:
    '1'  denotes a public constant named 1
    ~x   denotes a variable of sort fresh-message
    $x   denotes a variable of sort public-message
    x    denotes a variable of sort message
*/



subsection{* Protocol model *}


rule SDH_I_1:
  [ Fr( ~ni ) ]
  -->
  [ SDH_I_1( $I, $R, ~ni ),
    Out( <$I, 'g'^~ni, sign{<'1', 'g'^~ni, $R>}sk(lts($I))> ) ]

rule SDH_I_2:
  [ SDH_I_1( $I, $R, ~ni ),
    In( <$R, hkr, sign{<'2', hkr, $I>}sk(lts($R))> ) ] 
  -->
  [ SDH_I_2( $I, $R, ~ni, hkr ) 
  , SeKeyI( hkr^~ni, <$I, $R, 'g'^~ni, hkr> ) 
  ]

rule SDH_R_1:
  [ Fr( ~nr ), 
    In( <I, hki, sign{<'1', hki, $R>}sk(lts(I))> ) ] 
  -->
  [ SDH_R_1( $R, ~nr, I, hki )
  , Out( <$R, 'g'^~nr, sign{<'2', 'g'^~nr, I>}sk(lts($R))> ) 
  , SeKeyR(hki^~nr, <I, $R, hki, 'g'^~nr> )
  ]


subsection{* Adversary Model *}

rule Reveal_lts:
  [ In( m ) ] --> [ LTSR( m ), Out( lts(m) ) ]

rule Reveal_pk:
  [ ] --> [ Out( pk(lts($m)) ) ]


/* The following rules are always part of the adversary model

** Fr Data Generation **
***************************

   rule Fr:
     [ ] --> [ Fr( ~x ) ]

   rule Reveal_fresh:
     [ Fr( ~m ) ] --> [ Out( ~m ) ]
   


** Communication between adversary and protocol **
**************************************************
   
   rule In:
     [ m ] --> [ In( m ) ]
   
   rule Learn:
     [ Out( m ) ] --> [ m ]

*/

subsection{* Secrecy Properties *}

lemma I_secrecy_ni:
  "not( v :> SDH_I_1( I, R, ni ) & u :> In(ni) )"

lemma R_secrecy_nr:
  "not( v :> SDH_R_1( R, nr, I, hki ) & u :> In(nr) )"

lemma I_secrecy_key:
  "v :> SeKeyI(k, <I, R, hki, hkr>) & vk :> In(k)
  ==> 
  (Ex #vr. vr :> LTSR(R) & vr >+> v)"

lemma R_secrecy_key:
  "v :> SeKeyR(k, <R, I, hki, hkr>) & vk :> In(k)
  ==> 
  (Ex #vr. vr :> LTSR(I) & vr >+> v)"


subsection{* Authentication Properties *}

lemma I_niagree:
  "v :> SeKeyI(k, <I, R, hki, hkr>)
   ==> 
   ( Ex #u uk uhki. u :> SeKeyR(uk, <I, R, uhki, hkr>) & u >+> v ) | 
   ( Ex #rev. rev :> LTSR(R) & rev >+> v)
  "




/* Work in progress:
********************

// Session-key compromise

rule SeKeyI_compr: 
   [ SeKeyI(k, params) ]
   -->
   [ SeKeyICompr(k, params), Out(k) ]


rule SeKeyR_compr: 
   [ SeKeyR(k, params) ]
   -->
   [ SeKeyRCompr(k, params), Out(k) ]


lemma I_secrecy_key:
  "vkey :> SeKeyI(k, <I, R, hki, hkr>) & vk :> In(k)
  ==> 
    (Ex #vr. vr :> LTSR(R) & vr >+> vkey) |
    (Ex #vc. vc :> SeKeyICompr(k, <I, R, hki, hkr>) |
    (Ex #vc. vc :> SeKeyRCompr(k, <I, R, hki, hkr>))
  "



// Session-key consistency

lemma SeKey_consistency_I_R:
  "v :> SeKeyI(k, <vI, vR, vhki, vhkr>) &
   u :> SeKeyR(k, <uI, uR, uhki, uhkr>)
   ==> 
   (<vI, vR, vhki, vhkr> = <uI, uR, uhki, uhkr>) |
   ( Ex #rev. rev :> LTSR(vR) & rev >+> v) |
   ( Ex #rev. rev :> LTSR(vI) & rev >+> v)
  "

*/

end

