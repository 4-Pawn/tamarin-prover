theory KAS2_eCK_PFS
begin

builtin: diffie-hellman, hashing, asymmetric-encryption

section{* KAS2 *}

functions: KDF/1
functions: MAC/2

/*
 * Protocol:	KAS2
 * Modeler: 	Cas Cremers
 * Date: 	April 2012
 * Source:	"A Generic Variant of NISTS's KAS2 Key Agreement * Protocol"
 * 		Chatterjee, Menezes, Ustaoglu, 2011
 *
 * Status: 	drafting
 */

/* Protocol rules */

/* Generate long-term keypair */
rule Register_pk:
  let pkA = pk(~ltkA)
  in
  [ Fr(~ltkA) ] 
  --> 
  [ !Ltk($A, ~ltkA), !Pk($A, pkA), Out(pkA) ]

/* Initiator */
rule Init_1:
  let c1 = aenc{ ~m1 }pkR
  in
   [ Fr( ~m1 ), !Ltk( $I, ~lkI ), !Pk($R,pkR) ]
   --[ Sid( ~m1, $I, $R, 'Init', c1) ]->
   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1), !Ephk(~m1), Out( c1 ) ]

rule Resp_1:
  let m1 = adec(c1, ~lkR)
      c2 = aenc{ ~m2 }pkI
      key = KDF(< m1, ~m2, $I, $R, c1, c2 >)
      macR = MAC(key, (< 'Resp', $R, $I, c2, c1 >) )
  in
   [ Fr( ~m2 ), In( c1 ), !Ltk( $R, ~lkR ), !PK($I,pkI) ]
   --[ Sid( ~m2, $R, $I, 'Resp', c1, c2) ]->
   [ Resp_1(~m2, $I, $R, ~lkR, m1, ~m2, c1, c2, macR ), !Ephk(~m2), Out(< c2 , macR >) ]

rule Init_2:
  let m2 = adec(c2, ~lkI)
      key = KDF(< ~m1, m2, $I, $R, c1, c2 >)
      macR = MAC( key, (< 'Resp', $R, $I, c2, c1 >) )
      macI = MAC( key, (< 'Init', $I, $R, c1, c2 >) )
  in
   [ Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 ) , In(< c2, macR >) ]
   --[ Sid( ~m1, $I, $R, 'Init', c1, c2 ), Sessk( ~m1, key) ]->
   [ Out( macI ), !Sessk( ~m1, key ) ]

rule Resp_2:
  let 
      key = KDF(< m1, ~m2, $I, $R, c1, c2 >)
      macI = MAC( key, (< 'Init', $I, $R, c1, c2 >) )
  in
   [ Resp_1(~m2, $I, $R, ~lkR, m1, ~m2, c1, c2), In( macI ) ]
   --[ Sid( ~m2, $I, $R, 'Resp', c1, c2 ) , Sessk( ~m2, key) ]->
   [ !Sessk( ~m2, key ) ]


/* Key Reveals for the eCK model */
rule Sessk_reveal: 
   [ !Sessk(~tid, k) ]
   --[ SesskRev(~tid) ]->
   [ Out(k) ]

rule Ltk_reveal:
   [ !Ltk($A, lkA) ]
   --[ LtkRev($A) ]->
   [ Out(lkA) ]

rule Ephk_reveal:
   [ !Ephk(~ekA) ]
   --[ EphkRev(~ekA) ]->
   [ Out(~ekA) ]


/* Security properties */

/*
lemma key_agreement_reachable:
  "not (Ex #i1 #i2 ekI ekR I R k hkI hkR.
          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)"
*/

/* An attack is valid in eCK if the session key of the test session is deduced and
   the test session is clean.
*/
lemma eCK_initiator_key:
  "not (Ex #i1 #i2 #ik ekI I R k hkI hkR.
            Sid(ekI, I, R, 'Init', hkI, hkR) @ i1 & K( k ) @ i2 & Sessk(ekI, k) @ ik

            /* Not both longterm-key-reveal _and_ ephemeral-key-reveal
	     * for test thread. */
            & not(Ex #i3 #i4. LtkRev( I ) @ i3 & EphkRev( ekI ) @ i4)

            /* No session-key-reveal of test thread. */
            & not(Ex #i3. SesskRev( ekI ) @ i3 )

            /* No session-key-reveal for matching session. */
            & not(Ex #i3 #i4 #i5 ekR kpartner.
                     Sid( ekR,R,I,'Resp',hkI,hkR) @i3
		   & Sessk(ekR, kpartner) @i4
		   & SesskRev( ekR ) @ i5 )

            /* Not both long-term-key-reveal and ephemeral-key-reveal
	     * for matching session */
            & not(Ex #i3 #i4 #i5 ekR.
                    Sid( ekR,R,I,'Resp',hkI,hkR) @i3
		  & LtkRev( R ) @ i4
		  & EphkRev( ekR ) @ i5 )

	    /* If there is a longterm key reveal, then it must occur after the initiator is finished
               or there must be a matching session
            */
            & (All #i3. LtkRev( R ) @ i3 ==> 
                  (i1 < i3)
	          |  (Ex #i4 ekR .
                        Sid( ekR,R,I,'Resp',hkI,hkR) @i4)))"

/* An attack is valid in eCK if the session key of the test session is deduced and
   the test session is clean.
*/
lemma eCK_responder_key:
  "not (Ex #i1 #i2 #ik ekR I R k hkI hkR.
            SidR_1(ekR, I, R, hkI, hkR, k) @ i1 & K( k ) @ i2 & Sessk( ekR, k) @ ik

            /* Not longterm-key-reveal _and_ ephemeral-key-reveal of actor . */
            & not(Ex #i3 #i4. LtkRev( R ) @ i3 & EphkRev( ekR ) @ i4)

            /* Not session-key-reveal of test thread. */
            & not(Ex #i3. SesskRev( ekR ) @ i3 )

            /* Not session-key-reveal of partner thread. Note that we use SidI_2 here.
	       A session key reveal can only happen after SidI_2 is logged anyways.
	    */
            & not(Ex #i3 #i4 #i5 ekI kpartner.
	           ( Sid( ekI, R, I, 'Init', hkI ) @ i3
	           | Sid( ekI, R, I, 'Init', hkI, hkR ) @ i3 )
		   & Sessk( ekI, kpartner ) @ i5
		   & SesskRev( ekI ) @ i4 )

            /* If there is a partner thread, then not long-term-key-reveal and ephemeral-key-reveal. */
            & not(Ex #i3 #i4 #i5 ekI.
	           ( Sid( ekI, R, I, 'Init', hkI ) @ i3
	           | Sid( ekI, R, I, 'Init', hkI, hkR ) @ i3 )
		  & LtkRev( I ) @ i4
		  & EphkRev( ekI ) @ i5 )

	    /* If there is a longterm key reveal, then it must occur after the responder is finished
               or there must be a matching session.
	    */
            & (All #i3. LtkRev( I ) @ i3 ==>
                  (i1 < i3)
	          |  (Ex #i4 ekI.
	           ( Sid( ekI, R, I, 'Init', hkI ) @ i4
	           | Sid( ekI, R, I, 'Init', hkI, hkR ) @ i4 )
                     )))"

end
