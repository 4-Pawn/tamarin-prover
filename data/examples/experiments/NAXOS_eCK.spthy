theory NAXOS_eCK
begin

builtin: diffie-hellman

section{* NAXOS *}

/*
 * Protocol:	NAXOS
 * Modeler: 	Cas Cremers, Benedikt Schmidt
 * Date: 	January 2012/April 2012
 * Source:	"Stronger Security of Authenticated Key Exchange"
 * 		LaMacchia, Lauter, Mityagin, 2007
 * Property: 	eCK security
 *
 * Status: 	Working
 *
 * Notes:	New version with 'let' blocks and refactored setup.
 * 		This is an experimental spec to figure out better ways
 * 		of modeling AKE protocols.
 */

functions: H/1
functions: KDF/1

/* Protocol rules */

/* In the description in the paper, we omitted the sorts. 
 * In this description they are made explicit.
 * '$A' is equivalent to 'A:pub'
 * '~x' is equivalent to 'x:fresh'
 */

/* Generate long-term keypair */
rule generate_ltk:
   let pkA = 'g'^~lkA 
   in
   [ Fr(~lkA) ] 
   --[ RegKey($A) ]->
   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]

/* Initiator */
rule Init_1:
  let exI = H(<~ekI, ~lkI >)
      hkI = 'g'^exI
  in
   [   Fr( ~ekI ), !Ltk( $I, ~lkI ) ]
   --[ Sid( ~ekI, $I, $R, < 'Init', $I, $R, hkI > ) ]->
   [   Init_1( ~ekI, $I, $R, ~lkI, hkI )
     , !Ephk(~ekI, ~ekI)
     , Out( hkI ) ]

rule Init_2:
  let pkR    = 'g'^~lkR
      exI    = H(< ~ekI, ~lkI >)
      seskey = KDF(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) 
  in
   [   Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R, pkR ) ]
   --[ Sid( ~ekI, $I, $R, < 'Init', $I, $R, hkI, Y >) 
     , Match( ~ekI, < 'Resp', $R, $I, hkI, Y >)
     , Accept( ~ekI, $I, $R, seskey) 
     ]->
   [   !Sessk( ~ekI, seskey) ]

/* Responder */
rule Resp_1:
  let pkI    = 'g'^~lkI
      exR    = H(< ~ekR, ~lkR >)
      hkr    = 'g'^exR
      seskey = KDF(< pkI^exR, X^~lkR, X^exR, $I, $R >) 
  in
   [   In( X ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk($I, pkI) ]
   --[ Sid( ~ekR, $R, $I, <'Resp', $R, $I, X, hkr >) 
     , Match( ~ekR, <'Init', $I, $R, X, hkr> )
     , Accept( ~ekR, $R, $I, seskey )
     ]->
   [   Out( hkr ),
       !Ephk(~ekR, ~ekR),
       !Sessk( ~ekR, seskey) ]

/* Key Reveals for the eCK model */
rule Sessk_reveal: 
   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]

rule Ltk_reveal:
   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]

rule Ephk_reveal:
   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]


/* Security properties */
/*
lemma eCK_same_key:
  " // If every agent registered at most one public key
  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))
  ==> // then matching sessions accept the same key
  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .
              Accept(s , k ) @ i1 
	    & Accept(ss, kk) @ i2
	    & Sid(s, A, B, minfo) @ i3
	    & Match(ss, minfo) @i4
	    & not( k = kk )
  ) )"
*/

lemma eCK_key_secrecy:
  /* 
   * The property specification very closely follows the original eCK
   * (ProvSec) paper:
   *
   * If there exists a Test session whose key k is known to the
   * Adversary, then...
   */
  "(All #i1 #i2 Test A B k .
    Accept(Test, A, B, k) @ i1 & K( k ) @ i2 
    ==> ( 
    /* ... the Test session must be "not clean".
     * Test is not clean if one of the following has happened:
     */
    /* 1a. session-key-reveal of test thread. */
      (Ex #i4. SesskRev( Test ) @ i4 )

    /* 1b. session-key-reveal of matching session */
    | (Ex MatchingSession #i4 #i5 C D ms.
    	   /* ( MatchingSession's 'ms' info matches with Test ) */
           ( Sid ( MatchingSession, C, D, ms ) @ i4 & Match( Test, ms ) @ i5)
	   & (
	     (Ex #i6. SesskRev( MatchingSession ) @ i6 )
	   )
      )
    /* 2. If matching session exists and ... */
    | (Ex MatchingSession #i4 #i5 C D ms.
    	   /* ( MatchingSession's 'ms' info matches with Test ) */
           ( Sid ( MatchingSession, C, D, ms ) @ i4 & Match( Test, ms ) @ i5)
	   & (
	   /* 2a. reveal either both sk_A and esk_A, or */
	     (Ex #i6 #i7. LtkRev  ( A ) @ i6  & EphkRev ( Test  ) @ i7 )
	   /* 2b. both sk_B and esk_B */
	   | (Ex #i6 #i7. LtkRev  ( B ) @ i6  & EphkRev ( MatchingSession ) @ i7 )
	   )
      )
    /* 3. No matching session exists and ... */
    | ( ( not(Ex MatchingSession #i4 #i5 C D ms.
    	   /* ( MatchingSession's 'ms' info matches with Test ) */
           Sid ( MatchingSession, C, D, ms ) @ i4 & Match( Test, ms ) @ i5 ) )
	   & (
	   /* 3a. reveal either sk_B, or */
	     (Ex #i6    . LtkRev (B) @ i6 )
	   /* 3b. both sk_A and esk_A */
	   | (Ex #i6 #i7. LtkRev (A) @ i6 & EphkRev ( Test ) @ i7 )
	   )
      )
    )
  )"

end
