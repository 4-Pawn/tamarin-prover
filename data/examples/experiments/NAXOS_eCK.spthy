theory NAXOS_eCK
begin

builtin: diffie-hellman, hashing

section{* NAXOS *}

/*
 * Protocol:	NAXOS
 * Modeler: 	Cas Cremers, Benedikt Schmidt
 * Date: 	January 2012/April 2012
 * Source:	"Stronger Security of Authenticated Key Exchange"
 * 		LaMacchia, Lauter, Mityagin, 2007
 * Property: 	eCK security
 *
 * Status: 	New version with 'let' blocks and refactored setup.
 */

functions: H/1
functions: KDF/1

/* Protocol rules */

/* In the description in the paper, we omitted the sorts. 
 * In this description they are made explicit.
 * '$A' is equivalent to 'A:pub'
 * '~x' is equivalent to 'x:fresh'
 */

/* Generate long-term keypair */
rule generate_ltk:
   let pkA = 'g'^~lkA 
   in
   [ Fr(~lkA) ] 
   --[ RegKey($A) ]->
   [ !Ltk( $A, ~lkA ), !Pk( $A, pkA ), Out( pkA ) ]

/* Initiator */
rule Init_1:
  let exI = H(<~ekI, ~lkI >)
      hkI = 'g'^exI
  in
   [   Fr( ~ekI ), !Ltk( $I, ~lkI ) ]
   --[ Sid( ~ekI, $I, $R, < 'Init', $I, $R, hkI > ) ]->
   [   Init_1( ~ekI, $I, $R, ~lkI, hkI )
     , !Ephk(~ekI, ~ekI)
     , Out( hkI ) ]

rule Init_2:
  let pkR    = 'g'^~lkR
      exI    = H(< ~ekI, ~lkI >)
      seskey = KDF(< Y^~lkI, pkR^exI, Y^exI, $I, $R >) 
  in
   [   Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R, pkR ) ]
   --[ Sid( ~ekI, $I, $R, < 'Init', $I, $R, hkI, Y >) 
     , Match( ~ekI, < 'Resp', $R, $I, hkI, Y >)
     , Accept( ~ekI, seskey) 
     ]->
   [   !Sessk( ~ekI, seskey) ]

/* Responder */
rule Resp_1:
  let pkI    = 'g'^~lkI
      exR    = H(< ~ekR, ~lkR >)
      hkr    = 'g'^exR
      seskey = KDF(< pkI^exR, X^~lkR, X^exR, $I, $R >) 
  in
   [   In( X ), Fr( ~ekR ), !Ltk($R, ~lkR), !Pk($I, pkI) ]
   --[ Sid( ~ekR, $R, $I, <'Resp', $R, $I, X, hkr >) 
     , Match( ~ekR, <'Init', $I, $R, X, hkr> )
     , Accept( ~ekR, seskey )
     ]->
   [   Out( hkr ),
       !Ephk(~ekR, ~ekR),
       !Sessk( ~ekR, seskey) ]

/* Key Reveals for the eCK model */
rule Sessk_reveal: 
   [ !Sessk(~tid, k) ] --[ SesskRev(~tid) ]-> [ Out(k) ]

rule Ltk_reveal:
   [ !Ltk($A, lkA) ] --[ LtkRev($A) ]-> [ Out(lkA) ]

rule Ephk_reveal:
   [ !Ephk(~s, ~ek) ] --[ EphkRev(~s) ]-> [ Out(~ek) ]


/* Security properties */
/*
lemma eCK_same_key:
  " // If every agent registered at most one public key
  (All A #i #j. RegKey(A)@i & RegKey(A)@j ==> (#i = #j))
  ==> // then matching sessions accept the same key
  (not (Ex #i1 #i2 #i3 #i4 s ss k kk A B minfo .
              Accept(s , k ) @ i1 
	    & Accept(ss, kk) @ i2
	    & Sid(s, A, B, minfo) @ i3
	    & Match(ss, minfo) @i4
	    & not( k = kk )
  ) )"
*/

lemma eCK_key_secrecy:
  "not (Ex #i1 #i2 #i3 s A B minfo k .
            Sid(s, A, B, minfo) @ i1 & K( k ) @ i2 & Accept(s, k) @ i3

            /* No session-key-reveal of test thread. */
            & not(Ex #i4. SesskRev( s ) @ i4 )

	    /* If matching session exists (for all matching sessions...) */
	    & (All ss #i4 #i5 C D ms.
	           ( Sid ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5)
		     ==>
		   ( not(Ex #i6 #i7 kpartner. Accept(ss, kpartner) @ i6 & SesskRev( ss ) @ i7 )
		   & not(Ex #i6 #i7. LtkRev  ( A ) @ i6  & EphkRev ( s  ) @ i7 )
		   & not(Ex #i6 #i7. LtkRev  ( B ) @ i6  & EphkRev ( ss ) @ i7 )
		   )
	      )
	    /* No matching session exists */
	    & ( ( not(Ex ss #i4 #i5 C D ms.
	           Sid ( ss, C, D, ms ) @ i4 & Match( s, ms ) @ i5 ) )
		     ==>
		   ( not(Ex #i6    . LtkRev (B) @ i6 )
		   & not(Ex #i6 #i7. LtkRev (A) @ i6 & EphkRev ( s ) @ i7 )
		   )
	      )
  )"

end
