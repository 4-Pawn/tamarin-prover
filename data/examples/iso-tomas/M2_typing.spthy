theory Mechanism2_Typing
begin

builtins: symmetric-encryption
section{*  *}

/*
 * Protocol:	ISO Key Exchange Mechanism 2
 * Modeler: 	Tomas Zgraggen, Simon Meier
 * Date: 	May 2012
 * Source:	"Stronger Security of Authenticated Key Exchange"
 * 		LaMacchia, Lauter, Mityagin, 2007
 * Property: 	a sort of eCK security
 *
 * Status: 	Working. Demonstrates the use of a typing invariant.
 */


//the protocol
//A->B: {F}K_AB,T

// Generation of unidirectional symmetric long-term keys
rule GenerateKeyUnidirectional:
    [ Fr(~kAB)]
  -->
    [ !SK($A, $B, ~kAB) ]


//protocol rules
// NOTE: Session-identifier too strong if used for the full message.
rule A_1:
  let m1_core = senc{'1',~F}kAB
      m1_full = <m1_core, ~T>
      key = ~F
  in
    // get thread identifier, generate F, know kAB, allow T to be injected
    [ Fr(~tid)
    , Fr(~F)
    , Fr(~T)
    , !SK($A,$B,kAB)
    // , In(T)
    ]
  --[ Accept(~tid, $A, $B, key)
    , Sid  ( ~tid, <'Init', $A, $B, m1_core> )
    , Match( ~tid, <'Resp', $B, $A, m1_core> )
    , GEN_Sessk(key)
    ]->
    [ Out(m1_full)
    , !Sessk(~tid, key)
    ]


rule B_1:
  let m1_core = senc{'1', key}kAB
      m1_full = <m1_core, T>
  in
    [ Fr(~tid)
    , !SK($A,$B,kAB)
    , In(m1_full)
    ]
  --[ Accept(~tid, $B, $A, key)
    , Sid  ( ~tid, <'Resp', $B, $A, m1_core>)
    , Match( ~tid, <'Init', $A, $B, m1_core>)
    ]->
    [ !Sessk(~tid, key) ]


//key reveal rule(s)
rule Ltk_Reveal_Dir1:
    [ !SK(A, B, kAB) ]
  --[ Ltk_Reveal(A)  ]->
    [ Out(kAB) ]

//key reveal rule(s)
rule Ltk_Reveal_Dir2:
    [ !SK(B, A, kAB) ]
  --[ Ltk_Reveal(A)  ]->
    [ Out(kAB) ]

rule Sesskey_Reveal:
    [ !Sessk(tid, k)]
  --[ SessKey_Reveal(tid)
    , OUT_Sessk(k)
    ]->
    [ Out(k) ]

// A typing invariant for session keys. It relates the point of sending them
// to the intruder with their creation or the sending of a key by the
// intruder.
lemma typing_invariant [typing]:
  "All k #i.
      // Every session key sent to the intruder
      OUT_Sessk(k) @ i
      ==>
      // was either freshly generated
      (Ex #o. GEN_Sessk(k) @ o)
      |
      // or known by the intruder before sending it back to the intruder.
      (Ex f #o. KU(f,k) @ o & o < i)
  "

// Some secrecy property, which is actually violated because the matching
// session requirement is too strong to identify all partner threads deriving
// the same session-key.
lemma key_secrecy:
// if there is a test session of which the adversary knows the session key...

// " ( (All A B #i1 #i2. GenKey(A, B) @ i1 & GenKey(A, B) @ i2 ==> #i1 = #i2)
//   & (All x #i. InEq(x, x) @ i ==> F)
//   )
//   ==>
"
  (All Test A B sessk #i1 #i2. (
      Accept(Test,A,B,sessk) @ i1
    & K(sessk) @ i2
    // We need to assume that Test and Other have a predefined ltk. Why?
    // & Get_key(Test,Other,ltk) @ i0
          ==> (
         //there has been a use of one of these "illegal rules" (otherwise the
         //protocol is unsafe) session is unclean if one of the following has
         //happened:

         //1.a) Test-Sessions sesskey has been revealed
         (Ex #i3. SessKey_Reveal(Test) @ i3)

         |

         //1.b) a partner thread exists and its sesskey has been revealed
     (Ex data #i3 #i4 #i5 someOther.
                Sid(Test, data) @ i3
              & Match(someOther, data) @ i4
              // & not(Test = Other)
              & SessKey_Reveal(someOther) @ i5
         )

         |

         //2.) the most general case here is to reveal Test's and Other's ltk,trivially breaking security. This has been split into multiple cases for modularity:
         (Ex #i3. Ltk_Reveal(A) @ i3) // The most general case

         |

         (Ex #i3. Ltk_Reveal(B) @ i3) // The most general case
/*
         //2.a) partner thread exists and the symmetric longterm key between Other and Test has been revealed
         //(since Other's ltk is equal to Test's ltk, we automatically also reveal test's ltk. this trivially breaks security.)
         (Ex data #i3 #i4.
                (Sid(sessk,Test,Other,data,ltk) @ i3 & Match(sessk,Other,Test,data,ltk) @ i4 & not(Test = Other) & (Ex #i5. Key_Reveal(ltk) @ i5))
         )

         |

         //2.b) partner thread does not exist (either because adversary corrupted the session data, or Test is talking to itself), and the ltk between Other and Test is revealed
         ((not(Ex #i3 #i4 data. (Sid(sessk,Test,Other,data,ltk) @ i3 & Match(sessk,Other,Test,data,ltk) @ i4)) | (Test = Other))
           & (Ex #i5. Key_Reveal(ltk) @ i5)
         )*/

        )

        //TODO: split/merge these cases as needed

))"




end
