theory TPM_Envelope_attack_on_nonrandom_encryption begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, sign/2, snd/1,
           true/0, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

rule (modulo E) PCR_Init:
   [ Fr( ~aik ) ]
  --[ PCR_Init( ), PCR_Write( 'pcr0' ), DiffProtoPCR_Init( ) ]->
   [ PCR( 'pcr0' ), PCR_Write( 'pcr0' ), !AIK( ~aik ), Out( pk(~aik) )
   ]

rule (modulo E) PCR_Extend:
   [ PCR_Write( x ), PCR( x ), In( y ) ]
  --[ PCR_Write( h(<x, y>) ), DiffProtoPCR_Extend( ) ]->
   [ PCR( h(<x, y>) ), PCR_Write( h(<x, y>) ) ]

rule (modulo E) PCR_CertKey:
   [ !AIK( aik ), !KeyTable( lock, sk ) ]
  --[ DiffProtoPCR_CertKey( ) ]->
   [ Out( sign(<'certkey', lock, pk(sk)>, aik) ) ]

rule (modulo E) PCR_Quote:
   [ PCR( x ), !AIK( aik ) ]
  --[ PCR_Read( x ), DiffProtoPCR_Quote( ) ]->
   [ Out( sign(<'certpcr', x>, aik) ), PCR( x ) ]

rule (modulo E) PCR_Unbind:
   [ PCR( x ), !KeyTable( x, sk ), In( aenc(m, pk(sk)) ) ]
  --[ PCR_Unbind( x, sk, m ), PCR_Read( x ), DiffProtoPCR_Unbind( )
  ]->
   [ PCR( x ), Out( m ) ]

rule (modulo E) Alice1:
   [ Fr( ~n ), PCR( x ), PCR_Write( x ) ]
  --[ PCR_Write( h(<x, ~n>) ), DiffProtoAlice1( ) ]->
   [ PCR( h(<x, ~n>) ), PCR_Write( h(<x, ~n>) ), Alice1( ~n ) ]

rule (modulo E) Alice2:
   [
   Alice1( n ), Fr( ~s ), !AIK( aik ),
   In( sign(<'certkey', h(<h(<'pcr0', n>), 'obtain'>), pk>, aik) )
   ]
  --[ Secret( ~s ), DiffProtoAlice2( ) ]->
   [ Out( aenc(~s, pk) ), Alice2( n, ~s ), Alice2reveal( ~s ) ]

rule (modulo E) Challenge:
   [ Alice2reveal( ~s ), Fr( ~f ) ]
  --[ Challenge( ~s ), DiffProtoChallenge( ) ]->
   [ Out( diff(~s, ~f) ) ]

RHS:  axiom challenge_restriction:
  "∀ s #i.
    (Challenge( s ) @ #i) ⇒
    (∃ #j #k. (Secret( s ) @ #j) ∧ (Denied( s ) @ #k))"

LHS:  axiom challenge_restriction:
  "∀ s #i.
    (Challenge( s ) @ #i) ⇒
    (∃ #j #k. (Secret( s ) @ #j) ∧ (Denied( s ) @ #k))"

rule (modulo E) Alice3:
   [
   Alice2( n, s ), !AIK( aik ),
   In( sign(<'certpcr', h(<h(<'pcr0', n>), 'deny'>)>, aik) )
   ]
  --[ Denied( s ), DiffProtoAlice3( ) ]->
   [ ]

rule (modulo E) CreateLockedKey:
   [ PCR( x ), Fr( ~sk ), In( lock ) ]
  --[ PCR_Read( x ), DiffProtoCreateLockedKey( ) ]->
   [ PCR( x ), !KeyTable( h(<x, lock>), ~sk ), Out( pk(~sk) ) ]

RHS:  axiom PCR_Init_unique:
  "∀ #i #j. ((PCR_Init( ) @ #i) ∧ (PCR_Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

LHS:  axiom PCR_Init_unique:
  "∀ #i #j. ((PCR_Init( ) @ #i) ∧ (PCR_Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

RHS:  lemma types [typing]:
  all-traces
  "∀ m d1 d2 #i.
    (PCR_Unbind( d1, d2, m ) @ #i) ⇒
    ((∃ #j. (!KU( m ) @ #j) ∧ (#j < #i)) ∨ (∃ #j. Secret( m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m d1 d2 #i.
  (PCR_Unbind( d1, d2, m ) @ #i)
 ∧
  (∀ #j. (!KU( m ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #j. (Secret( m ) @ #j) ⇒ ⊥)"
*/
by sorry

LHS:  lemma types [typing]:
  all-traces
  "∀ m d1 d2 #i.
    (PCR_Unbind( d1, d2, m ) @ #i) ⇒
    ((∃ #j. (!KU( m ) @ #j) ∧ (#j < #i)) ∨ (∃ #j. Secret( m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m d1 d2 #i.
  (PCR_Unbind( d1, d2, m ) @ #i)
 ∧
  (∀ #j. (!KU( m ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #j. (Secret( m ) @ #j) ⇒ ⊥)"
*/
by sorry

RHS:  lemma PCR_Write_charn [reuse, use_induction]:
  all-traces
  "∀ x #i. (PCR_Read( x ) @ #i) ⇒ (∃ #j. PCR_Write( x ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (PCR_Read( x ) @ #i) ∧ ∀ #j. (PCR_Write( x ) @ #j) ⇒ ⊥"
*/
by sorry

LHS:  lemma PCR_Write_charn [reuse, use_induction]:
  all-traces
  "∀ x #i. (PCR_Read( x ) @ #i) ⇒ (∃ #j. PCR_Write( x ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (PCR_Read( x ) @ #i) ∧ ∀ #j. (PCR_Write( x ) @ #j) ⇒ ⊥"
*/
by sorry

RHS:  lemma executable:
  exists-trace "∃ s #i #j. (Secret( s ) @ #i) ∧ (Denied( s ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ s #i #j. (Secret( s ) @ #i) ∧ (Denied( s ) @ #j)"
*/
by sorry

LHS:  lemma executable:
  exists-trace "∃ s #i #j. (Secret( s ) @ #i) ∧ (Denied( s ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ s #i #j. (Secret( s ) @ #i) ∧ (Denied( s ) @ #j)"
*/
by sorry

RHS:  lemma Secret_and_Denied_exclusive:
  all-traces
  "¬(∃ s #i #j #k.
      ((Secret( s ) @ #i) ∧ (Denied( s ) @ #j)) ∧ (K( s ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ s #i #j #k.
  (Secret( s ) @ #i) ∧ (Denied( s ) @ #j) ∧ (K( s ) @ #k)"
*/
by sorry

LHS:  lemma Secret_and_Denied_exclusive:
  all-traces
  "¬(∃ s #i #j #k.
      ((Secret( s ) @ #i) ∧ (Denied( s ) @ #j)) ∧ (K( s ) @ #k))"
/*
guarded formula characterizing all counter-examples:
"∃ s #i #j #k.
  (Secret( s ) @ #i) ∧ (Denied( s ) @ #j) ∧ (K( s ) @ #k)"
*/
by sorry

lemma Diff: Observational_equivalence:
rule-equivalence
  case Rule Alice1
  by sorry
next
  case Rule Alice2
  by sorry
next
  case Rule Alice3
  by sorry
next
  case Rule Challenge
  by sorry
next
  case Rule CreateLockedKey
  by sorry
next
  case Rule DestrRule "adec"
  by sorry
next
  case Rule DestrRule "fst"
  by sorry
next
  case Rule DestrRule "snd"
  by sorry
next
  case Rule IEqualityRule
  backward-search
    case LHS
    simplify
    solve( !KD( x ) ▶₁ #i )
      case Alice2
      solve( (#vl, 0) ~~> (#i, 1) )
        case aenc
        solve( Alice1( n ) ▶₀ #vr )
          case Alice1
          solve( !AIK( aik ) ▶₂ #vr )
            case PCR_Init
            solve( !KU( sign(<'certkey', h(<h(<'pcr0', ~n>), 'obtain'>), pk>,
                             ~aik)
                   ) @ #vk.1 )
              case PCR_CertKey
              solve( PCR( h(<'pcr0', ~n>) ) ▶₀ #vr.4 )
                case Alice1
                solve( PCR( 'pcr0' ) ▶₁ #vr.1 )
                  case CreateLockedKey
                  by sorry
                next
                  case PCR_Init
                  solve( PCR_Write( 'pcr0' ) ▶₂ #vr.1 )
                    case PCR_Init
                    solve( !KU( aenc(~s, pk(~sk)) ) @ #vk.1 )
                      case Alice2
                      solve( !KU( 'obtain' ) @ #vk.2 )
                        case coerce
                        solve( !KD( 'obtain' ) ▶₀ #vk.2 )
                          case Alice2
                          solve( (#vl.2, 0) ~~> (#vk.2, 0) )
                            case dadec
                            by contradiction // impossible chain
                          qed
                        next
                          case Challenge
                          by contradiction // impossible chain
                        next
                          case CreateLockedKey
                          by contradiction // impossible chain
                        next
                          case PCR_CertKey
                          by solve( (#vl.2, 0) ~~> (#vk.2, 0) )
                        next
                          case PCR_Init
                          by contradiction // impossible chain
                        next
                          case PCR_Quote
                          by solve( (#vl.2, 0) ~~> (#vk.2, 0) )
                        next
                          case PCR_Unbind
                          solve( !KeyTable( x, sk.1 ) ▶₁ #vr.5 )
                            case CreateLockedKey
                            solve( !KU( aenc(t, pk(~sk.1)) ) @ #vk.3 )
                              case Alice2
                              by contradiction // impossible chain
                            next
                              case caenc
                              solve( PCR( h(<x, lock>) ) ▶₀ #vr.5 )
                                case Alice1
                                by solve( !KU( ~n.1 ) @ #vk.4 )
                              next
                                case CreateLockedKey
                                by sorry // removed
                              next
                                case PCR_Extend
                                by sorry
                              next
                                case PCR_Quote
                                by sorry
                              next
                                case PCR_Unbind
                                by sorry
                              qed
                            qed
                          qed
                        qed
                      next
                        case pub
                        SOLVED
                      qed
                    next
                      case caenc
                      solve( !KU( ~s ) @ #vk.3 )
                        case Alice2
                        by solve( !KU( ~sk ) @ #vk.5 )
                      next
                        case Challenge
                        solve( Alice2( n.1, ~s ) ▶₀ #k )
                          case Alice2
                          solve( !AIK( aik ) ▶₁ #k )
                            case PCR_Init
                            solve( !KU( pk(~sk) ) @ #vk.4 )
                              case CreateLockedKey
                              solve( !KU( 'obtain' ) @ #vk.4 )
                                case coerce
                                by sorry
                              next
                                case pub
                                solve( !KU( sign(<'certpcr', h(<h(<'pcr0', ~n>), 'deny'>)>, ~aik)
                                       ) @ #vk.5 )
                                  case PCR_Quote
                                  solve( PCR( h(<h(<'pcr0', ~n>), 'deny'>) ) ▶₀ #vr.6 )
                                    case CreateLockedKey
                                    by sorry
                                  next
                                    case PCR_Extend
                                    solve( PCR( h(<'pcr0', ~n>) ) ▶₁ #vr.7 )
                                      case CreateLockedKey
                                      solve( PCR_Write( h(<'pcr0', ~n>) ) ▶₀ #vr.7 )
                                        case Alice1
                                        solve( PCR( h(<'pcr0', ~n>) ) ▶₀ #vr.8 )
                                          case Alice1
                                          solve( !KU( 'deny' ) @ #vk.6 )
                                            case coerce
                                            by sorry
                                          next
                                            case pub
                                            by ATTACK // trace found
                                          qed
                                        next
                                          case CreateLockedKey
                                          by sorry
                                        next
                                          case PCR_Extend
                                          by sorry
                                        next
                                          case PCR_Quote
                                          by sorry
                                        next
                                          case PCR_Unbind
                                          by sorry
                                        qed
                                      next
                                        case PCR_Extend
                                        by sorry
                                      qed
                                    next
                                      case PCR_Extend
                                      by sorry
                                    next
                                      case PCR_Quote
                                      by sorry
                                    next
                                      case PCR_Unbind
                                      by sorry
                                    qed
                                  next
                                    case PCR_Quote
                                    by sorry
                                  next
                                    case PCR_Unbind
                                    by sorry
                                  qed
                                next
                                  case csign
                                  by sorry
                                qed
                              qed
                            next
                              case cpk
                              by sorry
                            qed
                          qed
                        qed
                      next
                        case PCR_Unbind
                        by sorry
                      qed
                    qed
                  qed
                next
                  case PCR_Quote
                  by sorry
                qed
              next
                case CreateLockedKey
                by sorry
              next
                case PCR_Extend
                by sorry
              next
                case PCR_Quote
                by sorry
              next
                case PCR_Unbind
                by sorry
              qed
            next
              case csign
              by sorry
            qed
          qed
        qed
      next
        case dadec
        by sorry
      qed
    next
      case Challenge
      by sorry
    next
      case CreateLockedKey
      by sorry
    next
      case PCR_CertKey
      by sorry
    next
      case PCR_Init
      by sorry
    next
      case PCR_Quote
      by sorry
    next
      case PCR_Unbind
      by sorry
    qed
  next
    case RHS
    by sorry
  qed
next
  case Rule PCR_CertKey
  by sorry
next
  case Rule PCR_Extend
  by sorry
next
  case Rule PCR_Init
  by sorry
next
  case Rule PCR_Quote
  by sorry
next
  case Rule PCR_Unbind
  by sorry
qed

/* All well-formedness checks were successful. */

LHS: rule (modulo E) PCR_Init:
        [ Fr( ~aik ) ]
       --[ PCR_Init( ), PCR_Write( 'pcr0' ), DiffProtoPCR_Init( ) ]->
        [ PCR( 'pcr0' ), PCR_Write( 'pcr0' ), !AIK( ~aik ), Out( pk(~aik) )
        ]

  /* has exactly the trivial AC variant */

LHS: rule (modulo E) PCR_Extend:
        [ PCR_Write( x ), PCR( x ), In( y ) ]
       --[ PCR_Write( h(<x, y>) ), DiffProtoPCR_Extend( ) ]->
        [ PCR( h(<x, y>) ), PCR_Write( h(<x, y>) ) ]

  // loop breakers: [0,1]
  /* has exactly the trivial AC variant */

LHS: rule (modulo E) PCR_CertKey:
        [ !AIK( aik ), !KeyTable( lock, sk ) ]
       --[ DiffProtoPCR_CertKey( ) ]->
        [ Out( sign(<'certkey', lock, pk(sk)>, aik) ) ]

  /* has exactly the trivial AC variant */

LHS: rule (modulo E) PCR_Quote:
        [ PCR( x ), !AIK( aik ) ]
       --[ PCR_Read( x ), DiffProtoPCR_Quote( ) ]->
        [ Out( sign(<'certpcr', x>, aik) ), PCR( x ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

LHS: rule (modulo E) PCR_Unbind:
        [ PCR( x ), !KeyTable( x, sk ), In( aenc(m, pk(sk)) ) ]
       --[ PCR_Unbind( x, sk, m ), PCR_Read( x ), DiffProtoPCR_Unbind( )
       ]->
        [ PCR( x ), Out( m ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

LHS: rule (modulo E) Alice1:
        [ Fr( ~n ), PCR( x ), PCR_Write( x ) ]
       --[ PCR_Write( h(<x, ~n>) ), DiffProtoAlice1( ) ]->
        [ PCR( h(<x, ~n>) ), PCR_Write( h(<x, ~n>) ), Alice1( ~n ) ]

  // loop breakers: [1,2]
  /* has exactly the trivial AC variant */

LHS: rule (modulo E) Alice2:
        [
        Alice1( n ), Fr( ~s ), !AIK( aik ),
        In( sign(<'certkey', h(<h(<'pcr0', n>), 'obtain'>), pk>, aik) )
        ]
       --[ Secret( ~s ), DiffProtoAlice2( ) ]->
        [ Out( aenc(~s, pk) ), Alice2( n, ~s ), Alice2reveal( ~s ) ]

  /* has exactly the trivial AC variant */

LHS: rule (modulo E) Challenge:
        [ Alice2reveal( ~s ), Fr( ~f ) ]
       --[ Challenge( ~s ), DiffProtoChallenge( ) ]->
        [ Out( ~s ) ]

  /* has exactly the trivial AC variant */

LHS: rule (modulo E) Alice3:
        [
        Alice2( n, s ), !AIK( aik ),
        In( sign(<'certpcr', h(<h(<'pcr0', n>), 'deny'>)>, aik) )
        ]
       --[ Denied( s ), DiffProtoAlice3( ) ]->
        [ ]

  /* has exactly the trivial AC variant */

LHS: rule (modulo E) CreateLockedKey:
        [ PCR( x ), Fr( ~sk ), In( lock ) ]
       --[ PCR_Read( x ), DiffProtoCreateLockedKey( ) ]->
        [ PCR( x ), !KeyTable( h(<x, lock>), ~sk ), Out( pk(~sk) ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

RHS: rule (modulo E) PCR_Init:
        [ Fr( ~aik ) ]
       --[ PCR_Init( ), PCR_Write( 'pcr0' ), DiffProtoPCR_Init( ) ]->
        [ PCR( 'pcr0' ), PCR_Write( 'pcr0' ), !AIK( ~aik ), Out( pk(~aik) )
        ]

  /* has exactly the trivial AC variant */

RHS: rule (modulo E) PCR_Extend:
        [ PCR_Write( x ), PCR( x ), In( y ) ]
       --[ PCR_Write( h(<x, y>) ), DiffProtoPCR_Extend( ) ]->
        [ PCR( h(<x, y>) ), PCR_Write( h(<x, y>) ) ]

  // loop breakers: [0,1]
  /* has exactly the trivial AC variant */

RHS: rule (modulo E) PCR_CertKey:
        [ !AIK( aik ), !KeyTable( lock, sk ) ]
       --[ DiffProtoPCR_CertKey( ) ]->
        [ Out( sign(<'certkey', lock, pk(sk)>, aik) ) ]

  /* has exactly the trivial AC variant */

RHS: rule (modulo E) PCR_Quote:
        [ PCR( x ), !AIK( aik ) ]
       --[ PCR_Read( x ), DiffProtoPCR_Quote( ) ]->
        [ Out( sign(<'certpcr', x>, aik) ), PCR( x ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

RHS: rule (modulo E) PCR_Unbind:
        [ PCR( x ), !KeyTable( x, sk ), In( aenc(m, pk(sk)) ) ]
       --[ PCR_Unbind( x, sk, m ), PCR_Read( x ), DiffProtoPCR_Unbind( )
       ]->
        [ PCR( x ), Out( m ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

RHS: rule (modulo E) Alice1:
        [ Fr( ~n ), PCR( x ), PCR_Write( x ) ]
       --[ PCR_Write( h(<x, ~n>) ), DiffProtoAlice1( ) ]->
        [ PCR( h(<x, ~n>) ), PCR_Write( h(<x, ~n>) ), Alice1( ~n ) ]

  // loop breakers: [1,2]
  /* has exactly the trivial AC variant */

RHS: rule (modulo E) Alice2:
        [
        Alice1( n ), Fr( ~s ), !AIK( aik ),
        In( sign(<'certkey', h(<h(<'pcr0', n>), 'obtain'>), pk>, aik) )
        ]
       --[ Secret( ~s ), DiffProtoAlice2( ) ]->
        [ Out( aenc(~s, pk) ), Alice2( n, ~s ), Alice2reveal( ~s ) ]

  /* has exactly the trivial AC variant */

RHS: rule (modulo E) Challenge:
        [ Alice2reveal( ~s ), Fr( ~f ) ]
       --[ Challenge( ~s ), DiffProtoChallenge( ) ]->
        [ Out( ~f ) ]

  /* has exactly the trivial AC variant */

RHS: rule (modulo E) Alice3:
        [
        Alice2( n, s ), !AIK( aik ),
        In( sign(<'certpcr', h(<h(<'pcr0', n>), 'deny'>)>, aik) )
        ]
       --[ Denied( s ), DiffProtoAlice3( ) ]->
        [ ]

  /* has exactly the trivial AC variant */

RHS: rule (modulo E) CreateLockedKey:
        [ PCR( x ), Fr( ~sk ), In( lock ) ]
       --[ PCR_Read( x ), DiffProtoCreateLockedKey( ) ]->
        [ PCR( x ), !KeyTable( h(<x, lock>), ~sk ), Out( pk(~sk) ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

end
