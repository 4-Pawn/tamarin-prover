theory KEA_plus_KCI_wPFS
begin

section{* The KEA+ Protocol *}
/* From: 
 * Security Analysis of KEA Authenticated Key Exchange Protocol
 * Lauter, Mityagin, 2006 */

/* Protocol rules */

rule generate_ltk:
   [ Fresh( <'RegisterKey',$A> ), Fresh(~lk) ] -->
   [ !Ltk( $A, ~lk ), !Pk( $A, 'g'^~lk ), Send( 'g'^~lk ) ]

rule Init_1:
   [ Fresh( ~ekI ), !Ltk( $I, ~lkI ) ]
   --[ SidI_1(~ekI,$I,$R, 'g'^~ekI ) ]->
   [ Init_1( ~ekI, $I, $R, ~lkI, 'g'^~ekI ),
     !EphkI(~ekI),
     Send( 'g'^~ekI ) ]

rule Init_2:
   [ Init_1( ~ekI, $I, $R, ~lkI , hkI), Knows( Y ), !Pk( $R,'g'^~lkR ) ]
   --[SidI_2( ~ekI, $I, $R, hkI, Y,
       h( <Y^~lkI, ('g'^~lkR)^~ekI, $I, $R > ) ) ]->
   [ !SesskOfI( ~ekI, 
       h( <Y^~lkI, ('g'^~lkR)^~ekI, $I, $R > ) ) ]


rule Resp_1:
   [ Knows( X ), Fresh( ~ekR ), !Ltk($R, ~lkR), !Pk($I, 'g'^~lkI) ]
   --[ SidR_1( ~ekR, $I, $R, X, 'g'^~ekR ,
       h( <('g'^~lkI)^~ekR, X^~lkR, $I, $R > ) ) ]->
   [ Send( 'g'^~ekR ),
     !EphkR(~ekR),
     !SesskOfR( ~ekR, 
       h( <('g'^~lkI)^~ekR, X^~lkR, $I, $R > ) ) ]

/* Copy rules to get case distinctions, otherwise no split on solving Sessk(~tid,k) fact
   if it is generated by both roles */
rule Sessk_revealI: 
   [ !SesskOfI(~tid, k) ]
   --[ SesskRev(~tid) ]->
   [ Send(k) ]

rule Sessk_revealR: 
   [ !SesskOfR(~tid, k) ]
   --[ SesskRev(~tid) ]->
   [ Send(k) ]

rule Ephk_revealI:
   [ !EphkI(~ekI) ]
   --[ EphkRev(~ekI) ]->
   [ Send(~ekI) ]

rule Ephk_revealR: 
   [ !EphkR(~ekR) ]
   --[ EphkRev(~ekR) ]->
   [ Send(~ekR) ]

rule Ltk_reveal:
   [ !Ltk($A, k) ]
   --[ LtkRev($A) ]->
   [ Send(k) ]

rule log_deducible:
  [ Knows(x) ]
  --[ Deducible(x) ]-> []

/* Security properties */

/*
lemma key_agreement_reachable:
  "not (Ex #i1 #i2 ekI ekR I R k hkI hkR.
          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)"
*/

/* Security notion.
 *
 * We model the wPFS claim in the KEA+ paper as well as the KCI
 * analysis.
 *
 * The KEA PFS notion is a weakened notion of wPFS, in which the
 * adversary can learn A or B's key after the test thread ends, but not
 * both. "Real" wPFS does not hold for this protocol anyway.
 *
 * We model ephemeral key reveals for non-partner threads.  This
 * corresponds to a session-state-reveal analysis where the
 * session-state is defined as the randomness generated by the parties.
 * This property is not implied by the proof (sketch) in the KEA+ paper.
 */

/* An attack is valid in the security notion if the session key of the test session is deduced and
   the test session is clean.
*/
lemma keaplus_initiator_key:
  "not (Ex #i1 #i2 ttest I R k hkI hkR.
            SidI_2(ttest, I, R, hkI, hkR, k) @ i1 & Deducible( k ) @ i2

            /* No ephemeral-key-reveal of test thread */
            & (All #i3. EphkRev( ttest ) @ i3 ==> F)

            /* Not session-key-reveal of test thread. */
            & (All #i3. SesskRev( ttest ) @ i3 ==> F)

            /* Not ephemeral-key-reveal of partner thread. */
            & (All #i3 #i4 tpartner kpartner.
                   SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i3
		   & EphkRev( tpartner ) @ i4 ==> F)

            /* Not session-key-reveal of partner thread. */
            & (All #i3 #i4 tpartner kpartner.
                   SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i3
		   & SesskRev( tpartner ) @ i4 ==> F)

	    /* If there is no partner thread, then there is no longterm-key-reveal for
	       the intended partner. */
            & (All #i3. LtkRev( R ) @ i3 ==>
	          ((i1 < i3)
	          & (Ex #i4 tpartner kpartner.
                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4)))

            /* Not longterm-key-reveal of both actor and peer. */
            & (All #i3 #i4. (LtkRev( I ) @ i3 & LtkRev(R) @ i4) ==> F)
    )"

/* An attack is valid in the security notion if the session key of the test session is deduced and
   the test session is clean.
*/
lemma keaplus_responder_key:
  "not (Ex #i1 #i2 ttest I R k hkI hkR.
            SidR_1(ttest, I, R, hkI, hkR, k) @ i1 & Deducible( k ) @ i2

            /* Not ephemeral-key-reveal of test thread. */
            & (All #i3. EphkRev( ttest ) @ i3 ==> F)

            /* Not session-key-reveal of test thread. */
            & (All #i3. SesskRev( ttest ) @ i3 ==> F)

            /* Not ephemeral-key-reveal of partner thread. */
	    /* Note we distinguish explicitly between an incomplete
	     * and complete partner thread case.
	     */
            & (All #i3 #i4 tpartner lki.
                   SidI_1( tpartner,I,R,lki ) @i3
		   & EphkRev( tpartner ) @ i4 ==> F) 
            & (All #i3 #i4 tpartner kpartner.
                   SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3
		   & EphkRev( tpartner ) @ i4 ==> F)

            /* Not session-key-reveal of partner thread. Note that we use SidI_2 here.
	       A session key reveal can only happen after SidI_2 is logged anyways.
	    */
            & (All #i3 #i4 tpartner kpartner.
                   SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3
		   & SesskRev( tpartner ) @ i4 ==> F)

	    /* If there is no partner thread, then there is no longterm-key-reveal for
	       the intended partner.
	       */
            & (All #i3. LtkRev( I ) @ i3 ==>
	          ((i1 < i3)
	          & (Ex #i4 tpartner.
                       SidI_1( tpartner,I,R,hkI ) @i4)))

            /* Not longterm-key-reveal of actor and peer. */
            & (All #i3 #i4. (LtkRev( I ) @ i3 & LtkRev(R) @ i4) ==> F)
    )"

end
