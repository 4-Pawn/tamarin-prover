theory ISO_DH
begin

section{* The ISO Diffie-Hellman Key-Exchange Protocol *}

anb-proto iso
{
  // syntactic message abbreviations
  let hki0 = 'g'^ni
      hkr0 = 'g'^nr

  // message transfers
  1. I ->  : I, hki0
       -> R: I, hki

//             assert hki: -  // always known to the intruder

  2.   <- R: R, hkr0, sign{'1', hki , hkr0, I}sk(lts(R))
     I <-  : R, hkr , sign{'1', hki0, hkr , I}sk(lts(R))

//             assert hkr: -  // always known to the intruder

  3. I ->  : I, sign{'2', hkr , hki0, R}sk(lts(I))

//             note SeKey(hkr^ni, <I, R, hki0, hkr> )

       -> R: I, sign{'2', hkr0, hki , R}sk(lts(I))

//             note SeKey(hki^nr, <I, R, hki ,hkr0> )
}

// Separate rules to ensure that protocol rules do not have variants.

rule SeKeyI:
  [ iso_I_3( $I, $R, ~ni, hkr ) ]
  -->
  [ SeKeyI(hkr^~ni, <$I, $R, 'g'^~ni, hkr> ) ]

rule SeKeyR:
  [ iso_R_3( $R, ~nr, I, hki ) ]
  -->
  [ SeKeyR(hki^~nr, <$R, I, hki, 'g'^~nr> )	 ]

/*
rule SeKey_compr: 
   [ SeKey(k, params) ]
   -->
   [ SeKeyCompr(k, params), Out(k) ]
*/

subsection{* Secrecy Properties *}

// Explanation of symbols:
//
//  v >+> u     non-empty path from node v to node u
//  v :>  f     node v has a conclusion equal modulo DH to fact f
//  m = m'      message m is equal modulo DH to message m'


lemma secrecy_lts:
  "u <: lts(A)
   ==> Ex #r. r :> LTSR(A)"

lemma secrecy_sk:
  "u <: sk(lts(A))
   ==> Ex #r. r :> LTSR(A)"

lemma I_secrecy_ni:
  "not( v :> iso_I_1( I, R, ni ) & u <: ni )"

lemma R_secrecy_nr:
  "not( v :> iso_R_2( R, nr, I, hki ) & u <: nr )"

lemma I_secrecy_key:
  "vkey :> SeKeyI(k, <I, R, hki, hkr>) & vk :> k
  ==> Ex #vr. vr :> LTSR(R)"

lemma R_secrecy_key:
  "vkey :> SeKeyR(k, <R, I, hki, hkr>) & vk :> k
  ==> Ex #vr. vr :> LTSR(I)"

/*
lemma I_key_pfs:
  "v :> iso_I_3(I, ni, R, hkr) & u :> In(hkr ^ fr(ni))
   ==> Ex r. r :> LTSR(R) & r >+> v"

lemma R_key_pfs:
  "v :> iso_R_3(I, nr, R, hki) & u :> In(hki ^ fr(nr))
   ==> Ex r. r :> LTSR(I) & r >+> v"

lemma I_niagree:
  "v :> iso_I_3(I, ni, R, hkr) 
   ==> 
   ( Ex u hki nr. 
       u :> iso_R_3(I, hki, R, nr) &
       hki = 'g' ^ fr(ni) &
       hkr = 'g' ^ fr(nr)
   ) 
   | 
   ( Ex r. r :> LTSR(R) & r >+> v )"

lemma session_key_consistency:
  "v1 :> SeKey (k, params1) & v2 :> SeKey(k, params2)
   ==>
   (params1 = params2) |
   (Ex R I hki hkr vr.
     params1 = <I, R, hki, hkr> &
     vr >+> v1 &
     (vr :> LTSR(I) | vr :> LTSR(R))
   )"
   // I'm curious if we can prove this: it is quite strong due to its
   // asymmetry.

*/

end

