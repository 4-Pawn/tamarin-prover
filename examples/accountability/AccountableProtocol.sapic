theory AccountableProtocol
begin

builtins: 
  signing

functions: 
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,

  // sign/2, verify/3, pk/1, and true/0 are from builtins
  // equations: verify(sign(m,sk),m,pk(sk)) = true
  extract/1, sk/1[private]  

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  extract(sign(x,y)) = x


// this trusted party verify logs and emits events accordingly
// trusted, since it doesn't have secret key thus can't be corrupted
// try without Log and secure channel first, since we dont have 'options: progress' anyway
let Judge = 
(
  let Cx  = fst(log) in
  let Cz  = fst(snd(log)) in
  let Z   = snd(snd(log)) in

  let tmp = Pub(Z) in
  let Cy  = fst(snd(tmp)) in

  let z   = fst(m) in
  let rz  = fst(snd(m)) in
  let rx  = snd(snd(m)) in

  // can the adversary prevents these messages from reaching Judge 
  // but not from reaching the other parties?
  // if so, this could be problem since there would be no Initialize(x) event
  // even though A initializes the protocol
  in (<'Initialize',Cy>);
  event Initialize(Cy);

  // from S
  //in (<x,sig1>);

  // the log from A
  // log = <Cx,Cz,ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)>
  in (<'Log','S',sig2,log>);
  event Log(<sig2,log>);

  // the result from A that is sent to S
  // m is the <z,rz,rx> and s is its signature
  in (<m,s>);

  // now check (this should greatly simplifies the verdictfunction)
  // 1. whether S is honest or not
  //    - compare x with open(Cx,rx)
  //      since Cx and rx are generated by A
  //      and the integrity of x from S is guaranteed by sig1
  //    - verify it by using sig1
  // 2. whether A is honest or not
  // 3. should we check that sig1 = sig2?
  //    normally they should be the same

  // or, directly implement the verdictfunction
  // the set AC
  // checks whether x = open(Cx,x)
  if verify(sig2,open(Cx,rx),pk(sk('S'))) = true()
    // checks whether Z is correct
    then 
      (
      if verZK(Z) = true()
      // and it contains the right thing
      then if <Cx,Cy,Cz> = Pub(Z)
        // then A's log is good
        then event ConsistentLogA()
      )
    // otherwise A's log is bad
    else event NotConsistentLogA();

  // the set SC
  // checks whether x = open(Cx,x)
  if verify(sig2,open(Cx,rx),pk(sk('S'))) = true()
    // checks whether z = open(Cz,z) is really the one that A computes
    then 
      (
      if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()
      // then S is behaving honestly
      then event HonestS()
      )
    // otherwise S is dishonest
    else event NotHonestS()
)

/*
let Log = 
(
  // 'r' is the reliable channel 
  //in ('r', <'A','L',m>);
  in (m);
  //event Log(m);                     
  //out ('r', <'L','S',m>)
  out (m);
)
*/

let A =
(
  let z   = f(x,y) in
  let Cx  = commit(x,rx) in
  let Cy  = commit(y,ry) in
  let Cz  = commit(z,rz) in
  let m   = <z,rz,rx> in
  let Z   = ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz) in
  let log = <Cx,Cz,Z> in

  // sends commitment of y to Log 
  new y; new ry; 
  //event Initialize(Cy);
  //out ('r', <'A','L',<'Initialize',Cy>>);
  out (<'Initialize',Cy>);

  // gets x from S
  in (<x,sig>);
  if verify(sig,x,pk(sk('S'))) = true()
    then 
    (
    new rz; new rx;
    // this represents the result of computations
    // from a particular subject, hence we label them with 'S'
    //out ('r',<'A','L',<'Log','S',sig,log>>); 
    // TODO: does it work without signature?
    out (<'Log','S',sig,log>);

    out (<m,sign(m,sk('A'))>);
    event Final()
    )
)

//1. small changes
//2. sanity
//3. fnish verdict function
//4. exclusiveness // exhaustiveness
//5. add progress only if ctr-example points to it
let S = 
(
  let sig = sign(x,pk(sk('S'))) in

  let m   = fst(msg) in 
  let s   = snd(msg) in

  let z   = fst(m) in
  let rz  = fst(snd(m)) in
  let rx  = snd(snd(m)) in

  let Cx  = fst(log) in
  let Cz  = fst(snd(log)) in
  let Z   = snd(snd(log)) in


  new x; out (<x,sig>);

  in (<'Initialize',Cy>); 
  in (msg);  // msg = <m,sign(m,sk('A'))> = <m,s>
  in (<'Log','S',sig,log>); 
  //event Log(<sig,log>);
  if verify(s,m,pk(sk('A'))) = true()  
    then 
      (
      if Cx = commit(x,rx)
        then 
          if Cz = commit(z,rz)
            then 
              if <Cx,Cy,Cz> = Pub(Z)
                then event Accepted(x,z,s)
      )
)


//A || S || Log 
A || S || Judge
|| 
!(  in ('c',<'corrupt',$x>);
    event Corrupted($x);
    out ('c',sk($x))
 )


lemma sanity_exists_pair:
  exists-trace
    "Ex #i a b c. Accepted(a,b,c)@i"

lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"

lemma honest_run:
  "
    ( All x z r #i. Accepted(x,z,r)@#i
      ==>
      ( Ex #j #k Cy ry. Initialize(Cy)@#j & Final()@#k 
        & #j < #i & #i < #k
        & z = f(x,open(Cy,ry))
      )
    )
  "

lemma honest_run_1:
  exists-trace
  "
    ( Ex x z r #i #j #k Cy ry. Accepted(x,z,r)@#i 
      & Initialize(Cy)@#j & Final()@#k 
      & z = f(x,open(Cy,ry))
    )
  "

verdictfunction v1: 
  " Ex #i #j. NotHonestS()@#i & NotConsistentLogA()@#j
  " -> <'A','S'>,

  " Ex #j. NotConsistentLogA()@#j
  & (not Ex #i. NotHonestS()@#i) 
  " -> <'A'>,

  " Ex #i. NotHonestS()@#i
  & (not Ex #j. NotConsistentLogA()@#j)
  " -> <'S'>,

  otherwise -> <>

 lemma acc: 
   v1 accounts  
   for "( All x z r #i. Accepted(x,z,r) @ #i
          ==> 
          ( Ex #j #k Cy ry. Initialize(Cy) @ #j & Final() @ #k
          & #j < #i & #i < #k
          & z = f(x,open(Cy,ry))
          )
        )"
   for parties <'A','S'> 

end
