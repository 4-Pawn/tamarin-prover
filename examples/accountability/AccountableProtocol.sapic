theory AccountableProtocol
begin

builtins: 
  signing // verify(sign(m,sk),m,pk(sk)) = true

functions: 
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  channel/2, retrieve/2, check/2,
  extract/1, sign/2, verify/3, true/0, pk/1,sk/1[private]

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  extract(sign(x,y)) = x


let Log = 
(
  in ('r', Cy); // 'r' is the reliable receive channel 

  // insert m at index i
  new i; insert i, Cy; // ROBERT: Index could be chosen semantically, e.g., 
                       // insert <Init,$A> Cy for Cy signed by $A
  out (Cy) // 'b' is the reliable broadcast channel
)

let A =
(
  // local vars
  let z = f(x,y) in
  let Cx = commit(x,rx) in
  let Cy = commit(y,ry) in
  let Cz = commit(z,rz) in
  let log = <Cx,Cz,ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)> in

  // sends commitment of y to Log 
  new y; new ry; 
  out ('r', Cy);

  // gets x from S
  in (<x, sig>);
  if verify(sig, x, pk(sk('S'))) = true()
  then new rz; new rx;
       event Log(<sig,log>);
       out (sign(<z,rz,rx>,sk('A')));
       out ('r', log);
       event Final()
)

let S = 
(
  // some local vars
  let p = extract(sig) in
  let z = fst(p) in
  let rz = fst(snd(p)) in
  let rx = snd(snd(p)) in
  /*
  let Cx = fst(log) in
  let Cz = fst(snd(log)) in
  let Z = snd(snd(log)) in
  */

  new x; out (<x, sign(x,pk(sk('S')))>);

  in (Cy); in (sig); //ROBERT my suspicion is that accountability will break here if we insert replication,
                    // as the attacker can insert an incorrect Cy at the log...
                    // could go via reliable channel, from log
                    // better: S explicitely requests from log
                    // more practical:
                    // log exists in the global store:
                    // <$A, ..> is data $A can write to
                    // <$Si, ..> is data $Si can write to
                    // Use:
                    // <$A,Init,Cy>  for initial log
                    // <$A,Si,<sign,...> for later log
                    // claims by Si are just events..
                    // if $A is corrupted, give read and write access to cells <$A,*>
  if verify(sig, p, pk(sk('A'))) = true()
  then in ('r', <Cx,Cz,Z>);
       if Cx = commit(x, rx)
       then if Cz = commit(z, rz)
            then if <Cx,Cy,Cz> = Pub(Z)
                then event Pair(x, z, p)
)


A || S || Log || !( in ('c', <'corrupt',$x>);
                      event Corrupted($x);
                      out ('c', sk($x))
                  )


lemma sanity_exists_pair:
  exists-trace
    "Ex #i a b c. Pair(a, b, c)@i"

lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"

/* Need to define verdict function */
/* verdictfunction v1: */
/*     "Ex a #i #j. Execute(a)@i & LogAB(a)@j & not(a=SpecialAct())" -> <'A','B'>, */
/*     "Ex a #i #j. Execute(a)@i & LogA(a)@j & not(a=NormalAct())" -> <'A'>, */
/*     otherwise -> <> */ 

/* lemma acc: */
/*     v1 accounts */ 
/*     for "All a #i.  Execute(a)@i ==> (a=SpecialAct()) | (a=NormalAct())" */ 
/*     for parties <'A','B'> */

end
