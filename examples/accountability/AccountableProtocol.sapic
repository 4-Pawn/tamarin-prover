theory AccountableProtocol
begin

builtins: 
  signing // verify(sign(m,sk),m,pk(sk)) = true

functions: 
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  channel/2, retrieve/2, check/2,
  extract/1, sign/2, verify/3, true/0, pk/1,sk/1[private]

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  extract(sign(x,y)) = x


let E =
(
  out (<pk(sk('A')),pk(sk('S'))>)
)

let Log = 
(
  in ('r', Cy); // 'r' is the reliable receive channel 

  // insert m at index i
  new i; insert i, Cy;
  out (Cy) // 'b' is the reliable broadcast channel
)

let A =
(
  // local vars
  let z = f(x,y) in
  let Cx = commit(x,rx) in
  let Cy = commit(y,ry) in
  let Cz = commit(z,rz) in
  let log = <Cx,Cz,ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)> in

  // sends commitment of y to Log 
  new y; new ry; 
  out ('r', Cy);

  // gets x from S
  in (<x, sig>);
  if verify(sig, x, pk(sk('S'))) = true()
  then new rz; new rx;
       event Log(<sig,log>);
       out (sign(<z,rz,rx>,sk('A')));
       out ('r', log);
       event Final()
)

let S = 
(
  // some local vars
  let p = extract(sig) in
  let z = fst(p) in
  let rz = fst(snd(p)) in
  let rx = snd(snd(p)) in
  /*
  let Cx = fst(log) in
  let Cz = fst(snd(log)) in
  let Z = snd(snd(log)) in
  */

  new x; out (<x, sign(x,pk(sk('S')))>);

  in (Cy); in (sig);
  if verify(sig, p, pk(sk('A'))) = true()
  then in ('r', <Cx,Cz,Z>);
       if Cx = commit(x, rx)
       then if Cz = commit(z, rz)
            then if <Cx,Cy,Cz> = Pub(Z)
                then event Pair(x, z, p)
)


A || S || Log || !( in ('c', <'corrupt',$x>);
                      event Corrupted($x);
                      out ('c', sk($x))
                  )


lemma sanity_exists_pair:
  exists-trace
    "Ex #i a b c. Pair(a, b, c)@i"

lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"

end
