theory AccountableProtocol
begin

builtins: 
  signing  // verify(sign(m,sk),m,pk(sk)) = true

functions: 
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  extract/1, sk/1[private]  // sign, verify, pk, and true are from builtins

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  extract(sign(x,y)) = x

//option: progresss // it adds assumptions, needed for proving liveness properties, namely:
  // 1. reliable channel 'r'
  // 2. local progress: process reduces as long as it can. Every process can reduce, except !P, or in(m); P
  // 3. NDC : A + B continues as either A' or B' 
  // used as follows : out('ping'); (in('pong'); etc) + (out('r','help');in('r','helped'))

let Log = 
(
  in ('r', <'A','L',m>); // 'r' is the reliable channel 
  event Log(m);                     
  out ('r', <'L','S',m>)
)

// Try:
// 1. rename `event Initialize(Cy)` as `Log(<'Initialize',Cy>)`
// 
let A =
(
  // local vars
  let z = f(x,y) in
  let Cx = commit(x,rx) in
  let Cy = commit(y,ry) in
  let Cz = commit(z,rz) in
  let log = <Cx,Cz,ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)> in

  // sends commitment of y to Log 
  new y; new ry; 
  event Initialize(Cy);
  out ('r', <'A','L',<'Initialize',Cy>>);

  // gets x from S
  in (<x, sig>);
  if verify(sig, x, pk(sk('S'))) = true()
  then new rz; new rx;
       out ('r',<'A','L',<'Log','S',sig,log>>); // TODO future: does it work without sig?
       out (sign(<z,rz,rx>,sk('A')));
       event Final()
)

//1. small changes
//2. sanity
//3. fnish verdict function
//4. exclusiveness // exhaustiveness
//5. add progress only if ctr-example points to it
let S = 
(
  // some local vars
  let p = extract(sig) in //TODO keep extract in function signature 
                          // for adversary, but never use yourself,
                          // attach message with signature where necessary
  let z = fst(p) in
  let rz = fst(snd(p)) in
  let rx = snd(snd(p)) in
  /*
  let Cx = fst(log) in
  let Cz = fst(snd(log)) in
  let Z = snd(snd(log)) in
  */
  new x; out (<x, sign(x,pk(sk('S')))>);
  //in (sig); 
  in ('r',<'L','S',<'Initialize',Cy>>); 
  in ('r',<'L','S',<'Log',<sig,<Cx,Cz,Z>>>>); 
  if verify(sig, p, pk(sk('A'))) = true()  // idea: represent these checks as event e.g. if Cx = commit(x, rx) then emit some event
  then if Cx = commit(x, rx)
       then if Cz = commit(z, rz)
            then if <Cx,Cy,Cz> = Pub(Z)
                then event Pair(x, z, p)
)


A || S || Log 
|| 
!(  in ('c', <'corrupt',$x>);
    event Corrupted($x);
    out ('c', sk($x))
 )


lemma sanity_exists_pair:
  exists-trace
    "Ex #i a b c. Pair(a, b, c)@i"

lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"

/*lemma security_property:*/
  /*exists-trace*/
    /*"Ex #i #j #k Cy x z r ry. Initialize(Cy)@i & Final()@j ==> Pair(x, z, r)@k & z = f(x, open(Cy, ry)) & i < k & k < j"*/

lemma honest_run:
  "
    ( All x z r #i. Pair(x, z, r) @ #i
      ==>
      ( Ex #j #k Cy ry. Initialize(Cy) @ #j & Final() @ #k 
        & #j < #i & #i < #k
        & z = f(x, open(Cy, ry))
      )
    )
  "

lemma honest_run_1 [use_induction]:
  exists-trace
  "
    ( Ex x z r #i #j #k Cy ry. Pair(x, z, r) @ #i 
      & Initialize(Cy) @ #j & Final() @ #k 
      & z = f(x, open(Cy, ry))
    )
  "
/* Need to define verdict function */

verdictfunction v1: 
  " not 
    ( Ex Cx Cy Cz rx Z sig #i #j #k. 
      Initialize(Cy) @ #i & Log(<sig, <Cx, Cz, Z>>) @#j & Final() @ #k 
    & <Cx, Cy, Cz> = Pub(Z)
    & verZK(Z) = true()
    & verify(sig, open(Cx, rx), pk(sk('S'))) = true()
    )
  " -> <'A'>,

  " not
    ( Ex r rz rx Cx Cz Z sig #i.
      Log(<sig, <Cx, Cz, Z>>) @ #i
    & verify(sig, open(Cx, rx), pk(sk('S'))) = true()
    & verify(r, <open(Cz, rz), rz, rx>, pk(sk('A'))) = true()
    )
  " -> <'S'>,

  otherwise -> <>

 lemma acc: 
   v1 accounts  
   for "( All x z r #i. Pair(x, z, r) @ #i
          ==> 
          ( Ex #j #k Cy ry. Initialize(Cy) @ #j & Final() @ #k
          & #j < #i & #i < #k
          & z = f(x, open(Cy, ry))
          )
        )"
   for parties <'A','S'> 

end
