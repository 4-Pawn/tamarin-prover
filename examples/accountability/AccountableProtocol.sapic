theory AccountableProtocol
begin

builtins: 
  signing

//predicates:
//  not_equal(a,b) <=> not(a = b)

functions: 
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,

  // sign/2, verify/3, pk/1, and true/0 are from builtins
  // equations: verify(sign(m,sk),m,pk(sk)) = true
  extract/1, sk/1[private]  

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  extract(sign(x,y)) = x


// this trusted party verify logs and emits events accordingly
// trusted, since it doesn't have secret key thus can't be corrupted
// try without Log and secure channel first, since we dont have 'options: progress' anyway
let Judge = 
(
  let Cx  = fst(log) in
  let Cz  = fst(snd(log)) in
  let Z   = snd(snd(log)) in

  let tmp = Pub(Z) in
  let Cy  = fst(snd(tmp)) in

  let z   = fst(m) in
  let rz  = fst(snd(m)) in
  let rx  = snd(snd(m)) in

  // can the adversary prevents these messages from reaching Judge 
  // but not from reaching the other parties?
  // if so, this could be problem since there would be no Initialize(x) event
  // even though A initializes the protocol
  in (<'Initialize',Cy>);
  event Initialize(Cy);

  // from S
  //in (<x,sig1>);

  // the log from A
  // log = <Cx,Cz,ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)>
  // this ensures that Judge only does its judgement after A put something in the Log
  in (<'Log','S',sig2,log>);
  event Log(<sig2,log>);

  // the result from A that is sent to S
  // m is the <z,rz,rx> and s is its signature
  in (<m,s>);

  // now check (this should greatly simplifies the verdictfunction)
  // 1. whether S is honest or not
  //    - compare x with open(Cx,rx)
  //      since Cx and rx are generated by A
  //      and the integrity of x from S is guaranteed by sig1
  //    - verify it by using sig1
  // 2. whether A is honest or not
  // 3. should we check that sig1 = sig2?
  //    normally they should be the same

  // or, directly implement the verdictfunction
  // the set AC
  // checks whether x = open(Cx,x)
  /*if verify(sig2,open(Cx,rx),pk(sk('S'))) = true()*/
    /*then */
      /*(*/
      /*// checks whether Z is correct*/
      /*if verZK(Z) = true()*/
        /*then */
          /*(*/
          /*// and it contains the right thing*/
          /*if <Cx,Cy,Cz> = Pub(Z)*/
            /*then */
              /*(*/
              /*// then A's log is good*/
              /*event ConsistentLogA();*/
              /*if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()*/
                 /*// then S is behaving honestly*/
                 /*then event HonestS()*/
                 /*else event NotHonestS()*/
              /*)*/
            /*else event NotHonestA();*/
                 /*if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()*/
                    /*// then S is behaving honestly*/
                    /*then event HonestS()*/
                    /*else event NotHonestS()*/
          /*)*/
        /*else event NotHonestA();*/
             /*if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()*/
                /*// then S is behaving honestly*/
                /*then event HonestS()*/
                /*else event NotHonestS()*/
      /*)*/
    /*// otherwise A's log is bad and S is dishonest*/
    /*else event NotHonestA();*/
         /*event NotHonestS()*/
    
    if verZK(Z) = true()
       then 
        (
          if <Cx,Cy,Cz> = Pub(Z)
             then 
              (
                if verify(sig2,open(Cx,rx),pk(sk('S'))) = true()
                   then 
                    (
                      event HonestA();
                      if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()
                         then event HonestS()
                         else event NotHonestS()
                    )
                   else 
                    (
                      event NotHonestA();
                      event NotHonestS()
                    )
              )
             else
              (
                event NotHonestA();
                if verify(sig2,open(Cx,rx),pk(sk('S'))) = true()
                   then 
                    (
                      if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()
                         then event HonestS()
                         else event NotHonestS()
                    )
                   else event NotHonestS()
              )
        )
       else 
        (
          event NotHonestA();
          if verify(sig2,open(Cx,rx),pk(sk('S'))) = true()
             then 
              (
                if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()
                   then event HonestS()
                   else event NotHonestS()
              )
             else event NotHonestS()
        )

  /*// the set SC*/
  /*// checks whether x = open(Cx,x)*/
  /*if verify(sig2,open(Cx,rx),pk(sk('S'))) = true()*/
    /*// checks whether z = open(Cz,z) is really the one that A computes*/
    /*then */
      /*(*/
      /*if verify(s,<open(Cz,rz),rz,rx>,pk(sk('A'))) = true()*/
      /*// then S is behaving honestly*/
      /*then event HonestS()*/
      /*)*/
    /*// otherwise S is dishonest*/
    /*else event NotHonestS()*/
)

/*
let Log = 
(
  // 'r' is the reliable channel 
  //in ('r', <'A','L',m>);
  in (m);
  //event Log(m);                     
  //out ('r', <'L','S',m>)
  out (m);
)
*/

let A =
(
  let z   = f(x,y) in
  let Cx  = commit(x,rx) in
  let Cy  = commit(y,ry) in
  let Cz  = commit(z,rz) in
  let m   = <z,rz,rx> in
  let Z   = ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz) in
  let log = <Cx,Cz,Z> in

  // sends commitment of y to Log 
  new y; new ry; 
  //event Initialize(Cy);
  //out ('r', <'A','L',<'Initialize',Cy>>);
  out (<'Initialize',Cy>);

  // gets x from S
  in (<x,sig>);
  if verify(sig,x,pk(sk('S'))) = true()
    then 
    (
    new rz; new rx;
    // this represents the result of computations
    // from a particular subject, hence we label them with 'S'
    //out ('r',<'A','L',<'Log','S',sig,log>>); 
    // TODO: does it work without signature?
    out (<'Log','S',sig,log>);

    out (<m,sign(m,sk('A'))>);
    event Final()
    )
)

//1. small changes
//2. sanity
//3. fnish verdict function
//4. exclusiveness // exhaustiveness
//5. add progress only if ctr-example points to it
let S = 
(
  let sig = sign(x,pk(sk('S'))) in

  let m   = fst(msg) in 
  let s   = snd(msg) in

  let z   = fst(m) in
  let rz  = fst(snd(m)) in
  let rx  = snd(snd(m)) in

  let Cx  = fst(log) in
  let Cz  = fst(snd(log)) in
  let Z   = snd(snd(log)) in


  new x; out (<x,sig>);

  in (<'Initialize',Cy>); 
  in (msg);  // msg = <m,sign(m,sk('A'))> = <m,s>
  in (<'Log','S',sig,log>); 
  //event Log(<sig,log>);
  if verify(s,m,pk(sk('A'))) = true()  
    then 
      (
      if Cx = commit(x,rx)
        then 
          if Cz = commit(z,rz)
            then 
              if <Cx,Cy,Cz> = Pub(Z)
                then event Accepted(<x,z,s>)
      )
)


//A || S || Log 
A || S || Judge
|| 
!(  in ('c',<'corrupt',$x>);
    event Corrupted($x);
    out ('c',sk($x))
 )


lemma sanity_exists_accepted:
  exists-trace
    "Ex #i a. Accepted(a)@i"

lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"

lemma honest_run:
  "
    ( All x z r #i. Accepted(<x,z,r>)@#i
      ==>
      ( Ex #j #k Cy ry. Initialize(Cy)@#j & Final()@#k 
        & #j < #i & #i < #k
        & z = f(x,open(Cy,ry))
      )
    )
  "

lemma honest_run_1:
  exists-trace
  "
    ( Ex x z r #i #j #k Cy ry. Accepted(<x,z,r>)@#i 
      & Initialize(Cy)@#j & Final()@#k 
      & z = f(x,open(Cy,ry))
    )
  "

verdictfunction v1: 
  " Ex #i #j. NotHonestS()@#i & NotHonestA()@#j
  " -> <'A','S'>,

  " Ex #j. NotHonestA()@#j
  & (not Ex #i. NotHonestS()@#i) 
  " -> <'A'>,

  " Ex #i. NotHonestS()@#i
  & (not Ex #j. NotHonestA()@#j)
  " -> <'S'>,

  otherwise -> <>

/*verdictfunction v1:*/
  /*" not Ex #i #j. HonestS()@#i & HonestA()@#j*/
  /*& (Ex m1 m2 #k #l. Accepted(m1)@#l & Accepted(m2)@#k & not (m1 = m1))*/
  /*" -> <'A','S'>,*/

  /*" not Ex #i #j. HonestS()@#i & HonestA()@#j*/
  /*& (not Ex m1 m2 #k #l. Accepted(m1)@#l & Accepted(m2)@#k & not (m1 = m1))*/
  /*" -> <'A','S'>,*/

  /*" not Ex #i. HonestA()@#i */
  /*& (Ex #j. HonestS()@#j)*/
  /*& (Ex m1 m2 #k #l. Accepted(m1)@#l & Accepted(m2)@#k & not (m1 = m1))*/
  /*" -> <'A','S'>,*/

  /*" not Ex #i. HonestA()@#i*/
  /*& (Ex #j. HonestS()@#j)*/
  /*& (not Ex m1 m2 #k #l. Accepted(m1)@#l & Accepted(m2)@#k & not (m1 = m1))*/
  /*" -> <'A'>,*/

  /*" not Ex #i. HonestS()@#i */
  /*& (Ex #j. HonestA()@#j)*/
  /*& (Ex m1 m2 #k #l. Accepted(m1)@#l & Accepted(m2)@#k & not (m1 = m1))*/
  /*" -> <'S'>,*/

  /*" not Ex #i. HonestS()@#i*/
  /*& (Ex #j. HonestA()@#j)*/
  /*& (not Ex m1 m2 #k #l. Accepted(m1)@#l & Accepted(m2)@#k & not (m1 = m1))*/
  /*" -> <'S'>,*/

  /*otherwise -> <>*/

lemma acc: 
  v1 accounts  
  for "
      ( All x z r #i. Accepted(<x,z,r>) @ #i
        ==> 
        ( Ex #j #k Cy ry. Initialize(Cy) @ #j & Final() @ #k
        //& #j < #i & #i < #k
        & z = f(x,open(Cy,ry))
        )
      ) 
      "
  for parties <'A','S'> 

end
