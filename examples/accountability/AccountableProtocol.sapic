theory AccountableProtocol
begin

builtins: 
  signing  // verify(sign(m,sk),m,pk(sk)) = true

functions: 
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  channel/2, retrieve/2, check/2,
  extract/1, sk/1[private]  // sign, verify, pk, and true are from builtins

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  extract(sign(x,y)) = x


let Log = 
(
  in ('r', m); // 'r' is the reliable receive channel 

  // ROBERT: Index could be chosen semantically, e.g., 
  // insert <Init,$A> Cy for Cy signed by $A
  insert <Init,$A>, Cy; 
                       
  out (Cy)
)

let A =
(
  // local vars
  let z = f(x,y) in
  let Cx = commit(x,rx) in
  let Cy = commit(y,ry) in
  let Cz = commit(z,rz) in
  let log = <Cx,Cz,ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)> in

  // sends commitment of y to Log 
  new y; new ry; 
  event Initialize(Cy);
  out ('r', Cy);

  // gets x from S
  in (<x, sig>);
  if verify(sig, x, pk(sk('S'))) = true()
  then new rz; new rx;
       event Log(<sig,log>);
       out (sign(<z,rz,rx>,sk('A')));
       out ('r', log);
       event Final()
)

let S = 
(
  // some local vars
  let p = extract(sig) in
  let z = fst(p) in
  let rz = fst(snd(p)) in
  let rx = snd(snd(p)) in
  /*
  let Cx = fst(log) in
  let Cz = fst(snd(log)) in
  let Z = snd(snd(log)) in
  */

  new x; out (<x, sign(x,pk(sk('S')))>);

  in (Cy); in (sig); //ROBERT my suspicion is that accountability will break here if we insert replication,
                    // as the attacker can insert an incorrect Cy at the log...
                    // could go via reliable channel, from log
                    // better: S explicitely requests from log
                    // more practical:
                    // log exists in the global store:
                    // <$A, ..> is data $A can write to
                    // <$Si, ..> is data $Si can write to
                    // Use:
                    // <$A,Init,Cy>  for initial log
                    // <$A,Si,<sign,...> for later log
                    // claims by Si are just events..
                    // if $A is corrupted, give read and write access to cells <$A,*>
  if verify(sig, p, pk(sk('A'))) = true()
  then in ('r', <Cx,Cz,Z>);
       if Cx = commit(x, rx)
       then if Cz = commit(z, rz)
            then if <Cx,Cy,Cz> = Pub(Z)
                then event Pair(x, z, p)
)


A || S || Log 
|| 
!(  in ('c', <'corrupt',$x>);
    event Corrupted($x);
    out ('c', sk($x))
 )


lemma sanity_exists_pair:
  exists-trace
    "Ex #i a b c. Pair(a, b, c)@i"

lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"

/*lemma security_property:*/
  /*exists-trace*/
    /*"Ex #i #j #k Cy x z r ry. Initialize(Cy)@i & Final()@j ==> Pair(x, z, r)@k & z = f(x, open(Cy, ry)) & i < k & k < j"*/

lemma honest_run:
  "
    ( All x z r #i. Pair(x, z, r) @ #i
      ==>
      ( Ex #j #k Cy ry. Initialize(Cy) @ #j & Final() @ #k 
        & #j < #i & #i < #k
        & z = f(x, open(Cy, ry))
      )
    )
  "

lemma honest_run_1:
  exists-trace
  "
    ( Ex x z r #i #j #k Cy ry. Pair(x, z, r) @ #i 
      & Initialize(Cy) @ #j & Final() @ #k 
      & z = f(x, open(Cy, ry))
    )
  "
/* Need to define verdict function */

verdictfunction v1: 
  " not 
    ( Ex Cx Cy Cz rx Z sig #i #j #k. 
      Initialize(Cy) @ #i & Log(<sig, <Cx, Cz, Z>>) @#j & Final() @ #k 
    & <Cx, Cy, Cz> = Pub(Z)
    & verZK(Z) = true()
    & verify(sig, open(Cx, rx), pk(sk('S'))) = true()
    )
  " -> <'A'>,

  " not
    ( Ex r rz rx Cx Cz Z sig #i.
      Log(<sig, <Cx, Cz, Z>>) @ #i
    & verify(sig, open(Cx, rx), pk(sk('S'))) = true()
    & verify(r, <open(Cz, rz), rz, rx>, pk(sk('A'))) = true()
    )
  " -> <'S'>,

  otherwise -> <>

 lemma acc: 
   v1 accounts  
   for "( All x z r #i. Pair(x, z, r) @ #i
          ==> 
          ( Ex #j #k Cy ry. Initialize(Cy) @ #j & Final() @ #k
          & #j < #i & #i < #k
          & z = f(x, open(Cy, ry))
          )
        )"
   for parties <'A','S'> 

end
