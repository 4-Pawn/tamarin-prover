/*
 * Protocol:    Accountable Algorithms protocol
 * Modeler: 	Robert KÃ¼nnemann, Ilkan Esiyok, Hizbullah Abdul Aziz Jabbar
 * Date: 	Dec 2017
 * Source:	Kroll's Ph.D. thesis, modified according to "Accountability in protocols"
 * Status: 	wip
 * Notes: Protocol modified in the lines proposed in "Accountability in
 * security protocols" paper, however, instead of x, a comittment to x is
 * signed, to preserve condidentiality. In contrast to
 * AccountableAlgorithmsStore.sapic, we chose to modify the proof system so
 * that $S_i$ choses the comittment on x, but x can produce a proof for
 * precisely this comittment. We hope that this gets rid of the notary in most places.
 * 
 * */
theory AccountableAlgorithmsStoreModifiedProof
begin

builtins: signing

functions: 
  extract/1, 
  sk/1[private],
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2, verCom/2,
  eq/2,
  oracle/3

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true(),
  open(commit(m,r),r)=m,
  verCom(commit(m,r),r)=true,
  extract(sign(x,y)) = x,
  eq(x,x)=true(),
  oracle(x,commit(y,ry),f(x,y))=true()

predicates:
  and3(x,y,z) <=> (x=true() & y=true() & z=true() ),
  and4(x,y,z,k) <=> (x=true() & y=true() & z=true() & k=true() )

let S =
(
  let res = <'2',z,rz> 
      claim = <'3',x,z,res,sig_res,rxp>
      Cxp = commit(x, rxp)
      m1 = <'1', x, rxp, sign(Cxp, sk('S'))>
      sig_cxp = fst(log)
      zkp = snd(log)
      CxpL = fst(Pub(zkp))
  in 
  lookup <'A', 'Initialize'> as Cy in 
  new x; 
  new rxp;
  out (<m1, sign(m1,sk('S'))>); 
  lookup <'A','Log','S'> as log in
  if and3( verZK(zkp),
           eq(sig_cxp,sign(Cxp, sk('S'))),
           eq(CxpL,Cxp)
           ) then 
	    (
                in (<res, sig_res>); 
                if verify(sig_res, res, pk(sk('A')))=true() then
                  out (<claim, sign(claim, sk('S'))>)
            )
)

let A =
(
  let m1      = <'1', x, rxp, sig_cxp>
   	  z   = f(x, y)
  	  res = <'2', z, rz>
      Cy      = commit(y, ry)
      Cz      = commit(z, rz)
      Cxp     = commit(x, rxp)
      zkp     = ZK(<Cxp,Cy,Cz>,x,y,z,rxp,ry,rz)
      sig_res = sign(res, sk('A'))
      
  in
  new y; new ry;
  insert <'A', 'Initialize'>, Cy;

  in (<m1, sig_m1>);
  new rz;
  if and3(      true(),
  		verify(sig_m1,m1,pk(sk('S'))), 
  		verify(sig_cxp,Cxp,pk(sk('S')))) then  //verify(sig_x,x,pk(sk('S')))
    (
      
      out (<res, sig_res>);  // send result to S
      insert <'A','Log','S'>, <sig_cxp, zkp>;
      insert <'A','Final'>, true()
    )
)

let J =
( let res     = <'2', z, rz>
      claim   = <'3', x, z, res, sig_res, rxp>
      sig_cxp = fst(log)  // log is <sig_cxp, zkp, Cxp>;
      zkp     = snd(log)
      Cxp     = fst(Pub(zkp))
      Cy      = fst(snd(Pub(zkp)))
      Cz      = snd(snd(Pub(zkp)))
  in
  lookup <'A','Final'> as y in
  event Final();

  lookup <'A','Initialize'> as CyL in 
  event Initialize(CyL);

  lookup <'A','Log','S'> as log in ( // log is present .. 
        // first check validity of the log by itself --> else branch means A dishonest
        if and4( verZK(zkp), //produced by A
                 eq(CyL, Cy), // produced by A
                 verify(sig_cxp,Cxp,pk(sk('S'))), // honest A checks this
                 true()
                 )
        then 
            (  // only if we have a log and it is ok, we accept claims..
                  in (<claim, sig_claim>);
                  if and5 (verify(sig_claim, claim, pk(sk('S'))),
                           eq(x,open(Cxp,rxp)),
                           eq(z,open(Cz,rz)),
                           verCom(Cxp,rxp),
                           verCom(Cz,rz))
                  then
                    ( // we ignore unsigned claims, and claims that do not correspond
                      // to the log..
                        if and3( verify(sig_res,res,pk(sk('A'))), // honest S verifies this
                                   eq(x, open(Cxp,rxp)), // honest S signed both messages, so this should hold
                                   verCom(Cxp,rxp)
                                   )
                        then ( // We now believe S is honest and its claim is valid
                              event HonestS();
                              event HonestA(); 
                              event Verified(claim)
                        )
                        else ( 
                              // A's log is alright, but S is definitely cheating
                              // But, need to blame only if there is indeed a violation!
                              // violation iff Cy in log does not match x and z in claim
                              // Cy is correct w.r.t. Cx by validity of A's log,
                              // but Cx can be different from x claimed
                              // how do we check whether x and z claimed have z=f(x,y)
                              // this maybe the case even if x is different from content of Cx.
                              //
                              // Here is why we need oracle even if zkp is strengthened:
                              //  - claimed x and z need not be the one in zkp
                              //  - can still be correct w.r.t. to y
                              //  - maybe change notion of claim?
                              //
                              /* if oracle(x,Cy,z)=true() then // trying this out for suf_nonempty_2 //Continue here... */
                              /*   (event HonestS(); */
                              /*    event HonestA(); // Not sure if this is right, but at this point I think S alone can provoke violation. */
                              /*    event Verified(claim)) */
                              /* else */ 
                                (event DisHonestS();  
                                 event HonestA(); // Not sure if this is right, but at this point I think S alone can provoke violation.
                                 event Verified(claim)))
                        )
                    else (// A is dishonest and produced bad log
                        if oracle(x,CyL,z)=true() then // see above
                                (event HonestS(); event HonestA(); event Verified(claim))
                        else (
                            event DisHonestA();
                            event DisHonestS();  // S checks the log itself before submitting claim -> must be dishonest herself! 
                            event Verified(claim))
                    )
    )
  else ( // no log...
          event DisHonestA();

  )

)

( 
A || S || J ||
 !(in ('c',<'corrupt',$x>); event Corrupted($x); 
     out ('c',sk($x));
     !(
       (if $x='A' then in(y); insert <'A','Initialize'>,y)
     ||
       (if $x='A' then in(y); insert <'A','Log','S'>, y)
     ||
       (if $x='A' then in(y); insert <'A','Final'>, y)
     ) 

     )
)

// TODO Give adversary read access to log.

restriction no_overwrite:
    "All #i #j x y x yp. Insert(x,y)@i & Insert(x,yp)@j ==> #i = #j"

lemma no_overwrite_lookup [reuse]:
    "All #i #j x y x yp. IsIn(x,y)@i & IsIn(x,yp)@j ==> y = yp"

// auto
/* lemma sanity_exists_accepted: */
/*   exists-trace */
/*     "Ex #i a. Verified(a)@i" */

/* // auto */
/* lemma sanity_exists_final: */
/*   exists-trace */
/*     "Ex #j. Final()@j" */


lemma sanity:
  exists-trace
  "
    ( Ex three rxp x z r sig_r #i #j #k y ry. 
        Final()@#i
      & Initialize(commit(y,ry))@#j 
      & Verified(<three,x,z,r,sig_r,rxp>)@#k // claim = <'3',x,z,res,sig_res,rxp>
      & #i < #j & #j < #k
      & z = f(x,y) 
    )
  "

verdictfunction v: 
  "Ex #i #j #k
      three x z r sig_r rxp. 
      Verified(<three,x,z,r,sig_r,rxp>)@#k // claim = <'3',x,z,res,sig_res,rxp>
      &
      DisHonestS()@#i & DisHonestA()@#j
      "
  -> <'A','S'>,

  "Ex #i #j #k
      three x z r sig_r rxp. 
      Verified(<three,x,z,r,sig_r,rxp>)@#k // claim = <'3',x,z,res,sig_res,rxp>
      &
      DisHonestA()@#i & HonestS()@#j
      "
  -> <'A'>,

  "Ex #i #j  #k
      three x z r sig_r rxp. 
      Verified(<three,x,z,r,sig_r,rxp>)@#k // claim = <'3',x,z,res,sig_res,rxp>
      &
      HonestA()@#i & DisHonestS()@#j
      "
  -> <'S'>,

  /* "All c #k . Verified(c)@k ==> Ex #i #j . HonestA()@#i & DisHonestS()@#j  & Verified(c)@k" */

  otherwise -> empty

// current state: sanity works, but 
// acc_compl_empty_3 auto fast
// acc_comple_noempty_0 auto fast
// acc_comple_noempty_1 counter-example

lemma acc: 
  v accounts  [cases]
  for "
      All three rxp x z r sig_r #k.
      Verified(<three,x,z,r,sig_r,rxp>)@#k // claim = <'3',x,z,res,sig_res,rxp>
      ==>
      ( Ex #j #i y ry. 
        Final()@#i
      & Initialize(commit(y,ry))@#j
      & #i < #j & #j < #k
      & z = f(x,y) 
      )
      "
  for parties <'A','S'> 
 
      
end
