/*
 * Protocol:  Whodunit protocol - Fixed
              - uses unbounded accountability implementation
              - unbounded set of parties
 * Modeler:   Robert KÃ¼nnemann, Kevin Morio
 * Date:
 * Source:
 * Status:
 * Note:
 * */

theory WhoDunit_Fixed_Unbounded
begin

functions:
    pk/1,sk/1[private],
    sign/2, verify/3,
    true/0,
    extract/1

equations:
    verify(sign(m, sk(i)),m, pk(sk(i))) = true,
    extract(sign(m,sk(i))) = m

// predicates:
//  and3(x,y,z) <=> ( x=true() & y=true() & z=true() )



/*
 * Processes
 */

let S =
    let m = <a, sign(a, sk($x))> in
        in($x);
        in($y);
        in(a);
        if $x = $y then 0 else
            lookup <'c_xy', $x, $y> as c_xy in
            lookup <'c_xj', $x> as c_xj in
                out(c_xy, m);
                out(c_xj, m);
                event FinishS()

let A =
    let pkX = pk(sk($x)) in
        in($x);
        in($y);
        if $x = $y then 0 else
            lookup <'c_xy', $x, $y> as c_xy in
            lookup <'c_yj', $y> as c_yj in
                in(c_xy, <a,asig>);
                if verify(asig, a, pkX) = true() then
                    out (c_yj, <a, asig, sign(a, sk($y))>);
                    event FinishA()

let Tr =
    let pkX = pk(sk($x))
        pkY = pk(sk($y))
    in
    in($x);
    in($y);
    lookup <'c_xj', $x> as c_xj in
    lookup <'c_yj', $y> as c_yj in
        in(c_xj, <a1, a1sig>);
            event CXJ();
        in(c_yj, <a2, a2sigS, a2sigA>);
            event CYJ();
        if verify(a1sig, a1, pkX) = true() then
           if verify(a2sigS, a2, pkX) = true() then
            if verify(a2sigA, a2, pkY) = true() then
                if a1 = a2 then
                    event Equal()
                else
                    event Blame($x);
                    event Unequal()

let Join = (
             new c_xj; 
             in($x); 
             out(pk(sk($x)));
             insert <'c_xj', $x>, c_xj
           )
           + 
           ( new c_yj; 
             in($y);
             out(pk(sk($y)));
             insert <'c_yj', $y>, c_yj
           )
           +
           (
             new c_xy;
             in($x);
             in($y);
             out(pk(sk($x)));
             out(pk(sk($y)));
             insert <'c_xy', $x, $y>, c_xy
           )

let Proto = S || A || Tr || !Join

let Adv = !( in('c', <'corrupt', $x>);
             event Corrupted($x);
             out('c',sk($x));
             !( lookup <'c_xj', $x> as c_xj in
                    out(c_xj)
             || lookup <'c_yj', $x> as c_yj in
                    out(c_yj)
             || in($y);
                lookup <'c_xy', $x, $y> as c_xy in
                    out(c_xy)
             )
           )

!(Proto | Adv)
             


/*
 * Lemmas
 */

lemma sanity:
    exists-trace
    "Ex #i. Equal()@i"

lemma sanity_unequal:
    exists-trace
    "Ex #i. Unequal()@i"

lemma multiple_sessions:
     exists-trace
     "Ex x y #i #j. Blame(x)@i & Blame(y)@j & not(x = y)"

lemma finish_S:
     exists-trace
     "Ex #i. FinishS()@i"

lemma finish_A:
     exists-trace
     "Ex #i. FinishA()@i"

lemma CXJ:
     exists-trace
     "Ex #i. CXJ()@i"

lemma CYJ:
     exists-trace
     "Ex #i. CYJ()@i"

lemma c_xj:
     exists-trace
     "Ex x c_xj #i. Insert(<'c_xj', x>, c_xj)@i"

lemma c_yj:
     exists-trace
     "Ex y c_yj #i. Insert(<'c_yj', y>, c_yj)@i"

lemma c_xy:
     exists-trace
     "Ex x y c_xy #i. Insert(<'c_xy', x, y>, c_xy)@i"


/*
 * Case Tests & Accountability Lemma
 */

test unequal:
  "Ex #i #j. Unequal()@i & Blame(x)@j"

lemma acc:
  unequal accounts for "not (Ex #i.  Unequal()@i)"



/*
 * Restrictions
 */

// restriction c_xj_once:
//   "All x c1 c2 #i #j. Insert(<'c_xj', x>, c1)@i & Insert(<'c_xj', x>, c2)@j ==> #i = #j"
// 
// restriction c_yj_once:
//   "All y c1 c2 #i #j. Insert(<'c_yj', y>, c1)@i & Insert(<'c_yj', y>, c2)@j ==> #i = #j"
// 
// restriction c_xy_once:
//   "All x y c1 c2 #i #j. Insert(<'c_xy', x, y>, c1)@i & Insert(<'c_xy', x, y>, c2)@j ==> #i = #j"



/*
 * Results
 */

/*==============================================================================


==============================================================================*/


end
