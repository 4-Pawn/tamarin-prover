/*
 * Protocol:    TrollThrottle protocol for accountable and privacy-preserving rate limiting
 * Modeler: 	Robert Künnemann
 * Date: 	Oct 2017
 * Source:	Designed by Lucjan Hanzlik and Robert Künnemann
 * Status: 	wip 
 */

theory TrollThrottle
begin

builtins: signing, hashing
functions: 
  extract/1, sk/1[private], // sign, verify, pk, and true are from builtins
  // DAAD
  ipk/1,daa_cert/3,daa_sig/3,daa_pseudo/2,daa_ver/5,
   // extraction function for soundness, but not to be used in protocol
    ex_daa_sig_m/1,
    ex_daa_sig_dom/1,
    ex_daa_cert_id/1,
    ex_daa_cert_pk/1,
    ex_daa_pseudo_dom/1,
    ex_daa_pseudo_id/1


equations:
    daa_ver( ipk(sk_iss),
             daa_pseudo(daa_cert(id,ipk(sk_iss),sk_iss),dom),
             dom,
             daa_sig(daa_cert(id,ipk(sk_iss),sk_iss),dom,m),
             m)
             = true(),
    // extraction function for soundness, but not to be used in protocol
    ex_daa_sig_m(daa_sig(cert,dom,m))=m,
    ex_daa_sig_dom(daa_sig(cert,dom,m))=dom,
    ex_daa_cert_id(daa_cert(id,pk_iss,sk_iss))=id,
    ex_daa_cert_pk(daa_cert(id,pk_iss,sk_iss))=pk_iss,
    ex_daa_pseudo_dom(daa_pseudo(cert,dom))=dom,
    ex_daa_pseudo_id(daa_pseudo(daa_cert(id,pk_iss,sk_iss),dom))=id


let Issuer = 0 //DAA issuer and verification of users, not explicit, but implicit in user definition
    
let U =  // honest user posting a comment on $date at website $W, after registering
    let cert = daa_cert(id,pk(sk_iss),sk_iss,)
        dom = <$date,$seq>
        m1 = <'1',h(c),$date,$seq>
        m2 = <'2',sign(m1,sk($W))>
        m3 = <'3',daa_pseudo(cert,dom),daa_sig(cert,dom,c),c>
    in
    new id;
    event Registered($U,cert);
    (!( in ($date); // adversary gets to chose current date
        !( in ($seq); // adversary gets to chose which sequence number is used
           in (<$W,c>); // adversary gets to chose comment and website to post do
           event Unique(<$date,$seq>); // honest user uses each coin only once
           out (m1);
           in (m2);
           out (m3)
         )
     )
     || (event Corrupted($U); out (cert)))

let W = 
    let dom = <$date,$seq>
        m1 = <'1',h(c),$date,$seq>
        m2 = <'2',sign(m1,sk($W))>
        m3 = <'3',c,xdaapseudo,xdaasig>
    in
    event Webserver($W);
    in (m1);
    out (m2);
    in (m3);
    if daa_ver(pk_iss,xdaapseudo,dom,xdaasig,c)=true() then
        event Accept($W,c)

/* let L = */ 

    (new sk_iss; 
     let pk_iss = pk(sk_iss)
     in
     out (pk_iss);
     out (pk(sk($W)));
        !(in ($U); U) 
      ||!(in ($W); W)
    ) 

restriction unique:
    "All m #i #j.
        (Unique(m) @ i & Unique(m) @ j) ==> #i = #j"

end
