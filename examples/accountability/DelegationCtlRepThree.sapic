theory DelegationCtlRepTwo
begin

/* builtins: signing */
functions: 
    pk/1,sk/1[private],
    /* aenc/2, adec/2, */
    sign/2, verify/3,
    true/0,
    NormalAct/0, SpecialAct/0, UnusualAct/0, isAct/1,
    S/1

equations: 
    /* adec(aenc(m,pk(i)),sk(i))=m, */
    // only accept signatures from corresponding public keys
    verify(sign(m, sk(i)),m, pk(sk(i))) = true,
    isAct(NormalAct) = true,
    isAct(SpecialAct) = true,
    isAct(UnusualAct) = true

predicates:
isSpecial(a) <=> a=SpecialAct(),
isNormal(a) <=> a=NormalAct()

let A = 
     let m1 = <'Do',a>
         m2 = <'Permit',a>
     in
  (  in(a);
     if isNormal(a)
       then out(<m1,sign(m1,sk('A'))>)
       else if isSpecial(a)
              then out(<m2,sign(m2,sk('A'))>)) 

let B = 
    let m2x = <'Permit',a>
        m3 = <m2x,m2xsign>
    in
  ( in(<m2x,m2xsign>);
     if verify( m2xsign, m2x, pk(sk('A'))) = true() then
        if isSpecial(a) then
          out(<m3,sign(m3,sk('B'))>)
  )

let C = 
    let m1 = <'Do',a>
        m2 = <'Permit',a>
        m3 = <m2,m2sign>
        sid = '0'
    in lock 'lock';
      ( in(<m1,m1sign>); 
         if verify(m1sign, m1, pk(sk('A'))) = true() then
           event Control(sid,'1'); event LogA(a); event Execute(a); event Control(sid,'1'); unlock 'lock')
     +
      ( in(<m3,m3sign>); 
        if verify(m3sign, m3, pk(sk('B'))) = true() then
            if verify(m2sign, m2, pk(sk('A'))) = true() then
                event Control(sid,'2'); event LogAB(a); event Execute(a); event Control(sid,'2'); unlock 'lock')

// The trusted party can only run once during each run of the protocol
let Proto = out(<pk(sk('A')), pk(sk('B'))>); ! (A || B || C) 

// general form for accountabilty processes
Proto
|| !( in('c',<'corrupt',$x>); 
      event Corrupted($x);
      out('c',sk($x))
      /* (  !(in('r',<$x,sid,m>);0) ) */
    )

/* restriction ctl_same: */
/*     "All sid eid eid2 p #i #j . Control(sid,p)@i & Event(eid)@i & Init(eid2)@j & not(eid=eid2) */
/*       ==> */
/*       (Ex #j . */
/*         Event(eid2)@j & */
/*         Control(sid,p)@j ) */ 
/*         " */

/* restriction ctl_order: */
/*     "All sid1 sid2 sid3 sid2p #i1 #i2 #i3 #j1 #j2 #j3. */
/*         Control(sid1,p1)@i1 & */
/*         Control(sid2,p2)@i2 & */
/*         Control(sid3,p3)@i3 & */
/*         Control(sid1,p1p)@j1 & */
/*         Control(sid2p,p2p)@j2 & */
/*         Control(sid3,p3p)@j3 & */
/*         #i1 < #i2 & */
/*         #i2 < #i3 & */
/*         #j1 < #j2 & */
/*         #j2 < #j3 & */
/*         (All sidp pp #i. Control(sidp,pp)@i ==> (#i <  #i1 | #i3 < #i ) & (#i <  #j1 | #ij < #i )) */
/*         ==> */ 

/* restriction ctl_order: */
/*     "All sid1 sid2 p1 p2 p1p eid1 eid2 #i1 #i2 #j1. */
/*     Control(sid1,p1)@i1 & Event(eid1)@i1 & */ 
/*     Control(sid2,p2)@i2 & Event(eid1)@i2 & */ 
/*     Control(sid1,p1p)@j1 & Event(eid2)@j1  & */
/*     #i1 < #i2 */ 
/*     ==> Ex p2p #j2. Control(sid2,p2p)@j2 & Event(eid2)@j2 & #j1 < #j2" */

lemma sanity_logA_not_misbehaving:
    exists-trace
    "Ex a #i #j. (a = NormalAct()) & LogA(a)@i & Execute(a)@j"

lemma sanity_logAB_not_misbehaving:
    exists-trace
    "Ex a #i #j. (a = SpecialAct()) & LogAB(a)@i & Execute(a)@j"

lemma sanity_logA:
    exists-trace
    "Ex a #i #j. LogA(a)@i & Execute(a)@j" 

lemma sanity_logAB:
    exists-trace
    "Ex a #i #j. LogAB(a)@i & Execute(a)@j" 

verdictfunction v1:
    "Ex a #i #j. 
        Execute(a)@i & LogA(a)@j &  not(a=NormalAct() | a=SpecialAct()) &
        (All ap #ip #jp.  Execute(ap)@ip &  LogAB(ap)@jp  ==> (ap=SpecialAct()) | (ap=NormalAct()))"
    -> let verdict1 = <'A'>,
    "Ex a #i #j. Execute(a)@i & LogAB(a)@j & not(a=NormalAct() |a=SpecialAct()) & 
        (All ap #ip #jp.  Execute(ap)@ip &  LogA(ap)@jp  ==> (ap=SpecialAct()) | (ap=NormalAct()))"
    -> let verdict2 = <'A','B'> ,
    " (Ex a #i #j. Execute(a)@i & LogAB(a)@j & not(a=NormalAct() | a=SpecialAct())) &
      (Ex a #i #j. Execute(a)@i & LogA(a)@j &  not(a=NormalAct() | a=SpecialAct()))"
    -> <verdict1> | <verdict2>,
    /* "Ex a #i #j. Execute(a)@i & LogA(a)@j & a=NormalAct()"   -> empty, */
    /* "Ex a #i #j. Execute(a)@i & LogAB(a)@j & a=SpecialAct()" -> empty, */
    otherwise -> empty 

lemma acc:
    v1 accounts [control] 
    /* for " //violation is the first violation */
    /* All a #i.  Execute(a)@i ==> (a=SpecialAct()) | (a=NormalAct()) */ 
    /*                           | ( Ex ap #ip . Execute(ap)@ip & #ip < #i & not ((a=SpecialAct()) | (a=NormalAct()))) */
    /* " */ 
    for "All a #i.  Execute(a)@i ==> (a=SpecialAct()) | (a=NormalAct())" 
    for parties <'A','B'>

// if ctl is used, give well-formedness error if 
// - check also if process is of right form and output template if not
end
