/*
 * Protocol:    Causality - Dessert traveller protocol {with control}
 * Modeler:     Robert KÃ¼nnemann, Ilkan Esiyok
 * Date:        Feb 2018
 * Source:
 * */

theory ThirstOrPoisoningControl
begin

builtins: signing

functions: 
  extract/1, 
  sk/1[private]

/* options: progress */

//Poisoned
let A = 0

//Shot
let B = 0

//Victim
let C = 
  let sig_p = sign(sk('A'), ~p)
      sig_s = sign(sk('B'), ~s)
  in
    (   in('c',sig_p); 
        ( ( event DrinkAll(); event Poisoned(); 
             (event Control('0','1'); event Verdict()) 
            +(in('c',sig_s); event CanteenShoot(); event Control('0','2');event Verdict()))
         +(in('c',sig_s); event CanteenShoot(); event Control('0','3');event Verdict())))
    +
    (   in('c',sig_s); event CanteenShoot(); event Control('0','4');event Verdict())
    +
    (   event DrinkAll(); event Control('0','5');event Healthy(); event Verdict()) 
        
    
new ~p; new ~s;
(A || B || C ||
 !(in ('c',<'corrupt',$x>); event Corrupted($x); 
     !(
       (if $x='A' then out('c',sign(sk('A'), ~p)))
     ||
       (if $x='B' then out('c',sign(sk('B'), ~s)))
     )
   )
)

lemma sanity[reuse]:
	"All #i. Verdict()@i 
      ==> ((Ex #j. Poisoned()@j) | (Ex #j. CanteenShoot()@j) | (Ex #j. Healthy()@j)) "


verdictfunction v1:
    "Ex #i #j #k. Verdict()@k & Poisoned()@i & Control('0','1')@j " -> <'A'>,
    "Ex #i #j #k. Verdict()@k & CanteenShoot()@i & Control('0','2')@j " -> <'B'>,
    "Ex #i #j #k. Verdict()@k & CanteenShoot()@i & Control('0','3')@j " -> <'B'>,
    "Ex #i #j #k. Verdict()@k & CanteenShoot()@i & Control('0','4')@j " -> <'B'>,
    otherwise -> empty

lemma acc:
    v1 accounts [control]
    for "not((Ex #j. Verdict()@j) & ( (Ex #j. Poisoned()@j) | (Ex #j. CanteenShoot()@j)))"
    for parties <'A','B'>

end
