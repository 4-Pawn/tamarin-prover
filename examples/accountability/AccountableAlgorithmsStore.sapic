theory AccountableAlgorithmsStore
begin

builtins: signing

functions: 
  extract/1, sk/1[private],
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  eq/2

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  open(commit(m,r),r)=m,
  extract(sign(x,y)) = x,
  eq(x,x)=true

predicates:
  and3(x,y,z) <=> (x=true() & y=true() & z=true() ),
  and4(x,y,z,k) <=> (x=true() & y=true() & z=true() & k=true() )

let S =
(
  let res = <'2',z,rz,rx> 
      claim = <'3',x,z,res,sig_res,rxp>
      Cxp = commit(x, rxp)
      m1 = <'1', x, rxp, sign(Cxp, sk('S'))>
      sig_cxp = fst(log)
      zkp = fst(snd(log))
      Cx = fst(snd(snd(log)))
      Cz = fst(snd(snd(snd(log))))
      CxpL = snd(snd(snd(snd(log))))
  in 
  lookup <'A','Initialize'> as Cy in // TODO:: Give adversary access to Cell
  new x; 
  new rxp;
  out (<m1,sign(m1,sk('S'))>); //TODO change other messages to same style and adapt recipient
  lookup <'A','Log','S'> as log in
  if and4( verZK(zkp),
           eq(<Cx,Cy,Cz>, Pub(zkp)),
           eq(sig_cxp,sign(Cxp, sk('S'))),
           eq(CxpL,Cxp)
           ) then 
	    (
                in (<res, sig_res>); 
                if verify(sig_res, res, pk(sk('A')))=true() then
                  out (<claim, sign(claim, sk('S'))>)
      )
)

let A =
(
  let z   = f(x,y) 
      Cx      = commit(x,rx)
      Cy      = commit(y,ry)
      Cz      = commit(z,rz)
      zkp     = ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)
      res     = <'2',z,rz,rx>
      sig_res = sign(res,sk('A'))
      Cxp = commit(x, rxp)
      m1 = <'1', x, rxp, sig_cxp>
  in
  new y; new ry; 
  insert <'A','Initialize'>,Cy;

  in (<m1, sig_m1>);
  if and3( verify(sig_m1,m1,pk(sk('S'))), true(), verify(sig_cxp,Cxp,pk(sk('S')))) then  //verify(sig_x,x,pk(sk('S')))
    (
      new rx; new rz;
      out (<res, sig_res>);  // send result to S
      insert <'A','Log','S'>, <sig_cxp, zkp, Cx, Cz, Cxp>;
      insert <'A','Final'>, true()
    )
)

let J =
( let res = <z,rz,rx> 
      claim = <'3',x,z,res,sig_res,rxp>
      sig_cxp = fst(log)
      zkp = fst(snd(log))
      Cx = fst(snd(snd(log)))
      Cz = fst(snd(snd(snd(log))))
      CxpL = snd(snd(snd(snd(log))))
  in
  in (<claim, sig_claim>);//what if the claim has been sent by the adversary?
  if verify(sig_claim, claim, pk(sk('S'))) = true() then
    (
        lookup <'A','Final'> as y in 
        event Final();

        lookup <'A','Initialize'> as Cy in 
        event Initialize(Cy);
        
        lookup <'A','Log','S'> as log in

        // first check validity of the log by itself --> else branch means A dishonest
        if and3( verZK(zkp), //produced by A
                 eq(<Cx,Cy,Cz>,Pub(zkp)), // produced by A
                 verify(sig_cxp,CxpL,pk(sk('S'))) // honest A checks this
                 )
        then 
            ( if and3( verify(sig_res,res,pk(sk('A'))), // honest S verifies this
                       eq(x, open(CxpL,rxp)), // honest S signed both messages, so this should hold
                       true())
              then ( // We now believe S is honest and its claim is valid
                  event HonestS(); 
                  if and3(
                       eq(x, open(Cx,rx)),  // honest A comits to x send by S, we've used CxpL to verify its the same that is claimed
                       eq(z, open(Cz,rz)),  // z from signed res should match zkp
                       true()) 
                  then 
                            event HonestA(); 
                            event Verified(claim)
                  else 
                       event DisHonestA(); event Verified(claim)
                  )
              else 
                  event DisHonestS();  // A's log is alright, but S is definitely cheating
                  event HonestA(); // Not sure if this is right, but at this point I think S alone can provoke violation.
                  event Verified(claim)
            )
        else // A is dishonest and produced bad log
            event DisHonestA();
            event DisHonestS();  // S checks the log itself before submitting claim -> must be dishonest herself! 
            event Verified(claim)
    )
)

( 
A 
|| S 
|| J 
|| !(in ('c',<'corrupt',$x>); event Corrupted($x); 
     out ('c',sk($x));
     !(
       (if $x='A' then in(y); insert <'A','Initialize'>,y)
     ||
       (if $x='A' then in(y); insert <'A','Log','S'>, y)
     ||
       (if $x='A' then in(y); insert <'A','Final'>, y)
     ))
)

restriction no_overwrite:
    "All #i #j x y x yp. Insert(x,y)@i & Insert(x,yp)@j ==> #i = #j"

lemma no_overwrite_lookup [reuse]:
    "All #i #j x y x yp. IsIn(x,y)@i & IsIn(x,yp)@j ==> y = yp"

// auto
lemma sanity_exists_accepted:
  exists-trace
    "Ex #i a. Verified(a)@i"

// auto
lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"


lemma sanity:
  exists-trace
  "
    ( Ex three rxp x z r sig_r #i #j #k y ry. Verified(<three,x,z,r,sig_r,rxp>)@#i // claim = <'3',x,z,res,sig_res,rxp>
      & Initialize(commit(y,ry))@#j & Final()@#k 
      & z = f(x,y) 
    )
  "

verdictfunction v: 
  "Ex #i #j #k c . DisHonestS()@#i & DisHonestA()@#j & Verified(c)@k"
  -> <'A','S'>,

  "Ex #i #j #k c . DisHonestA()@#i & HonestS()@#j & Verified(c)@k"
  -> <'A'>,

  "Ex #i #j  #k c . HonestA()@#i & DisHonestS()@#j  & Verified(c)@k"
  -> <'S'>,

  otherwise -> empty

// excl auto
// exh auto
// suf_0  ~5min colossus04
// suf_0, suf_1 failed!

lemma acc: 
  v accounts  [cases]
  for "
    ( All three rxp x z r sig_r #i. Verified(<three,x,z,r,sig_r,rxp>)@#i
      ==>
      ( Ex #j #k y ry. Initialize(commit(y,ry))@#j & Final()@#k 
        & #j < #i & #i < #k
        & z = f(x,y)
      )
    )
      "
  for parties <'A','S'> 
 
      
end
