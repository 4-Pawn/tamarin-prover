theory AccountableAlgorithmsStore
begin

builtins: signing

functions: 
  extract/1, sk/1[private],
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  eq/2

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  open(commit(m,r),r)=m,
  extract(sign(x,y)) = x,
  eq(x,x)=true

predicates:
  and3(x,y,z) <=> (x=true() & y=true() & z=true())

let S =
(
  let res = <z,rz,rx> 
      claim = <x,z,res,sig_res>
      /* sig_x = fst(log) */
      /* zkp = fst(snd(log)) */
      /* Cx = fst(snd(snd(log))) */
      /* Cz = snd(snd(snd(log))) */
  in 
  lookup <'A','Initialize'> as Cy in
  new x; 
  out (<x,sign(x,sk('S'))>);
  lookup <'A','Log','S'> as log in
  in (<res,sig_res>); 
  if verify(sig_res,res,pk(sk('A'))) then
          out (<claim,sign(claim,sk('S'))>)
)

let A =
(
  let z   = f(x,y) in
  let Cx  = commit(x,rx) in
  let Cy  = commit(y,ry) in
  let Cz  = commit(z,rz) in
  let zkp   = ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz) in
  let res = <z,rz,rx> in
  let sig_res = sign(res,sk('A')) in

  new y; new ry; 
  insert <'A','Initialize'>,Cy;

  in (<x, sig_x>);
  if verify(sig_x,x,pk(sk('S'))) = true() then
    (
      new rx; new rz;
      out (<res, sig_res>);  // send result to S
      insert <'A','Log','S'>, <sig_x,zkp, Cx, Cz>;
      insert <'A','Final'>, true()
    )
)

let J =
( let res = <z,rz,rx> 
      claim = <x,z,res,sig_res>
      sig_x = fst(log)
      zkp = fst(snd(log))
      Cx = fst(snd(snd(log)))
      Cz = snd(snd(snd(log)))
  in
  in (claim,sig_claim);
  if verify(sig_claim,claim,pk(sk('S'))) = true() then
    lookup <'A','Final'> as y in 
        event Final();
        lookup <'A','Initialize'> as Cy in 
            event Initialize(Cy);
            lookup <'A','Log','S'> as log in
            if and3(verZK(zkp),eq(<Cx,Cy,Cz>,Pub(zkp)),verify(sig_x,open(Cx,rx),pk(sk('S')))) then 
                event HonestA();
                  ( if verify(sig_res,<open(Cz,rz),rz,rx>,pk(sk('A')))=true() 
                   then event HonestS(); event Verified(claim)
                   else event NotHonestS(); event Verified(claim))
                else
                  event NotHonestA();
                  ( if verify(sig_res,<open(Cz,rz),rz,rx>,pk(sk('A')))=true() 
                   then event HonestS(); event Verified(claim)
                   else event NotHonestS(); event Verified(claim))
)

( 
A 
|| S 
|| J 
|| !(in ('c',<'corrupt',$x>); event Corrupted($x); 
     out ('c',sk($x));
     (if $x='A' then in(y); event Initialize(y))
     ))

restriction no_overwrite:
    "All #i #j x y x yp. Insert(x,y)@i & Insert(x,yp)@j ==> #i = #j"

lemma no_overwrite_lookup [reuse]:
    "All #i #j x y x yp. IsIn(x,y)@i & IsIn(x,yp)@j ==> y = yp"

// auto
lemma sanity_exists_accepted:
  exists-trace
    "Ex #i a. Verified(a)@i"

// auto
lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"


lemma sanity:
  exists-trace
  "
    ( Ex x z r sig_r #i #j #k y ry. Verified(<x,z,r,sig_r>)@#i 
      & Initialize(commit(y,ry))@#j & Final()@#k 
      & z = f(x,y)
    )
  "

verdictfunction v: 
  "Ex #i #j #k c . NotHonestS()@#i & NotHonestA()@#j & Verified(c)@k"
  -> <'A','S'>,

  "Ex #i #j #k c . NotHonestA()@#i & HonestS()@#j & Verified(c)@k"
  -> <'A'>,

  "Ex #i #j  #k c . HonestA()@#i & NotHonestS()@#j  & Verified(c)@k"
  -> <'S'>,

  otherwise -> empty

// excl auto
// exh auto
// suf_0  ~5min colossus04
lemma acc: 
  v accounts  [cases]
  for "
    ( All x z r sig_r #i. Verified(<x,z,r,sig_r>)@#i
      ==>
      ( Ex #j #k y ry. Initialize(commit(y,ry))@#j & Final()@#k 
        & #j < #i & #i < #k
        & z = f(x,y)
      )
    )
      "
  for parties <'A','S'> 

end
