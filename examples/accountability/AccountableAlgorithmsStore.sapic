theory AccountableAlgorithmsStore
begin

builtins: signing

functions: 
  //extract/1, 
  sk/1[private],
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  eq/2

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz),rx,rz>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true(),
  open(commit(m,r),r)=m,
  //extract(sign(x,y)) = x,
  eq(x,x)=true()

predicates:
  and3(x,y,z) <=> (x=true() & y=true() & z=true() ),
  and4(x,y,z,k) <=> (x=true() & y=true() & z=true() & k=true() ),
  and5(x,y,z,k,l) <=> (x=true() & y=true() & z=true() & k=true() & l=true())

let S =
(
  let Cxp   = commit(x, rxp)
  	  m1    = <'1', x, rxp, sign(Cxp, sk('S'))>
  	  res   = <'2', z, rz, rx> 
      claim = <'3', x, z, res, sig_res, rxp>
      pub_zkp = <Cx, Cy, Cz, rxL, rzL>
      
      log   = <sig_cxp, zkp, pub_zkp, CxpL>
      //rxL = fst(snd(snd(snd(log))))
      //rzL = snd(snd(snd(snd(log))))
      
  in 
  lookup <'A', 'Initialize'> as Cy in 
  new x; 
  new rxp;
  out (<m1, sign(m1,sk('S'))>); 
  lookup <'A','Log','S'> as log in
  if and4( verZK(zkp),
           eq(pub_zkp, Pub(zkp)),
           eq(sig_cxp, sign(Cxp, sk('S'))),
           eq(CxpL, Cxp)
           ) then 
	    (
	    	in (<res, sig_res>);
	    	if and5(
	    		eq(rx, rxL), 
	    		eq(rz, rzL), 
	    		verify(sig_res, res, pk(sk('A'))), 
	    		eq(x, open(Cx, rx)),
	    		eq(z, open(Cz, rz))) then
	    	(
                  out (<claim, sign(claim, sk('S'))>)
            )
      )
)

let A =
(
  let m1      = <'1', x, rxp, sig_cxp>
   	  z       = f(x, y) 
  	  res     = <'2', z, rz, rx>

      Cx      = commit(x, rx)
      Cy      = commit(y, ry)
      Cz      = commit(z, rz)
      Cxp     = commit(x, rxp)
      pub_zkp = <Cx,Cy,Cz,rx,rz>
      zkp     = ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz)//it's not sending the same rx, rz?
      sig_res = sign(res, sk('A'))
      
  in
  new y; new ry; new rx; new rz;
  insert <'A', 'Initialize'>, Cy;

  in (<m1, sig_m1>);
  if and3( 
  		verify(sig_m1,m1,pk(sk('S'))), 
  		eq(x, open(Cxp,rxp)), 
  		verify(sig_cxp,Cxp,pk(sk('S')))) then  //verify(sig_x,x,pk(sk('S')))
    (
      
      out (<res, sig_res>);  // send result to S
      insert <'A','Log','S'>, <sig_cxp, zkp, pub_zkp, Cxp>;
      insert <'A','Final'>, true()
    )
)

let J =
( let res   = <'2', z, rz, rx> 
      claim = <'3', x, z, res, sig_res, rxp>
      pub_zkp = <Cx,Cy,Cz,rxL,rzL>
      log  = <sig_cxp, zkp, pub_zkp, CxpL>
  in
  in (<claim, sig_claim>);//what if the claim has been sent by the adversary?
  if verify(sig_claim, claim, pk(sk('S'))) = true() then
    (
        lookup <'A','Final'> as y in //y is unbound
        event Final();

        lookup <'A','Initialize'> as Cy in //problem is with Cy?==============
        event Initialize(Cy);
        
        lookup <'A','Log','S'> as log in

        // first check validity of the log by itself --> else branch means A dishonest
        if and4( verZK(zkp), //produced by A
                 eq(pub_zkp, Pub(zkp)), // produced by A
                 verify(sig_cxp,CxpL,pk(sk('S'))) // honest A checks this
                 ,true()
                 )
        then 
            ( if and4( verify(sig_res,res,pk(sk('A'))), // honest S verifies this
                       eq(x, open(CxpL,rxp)), // honest S signed both messages, so this should hold
                       eq(rx, rxL),
                       eq(rz, rzL))
              then ( // We now believe S is honest and its claim is valid
                  event HonestS();
                  if and3(
                       eq(x, open(Cx, rxL)),  // honest A comits to x send by S, we've used CxpL to verify its the same that is claimed
                       eq(z, open(Cz, rzL)),  // z from signed res should match zkp
                       true()) 
                  then 
                            event HonestA(); 
                            event Verified(claim)
                  else 
                       event DisHonestA(); event Verified(claim)
                  )
              else ( 
                  event DisHonestS();  // A's log is alright, but S is definitely cheating
                  event HonestA(); // Not sure if this is right, but at this point I think S alone can provoke violation.
                  event Verified(claim))
            )
        else (// A is dishonest and produced bad log
            event DisHonestA();
            event DisHonestS();  // S checks the log itself before submitting claim -> must be dishonest herself! 
            event Verified(claim))
    )
)

( 
A || S || J ||
 !(in ('c',<'corrupt',$x>); event Corrupted($x); 
     out ('c',sk($x));
     !(
       (if $x='A' then in(y); insert <'A','Initialize'>,y)
     ||
       (if $x='A' then in(y); insert <'A','Log','S'>, y)
     ||
       (if $x='A' then in(y); insert <'A','Final'>, y)
     ) 

     )
)

restriction no_overwrite:
    "All #i #j x y x yp. Insert(x,y)@i & Insert(x,yp)@j ==> #i = #j"

lemma no_overwrite_lookup [reuse]:
    "All #i #j x y x yp. IsIn(x,y)@i & IsIn(x,yp)@j ==> y = yp"

// auto
/* lemma sanity_exists_accepted: */
/*   exists-trace */
/*     "Ex #i a. Verified(a)@i" */

/* // auto */
/* lemma sanity_exists_final: */
/*   exists-trace */
/*     "Ex #j. Final()@j" */


lemma sanity:
  exists-trace
  "
    ( Ex three rxp x z r sig_r #i #j #k y ry. 
        Final()@#i
      & Initialize(commit(y,ry))@#j 
      & Verified(<three,x,z,r,sig_r,rxp>)@#k // claim = <'3',x,z,res,sig_res,rxp>
      & #i < #j & #j < #k
      & z = f(x,y) 
    )
  "

verdictfunction v: 
  "Ex #i #j #k c . DisHonestS()@#i & DisHonestA()@#j & Verified(c)@k"
  -> <'A','S'>,

  "Ex #i #j #k c . DisHonestA()@#i & HonestS()@#j & Verified(c)@k"
  -> <'A'>,

  "Ex #i #j  #k c . HonestA()@#i & DisHonestS()@#j  & Verified(c)@k"
  -> <'S'>,

  otherwise -> empty

// excl auto
// exh auto
// suf_0  ~5min colossus04
// suf_0, suf_1 failed!

lemma acc: 
  v accounts  [cases]
  for "
      All three rxp x z r sig_r #k.
      Verified(<three,x,z,r,sig_r,rxp>)@#k // claim = <'3',x,z,res,sig_res,rxp>
      ==>
      ( Ex #j #i y ry. 
        Final()@#i
      & Initialize(commit(y,ry))@#j 
      & #i < #j & #j < #k
      & z = f(x,y) 
      )
      "
  for parties <'A','S'> 
 
      
end
