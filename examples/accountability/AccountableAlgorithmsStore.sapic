theory AccountableAlgorithmsStore
begin

builtins: signing

functions: 
  extract/1, sk/1[private],
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  eq/2

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  open(commit(m,r),r)=m,
  extract(sign(x,y)) = x,
  eq(x,x)=true

predicates:
  and3(x,y,z) <=> (x=true() & y=true() & z=true() ),
  and4(x,y,z,k) <=> (x=true() & y=true() & z=true() & k=true() )

let S =
(
  let res = <z,rz,rx> 
      claim = <x,z,res,sig_res>
      sig_cxz = fst(log)
      zkp = fst(snd(log))
      Cx = fst(snd(snd(log)))
      Cz = fst(snd(snd(snd(log))))
      CxpL = snd(snd(snd(snd(log))))
      //Cxp = commit(x, rxp)
      //sig_cxp = 
  in 
  lookup <'A','Initialize'> as Cy in // TODO:: Give adversary access to Cell
  new x; 
  new rxp;
  out (<x, sign(x, sk('S')), commit(x, rxp), sign(commit(x, rxp), sk('S')) >);
  lookup <'A','Log','S'> as log in
  if and3( verZK(zkp), eq(<Cx,Cy,Cz>, Pub(zkp)), verify(sig_cxz, <Cx,Cz>, pk(sk('A'))) ) then 
	    (
        in (<res, sig_res, Cxp, sig_cxp>); 
        if and4(verify(sig_res, res, pk(sk('A'))), verify(sig_cxp, Cxp, pk(sk('A'))), eq(Cxp, CxpL), eq(x, open(Cxp, rxp)) ) then
          out (<claim, sign(<claim,Cxp>, sk('S')), Cxp>)
      )
)

let A =
(
  let z   = f(x,y) in
  let Cx  = commit(x,rx) in
  let Cy  = commit(y,ry) in
  let Cz  = commit(z,rz) in
  let zkp = ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz) in
  let res = <z,rz,rx> in
  let sig_res = sign(res,sk('A')) in 

  new y; new ry; 
  insert <'A','Initialize'>,Cy;

  in (<x, sig_x, Cxp, sig_cxp>);
  if and3(verify(sig_x,x,pk(sk('S'))), verify(sig_cxp,Cxp,pk(sk('S'))), true()) then
    (
      new rx; new rz;
      out (<res, sig_res, Cxp, sign(Cxp,sk('A'))>);  // send result to S
      insert <'A','Log','S'>, <sign(<Cx,Cz>,sk('A')), zkp, Cx, Cz, Cxp>;
      insert <'A','Final'>, true()
    )
)

let J =
( let res = <z,rz,rx> 
      claim = <x,z,res,sig_res>
      sig_cxz = fst(log)
      zkp = fst(snd(log))
      Cx = fst(snd(snd(log)))
      Cz = fst(snd(snd(snd(log))))
      CxpL = snd(snd(snd(snd(log))))
  in
  in (<claim, sig_claim, Cxp>);//what if the claim has been sent by the adversary?
  if verify(sig_claim, <claim, Cxp>, pk(sk('S'))) = true() then
    (
        lookup <'A','Final'> as y in 
        event Final();

        lookup <'A','Initialize'> as Cy in 
        event Initialize(Cy);
        
        lookup <'A','Log','S'> as log in

        if and3(verify(sig_res, res, pk(sk('A'))), eq(Cxp, CxpL) , true()) then
				  ( 
			        if and3(verZK(zkp), eq(<Cx,Cy,Cz>,Pub(zkp)), verify(sig_cxz,<Cx,Cz>,pk(sk('A'))) ) then 
              event HonestA();
                ( if and3(verify(sig_res,<open(Cz,rz),rz,rx>,pk(sk('A'))), eq(x, open(Cx, rx)), eq(z, open(Cz, rz)))  
                 then event HonestS()//; //event Verified(claim)	//if both are honest then there should be no Verified event.
                 else event DisHonestS(); event Verified(claim))
              else
                event DisHonestA();
                ( if and3(verify(sig_res,<open(Cz,rz),rz,rx>,pk(sk('A'))), eq(x, open(Cx, rx)), eq(z, open(Cz, rz))) 
                 then event HonestS(); event Verified(claim)
                 else event DisHonestS(); event Verified(claim))
          )
                //this part looks like unnecessary, happy to discuss*
        else
        	(
        		event DisHonestS();
          	if and3(verZK(zkp), eq(<Cx,Cy,Cz>,Pub(zkp)), verify(sig_cxz,<Cx,Cz>,pk(sk('A')))) then 
          		event HonestA(); event Verified(claim)
          	else
          		event DisHonestA(); event Verified(claim)
          )
    )
)

( 
A 
// || S 
// || J 
|| !(in ('c',<'corrupt',$x>); event Corrupted($x); 
     out ('c',sk($x));
     (if $x='A' then in(y); event Initialize(y))
     ))

restriction no_overwrite:
    "All #i #j x y x yp. Insert(x,y)@i & Insert(x,yp)@j ==> #i = #j"

lemma no_overwrite_lookup [reuse]:
    "All #i #j x y x yp. IsIn(x,y)@i & IsIn(x,yp)@j ==> y = yp"

// auto
lemma sanity_exists_accepted:
  exists-trace
    "Ex #i a. Verified(a)@i"

// auto
lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"


lemma sanity:
  exists-trace
  "
    ( Ex x z r sig_r #i #j #k y ry. Verified(<x,z,r,sig_r>)@#i //claim = <x,z,<z,rz,rx>,sig_res>
      & Initialize(commit(y,ry))@#j & Final()@#k 
      & z = f(x,y) 
    )
  "

verdictfunction v: 
  "Ex #i #j #k c . DisHonestS()@#i & DisHonestA()@#j & Verified(c)@k"
  -> <'A','S'>,

  "Ex #i #j #k c . DisHonestA()@#i & HonestS()@#j & Verified(c)@k"
  -> <'A'>,

  "Ex #i #j  #k c . HonestA()@#i & DisHonestS()@#j  & Verified(c)@k"
  -> <'S'>,

  otherwise -> empty

// excl auto
// exh auto
// suf_0  ~5min colossus04
// suf_0, suf_1 failed!

lemma acc: 
  v accounts  [cases]
  for "
    ( All x z r sig_r #i. Verified(<x,z,r,sig_r>)@#i
      ==>
      ( Ex #j #k y ry. Initialize(commit(y,ry))@#j & Final()@#k 
        & #j < #i & #i < #k
        & z = f(x,y)
      )
    )
      "
  for parties <'A','S'> 
 
      
end
