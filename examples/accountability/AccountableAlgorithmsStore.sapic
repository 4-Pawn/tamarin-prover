theory AccountableAlgorithmsStore
begin

builtins: signing

functions: 
  extract/1, sk/1[private],
  ZK/7, verZK/1, Pub/1, f/2,
  commit/2, open/2,
  eq/2

equations: 
  Pub(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = <commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,
  verZK(ZK(<commit(x,rx),commit(y,ry),commit(f(x,y),rz)>,x,y,f(x,y),rx,ry,rz)) = true,
  open(commit(m,r),r)=m,
  extract(sign(x,y)) = x,
  eq(x,x)=true

predicates:
  and3(x,y,z) <=> (x=true() & y=true() & z=true() )

let S =
(
  let res = <z,rz,rx> 
      claim = <x,z,res,sig_res>
      sig_cx = fst(log)
      zkp = fst(snd(log))
      Cx = fst(snd(snd(log)))
      Cz = snd(snd(snd(log))) 
  in 
  lookup <'A','Initialize'> as Cy in // TODO:: Give adversary access to Cell
  new x; 
  out (<x, sign(x, sk('S'))>);
  lookup <'A','Log','S'> as log in
  if and3( verZK(zkp), eq(<Cx,Cy,Cz>, Pub(zkp)), verify(sig_cx, Cx, pk(sk('A'))) ) then 
	in (<res, sig_res>); 
  	if verify(sig_res, res, pk(sk('A')))  then
        out (<claim, sign(claim, sk('S'))>)
)

let A =
(
  let z   = f(x,y) in
  let Cx  = commit(x,rx) in
  let Cy  = commit(y,ry) in
  let Cz  = commit(z,rz) in
  let zkp = ZK(<Cx,Cy,Cz>,x,y,z,rx,ry,rz) in
  let res = <z,rz,rx> in
  let sig_res = sign(res,sk('A')) in 

  new y; new ry; 
  insert <'A','Initialize'>,Cy;

  in (<x, sig_x>);
  if verify(sig_x,x,pk(sk('S'))) = true() then
    (
      new rx; new rz;
      out (<res, sig_res>);  // send result to S
      insert <'A','Log','S'>, <sign(Cx,sk('A')), zkp, Cx, Cz>;
      insert <'A','Final'>, true()
    )
)

let J =
( let res = <z,rz,rx> 
      claim = <x,z,res,sig_res>
      sig_x = fst(log)
      zkp = fst(snd(log))
      Cx = fst(snd(snd(log)))
      Cz = snd(snd(snd(log)))
  in
  in (claim, sig_claim);//what if the claim has been sent by the adversary?
  if verify(sig_claim, claim, pk(sk('S'))) = true() then
    lookup <'A','Final'> as y in 

        event Final();
        lookup <'A','Initialize'> as Cy in 
            event Initialize(Cy);
            lookup <'A','Log','S'> as log in

            if verify(sig_res, res, pk(sk('A'))) = true() then
				(
					if and3(verZK(zkp), eq(<Cx,Cy,Cz>,Pub(zkp)), verify(sig_x,Cx,pk(sk('A'))) ) then 
	                event HonestA();
	                  ( if and3(verify(sig_res,<open(Cz,rz),rz,rx>,pk(sk('A'))), eq(x, open(Cx, rx)), true())  
	                   then event HonestS()//; //event Verified(claim)	//if both are honest then there should be no Verified event.
	                   else event DisHonestS(); event Verified(claim))
	                else
	                  event DisHonestA();
	                  ( if and3(verify(sig_res,<open(Cz,rz),rz,rx>,pk(sk('A'))), eq(x, open(Cx, rx)), true()) 
	                   then event HonestS(); event Verified(claim)
	                   else event DisHonestS(); event Verified(claim))
                )
                //this part looks like unnecessary, happy to discuss*
            // else
            // 	(
            // 		event DisHonestS();
	           //  	if and3(verZK(zkp), eq(<Cx,Cy,Cz>,Pub(zkp)), verify(sig_x,open(Cx,rx),pk(sk('S')))) then 
	           //  		event HonestA(); event Verified(claim)
	           //  	else
	           //  		event DisHonestA(); event Verified(claim)
	           //  )
)

( 
A 
|| S 
|| J 
|| !(in ('c',<'corrupt',$x>); event Corrupted($x); 
     out ('c',sk($x));
     (if $x='A' then in(y); event Initialize(y))
     ))

restriction no_overwrite:
    "All #i #j x y x yp. Insert(x,y)@i & Insert(x,yp)@j ==> #i = #j"

lemma no_overwrite_lookup [reuse]:
    "All #i #j x y x yp. IsIn(x,y)@i & IsIn(x,yp)@j ==> y = yp"

// auto
lemma sanity_exists_accepted:
  exists-trace
    "Ex #i a. Verified(a)@i"

// auto
lemma sanity_exists_final:
  exists-trace
    "Ex #j. Final()@j"


lemma sanity:
  exists-trace
  "
    ( Ex x z r sig_r #i #j #k y ry. Verified(<x,z,r,sig_r>)@#i //claim = <x,z,<z,rz,rx>,sig_res>
      & Initialize(commit(y,ry))@#j & Final()@#k 
      & z = f(x,y) 
    )
  "

verdictfunction v: 
  "Ex #i #j #k c . DisHonestS()@#i & DisHonestA()@#j & Verified(c)@k"
  -> <'A','S'>,

  "Ex #i #j #k c . DisHonestA()@#i & HonestS()@#j & Verified(c)@k"
  -> <'A'>,

  "Ex #i #j  #k c . HonestA()@#i & DisHonestS()@#j  & Verified(c)@k"
  -> <'S'>,

  otherwise -> empty

// excl auto
// exh auto
// suf_0  ~5min colossus04
// suf_0, suf_1 failed!

lemma acc: 
  v accounts  [cases]
  for "
    ( All x z r sig_r #i. Verified(<x,z,r,sig_r>)@#i
      ==>
      ( Ex #j #k y ry. Initialize(commit(y,ry))@#j & Final()@#k 
        & #j < #i & #i < #k
        & z = f(x,y)
      )
    )
      "
  for parties <'A','S'> 
 
      
end
