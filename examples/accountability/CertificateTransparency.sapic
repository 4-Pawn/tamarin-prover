/*
 * Protocol:    
 * Modeler:   
 * Date:  
 * Source:  
 * Status:  
 * Note:  execute with --heuristic=p 
 * */

theory CertificateTransparency
begin

/* builtins: signing */
functions: 
    pk/1,
    skca/1[private], 
    /* aenc/2, adec/2, */
    sign/2, verify/3,
    true/0

equations: 
    /* adec(aenc(m,pk(i)),sk(i))=m, */
    // only accept signatures from corresponding public keys
    verify(sign(m, sk),m, pk(sk)) = true

let CA = /* CA */
    let id = 'CA' in
    let sk =  skca(id) in
    out(pk(sk));
    !( 
        in(<S,id>); //Request to register S at CA
        new sk_S;
        event HonestRegister(S,id,pk(sk_S));
        insert <'proofOfID',S,pk(sk_S)>,'yes'; 
        out(sign(sk,<pk(sk_S),S>))
    )
    ||
    !( 
        event Corrupted(id);
        in(<S,id>); //Request to register S at CA
        new sk_S;
        out(sign(sk,<pk(sk_S),S>))
    )

let LogCert = 
    in(sign(skca('CA'),<pk,S>));
    (
    !(
    insert <'Log','LA',S,pk,'c1'>,'yes';
    insert <'Log','LA',S,pk,'s1'>,'yes';
    insert <'Log','LA',S,pk,'i'>,'yes'
    )
    ||
    !(
        event Corrupted('LA');
        insert <'Log','LA',S,pk,'s1'>,'yes';
        insert <'Log','LA',S,pk,'i'>,'yes'
    ))
        

let TestCA = 
    lock 'testCA';
    in(sign(skca('CA'),<pk,S>));
    lookup <'proofOfID',S,pk> as ignored in 
            event HonestCA();
            event TestCA(S,pk);
            unlock 'testCA'
    else
        event DishonestCA();
        event TestCA(S,pk);
        unlock 'testCA'

let Terminate = lock 'testCA'; event Terminate()

let TestLA =
    let u1='c1' in
    let u2='s1' in /* This is the test that the AIFom file compiles to, modulo symmetry */
    in(<u1,u2,S,pk>);
    lookup <'Log','LA',S,pk,u1> as x1 in
    (
        lookup <'Log','LA',S,pk,u2> as x2 in
            event honestLA()
        else
            event dishonestLA()
    )
    else (
        lookup <'Log','LA',S,pk,u2> as x2 in
            event dishonestLA()
        else
            event honestLA()
    )

// The trusted party can only run once during each run of the protocol
let Proto = CA || LogCert || TestCA || Terminate

// general form for accountabilty processes
Proto
/* || !( in('c',<'corrupt',$x>); */ 
/*       event Corrupted($x); */
/*       out('c',sk($x)) */
      /* (  !(in('r',<$x,sid,m>);0) ) */
    /* ) */

/* lemma sanity_logA_not_misbehaving: */
/*     exists-trace */
/*     "Ex a #i #j. (a = NormalAct()) & LogA(a)@i & Execute(a)@j" */


restriction terminate:
    "Ex #t. Terminate()@t"

verdictfunction v1:
    "Ex #i . DishonestCA()@i" -> let verdict1 = <'CA'>,
    otherwise -> empty 

lemma acc:
    v1 accounts [coarse] 
    for "All S pk #i.  TestCA(S,pk)@i ==> 
                Ex #j. HonestRegister(S,'CA',pk)@j
                " 
    for parties <'CA','LA'>

// if ctl is used, give well-formedness error if 
// - check also if process is of right form and output template if not

/* lemma acc_rel_1_1: */
/*     " */
/*     // Axiom: */
/*     ( All #i #j #k id a . Start(id)@i & Stop(id)@j & Execute(id,a)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k id a . Start(id)@i & Stop(id)@j & LogAB(id,a)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k id pos . Start(id)@i & Stop(id)@j & Ctl(id,pos)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k #l id id2 . Start(id)@i & Stop(id)@j & Start(id2)@k & Stop(id2)@l ==> (#j < #k & #j < #l) | (#l < #i & #l < #j) | (#i=#k & #j=#l)) */
/*     & */
/*     ( All #i id . Start(id)@i ==> Ex #k . Stop(id)@k & i<k ) */
/*     ==> */
/*     ( */
/*       All id1 #i1 #j1 a1 .  (Execute(id1,a1)@#i1 & (LogAB(id1,a1)@#j1 & not(a1 = SpecialAct()))) // rename first case with variable plus 1 */
/*       ==> */
/*       All id2 #i2 #j2 a2 .  (Execute(id2,a2)@#i2 & (LogAB(id2,a2)@#j2 & not(a2 = SpecialAct()))) // rename second case with variable plus 2 */
/*       ==> */ 
/*       All pos1 pos2 #p1 #p2. Ctl(id1,pos1)@p1 & Ctl(id2,pos2)@p2 ==> pos1 = pos2 */
/*     )" */

/* lemma acc_rel_1_1_rewrite: */
/*     " */
/*     // Axiom: */
/*     ( All #i #j #k id a . Start(id)@i & Stop(id)@j & Execute(id,a)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k id a . Start(id)@i & Stop(id)@j & LogAB(id,a)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k id pos . Start(id)@i & Stop(id)@j & Ctl(id,pos)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k #l id id2 . Start(id)@i & Stop(id)@j & Start(id2)@k & Stop(id2)@l ==> (#j < #k & #j < #l) | (#l < #i & #l < #j) | (#i=#k & #j=#l)) */
/*     & */
/*     ( All #i id . Start(id)@i ==> Ex #k . Stop(id)@k & i<k ) */
/*     ==> */
/*     ( */
/*       All id1 id2 #i #j . Start(id1)@i & Start(id2)@j */ 
/*       ==> */
/*       not (Ex #i1 #j1 a1 .  (Execute(id1,a1)@#i1 & (LogAB(id1,a1)@#j1 & not(a1 = SpecialAct())))) // rename first case with variable plus 1 */
/*       | */
/*       not (Ex #i2 #j2 a2 .  (Execute(id2,a2)@#i2 & (LogAB(id2,a2)@#j2 & not(a2 = SpecialAct())))) // rename second case with variable plus 2 */
/*       | */
/*       All pos1 pos2 #p1 #p2. Ctl(id1,pos1)@p1 & Ctl(id2,pos2)@p2 ==> pos1 = pos2 */
/*     )" */


/* // acc_rel_2_2 left out */

/* lemma acc_rel_1_2: // Example for negation. */
/*     " */
/*     // Axiom: */
/*     ( All #i #j #k id a . Start(id)@i & Stop(id)@j & Execute(id,a)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k id a . Start(id)@i & Stop(id)@j & LogAB(id,a)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k id pos . Start(id)@i & Stop(id)@j & Ctl(id,pos)@k ==> #i < #k & #k < #j ) */
/*     & */
/*     ( All #i #j #k #l id id2 . Start(id)@i & Stop(id)@j & Start(id2)@k & Stop(id2)@l ==> (#j < #k & #j < #l) | (#l < #i & #l < #j) | (#i=#k & #j=#l)) */
/*     & */
/*     ( All #i id . Start(id)@i ==> Ex #k . Stop(id)@k & i<k ) */
/*     ==> */
/*     (All #i1 #j1 id1 a1 id2 #s . */
/*      ( Execute(id1, a1)@#i1 & (LogAB(id1, a1)@#j1 & not(a1 = SpecialAct())) ) */
/*      & */
/*      Start(id2)@s // <- for guardedness */
/*       ==> */ 
/*       ( All pos1 pos2 #p1 #p2. Ctl(id1,pos1)@p1 & Ctl(id2,pos2)@p2 ==> not (pos1 = pos2) | #p1=#p2) */
/*      | */ 
/*     ((Ex #i #j a . ((Execute(id2, a)@#i & (LogAB(id2, a)@#j & a = SpecialAct())))) | ((Ex #i #j a . ((Execute(id2, a)@#i & (LogA(id2, a)@#j & a = NormalAct())))) | ((Ex #i #j a . ((Execute(id2, a)@#i & (LogAB(id2, a)@#j & not(a = SpecialAct()))))) | (Ex #i #j a . ((Execute(id2, a)@#i & (LogA(id2, a)@#j & not(a = NormalAct())))))))) */
/*       // ^^ do not rebind id2 */
/*     )" */

end
