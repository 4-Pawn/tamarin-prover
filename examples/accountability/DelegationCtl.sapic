theory DelegationCtl
begin

/* builtins: signing */
functions: 
    pk/1,sk/1[private],
    /* aenc/2, adec/2, */
    sign/2, verify/3,
    true/0,
    NormalAct/0, SpecialAct/0, UnusualAct/0, isAct/1

equations: 
    /* adec(aenc(m,pk(i)),sk(i))=m, */
    // only accept signatures from corresponding public keys
    verify(sign(m, sk(i)),m, pk(sk(i))) = true,
    isAct(NormalAct) = true,
    isAct(SpecialAct) = true,
    isAct(UnusualAct) = true

predicates:
isSpecial(a) <=> a=SpecialAct(),
isNormal(a) <=> a=NormalAct()

let A = 
     let m1 = <'Do',a>
         m2 = <'Permit',a>
     in
  (  in(a);
     if isNormal(a)
       then out(<m1,sign(m1,sk('A'))>)
       else if isSpecial(a)
              then out(<m2,sign(m2,sk('A'))>)) 

let B = 
    let m2x = <'Permit',a>
        m3 = <m2x,m2xsign>
    in
  ( in(<m2x,m2xsign>);
     if verify( m2xsign, m2x, pk(sk('A'))) = true() then
        if isSpecial(a) then
          out(<m3,sign(m3,sk('B'))>)
  )

let C = 
    let m1 = <'Do',a>
        m2 = <'Permit',a>
        m3 = <m2,m2sign>
    in
  ( in(<m1,m1sign>); 
     if verify(m1sign, m1, pk(sk('A'))) = true() then
       event LogA(id,a); event Execute(id,a); event Ctl(id,'1'))
 + 
  ( in(<m3,m3sign>); 
    if verify(m3sign, m3, pk(sk('B'))) = true() then
        if verify(m2sign, m2, pk(sk('A'))) = true() then
            event LogAB(id,a); event Execute(id,a); event Ctl(id,'2'))

let I = 
  ( out(SpecialAct()); out(<pk(sk('A')), pk(sk('B'))>)
  )

// The trusted party can only run once during each run of the protocol
let Proto = ! (A || B || I) || C

// general form for accountabilty processes
( new id; (event Start(id); Proto || event Stop(id)) )
|| !( in('c',<'corrupt',$x>); 
      event Corrupted($x);
      out('c',sk($x))
      /* (  !(in('r',<$x,sid,m>);0) ) */
    )

lemma sanity_logA_not_misbehaving:
    exists-trace
    "Ex id a #i #j. (a = NormalAct()) & LogA(id,a)@i & Execute(id,a)@j"

lemma sanity_logAB_not_misbehaving:
    exists-trace
    "Ex id a #i #j. (a = SpecialAct()) & LogAB(id,a)@i & Execute(id,a)@j"

lemma sanity_logA:
    exists-trace
    "Ex id a #i #j. LogA(id,a)@i & Execute(id,a)@j" 

lemma sanity_logAB:
    exists-trace
    "Ex id a #i #j. LogAB(id,a)@i & Execute(id,a)@j" 

verdictfunction v1:
    "Ex id a #i #j. Execute(id,a)@i & LogA(id,a)@j & not(a=NormalAct())"   -> let verdict1 = <'A'>,
    "Ex id a #i #j. Execute(id,a)@i & LogAB(id,a)@j & not(a=SpecialAct())" -> let verdict2 = <'A','B'> ,
    otherwise -> empty 

lemma acc:
    v1 accounts [cases] 
    for "All id a #i.  Execute(id,a)@i ==> (a=SpecialAct()) | (a=NormalAct())" 
    for parties <'A','B'>

// need to add for accountability lemmas assumption:
//  All #i #j id1 id2. Start(id1)@i & Start(id2)@j ==> #i = #j 
//
// if ctl is used, give well-formedness error if event does not have id as first argument
// check also if process is of right form and output template if not

lemma acc_rel_1_1:
    "
    // Axiom:
    ( All #i #j #k id1 a . Start(id1)@i & Stop(id1)@j & Execute(id1,a)@k ==> #i < #k & #k < #j)
    &
    ( All #i #j #k id1 a . Start(id1)@i & Stop(id1)@j & LogAB(id1,a)@k ==> #i < #k & #k < #j)
    ==>
    (All #i1 #j1 id1 a1 #i2 #j2 id2 a2 . // How is the transformation from Ex to All justified?
    (Execute(id1,a1)@#i1 & (LogAB(id1,a1)@#j1 & not(a1 = SpecialAct()))) // rename first case with variable plus 1
    &
    (Execute(id2,a2)@#i2 & (LogAB(id2,a2)@#j2 & not(a2 = SpecialAct()))) // rename second case with variable plus 2
      ==> All pos1 pos2 #p1 #p2. Ctl(id1,pos1)@p1 & Ctl(id2,pos2)@p2 ==> pos1 = pos2
    )"

// acc_rel_2_2 left out

lemma acc_rel_1_2: // Example for negation.
    "
    // Axiom:
    ( All #i #j #k id1 a . Start(id1)@i & Stop(id1)@j & Execute(id1,a)@k ==> #i < #k & #k < #j)
    &
    ( All #i #j #k id1 a . Start(id1)@i & Stop(id1)@j & LogAB(id1,a)@k ==> #i < #k & #k < #j)
    ==>
    (All #i1 #j1 id1 a1 #i2 #j2 id2 a2 .
    (Execute(id1, a1)@#i1 & (LogAB(id1, a1)@#j1 & not(a1 = SpecialAct())))
    &
    not(((Ex #i2 #j2 a2 id2 . ((Execute(id2, a2)@#i2 & (LogAB(id2, a2)@#j2 & not(a2 = SpecialAct()))))) | (Ex #i2 #j2 a2 id2 . ((Execute(id2, a2)@#i2 & (LogA(id2, a2)@#j2 & not(a2 = NormalAct())))))))
      ==> All pos1 pos2 #p1 #p2. Ctl(id1,pos1)@p1 & Ctl(id2,pos2)@p2 ==> not (pos1 = pos2)
    )"

end
