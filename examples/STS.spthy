theory STS
begin

section{* The Station-To-Station Protocol *}


// Public key infrastructure
rule Register_pk:
  [ Fr(~ltk) ] 
  --> 
  [ !Ltk($A, ~ltk), !Pk($A, pk(~ltk)) ]

rule Get_pk:
  [ !Pk(A, pk) ] 
  --> 
  [ Out(pk) ]

rule Reveal_ltk:
    [ !Ltk(A, ltk) ]
  --[ LtkReveal(A) ]->
    [ Out(ltk) ]

// Protocol
rule Init_1:
  [ Fr(~ekI), !Ltk($I, ltkI) ]
  -->
  [ Init_1( $I, $R, ltkI, ~ekI )
  , Out( <$I, $R, 'g' ^ ~ekI> ) ]

rule Init_2:
    [ Init_1( $I, $R, ltkI, ~ekI )
    , !Pk($R, pk(ltkR))
    , In( <$R, $I, Y, sign{'1', h(< 'g'^~ekI, Y >) }ltkR> ) ]
  --[ SessionKey(~ekI,$I,$R, h(Y ^ ~ekI)), 
      AcceptedI(~ekI,$I,$R,'g'^~ekI,Y) ]->
    [ Out( <$I, $R, sign{'2', h(< 'g' ^ ~ekI, Y >) }ltkI> ) ]

rule Resp_1:
    [ !Pk($I, pk(ltkI))
    , !Ltk($R, ltkR)
    , Fr(~ekR)
    , In( <$I, $R, X > ) ]
  -->
    [ Resp_1( $I, $R, ltkI, ltkR, ~ekR, X )
    , Out( <$R, $I, 'g' ^ ~ekR, sign{'1', h(< X, 'g' ^ ~ekR >) }ltkR > ) ]

rule Resp_2:
    [ Resp_1( $I, $R, ltkI, ltkR, ~ekR, X )
    , In( <$I, $R, X, sign{'2', h(< X, 'g'^~ekR >) }ltkI> ) ]
  --[ SessionKey(~ekR,$I,$R, h(X ^ ~ekR) ),
      AcceptedR(~ekR,$I,$R,X,'g'^~ekR) ]->
    []

rule Sessionkey_Reveal:
    [ SessionKey(~tid, $I,$R,k) ]
  --[ SesskRev(~tid,k) ]->
    [ Out(k) ]

lemma KI_Perfect_Forward_Secrecy_I:
  "not (Ex ttest I R sessKey #i #k hki hkr.
     AcceptedI(ttest,I,R,hki,hkr) @ i &
     SessionKey(ttest,I,R,sessKey) @ i &
     K(sessKey) @ k
     &
     // No session key reveal of test
     not (Ex #i3. SesskRev(ttest, sessKey) @ i3)
     &
     // No session key reveal of partner
     not (Ex #i3 #i4 tpartner kpartner. SesskRev(tpartner, kpartner) @ i3
       & AcceptedR(tpartner,I,R,hki,hkr) @ i4
     )
     &
     not (Ex #r. LtkReveal(I) @ r & r < i)
     & 
     not (Ex #r. LtkReveal(R) @ r & r < i)
     )
  "

lemma KI_Perfect_Forward_Secrecy_R:
  "not (Ex ttest I R sessKey #i #k hki hkr.
     AcceptedR(ttest,I,R,hki,hkr) @ i &
     SessionKey(ttest,I,R,sessKey) @ i &
     K(sessKey) @ k
     &
     // No session key reveal of test
     not (Ex #i3. SesskRev(ttest, sessKey) @ i3)
     &
     // No session key reveal of partner
     not (Ex #i3 #i4 tpartner kpartner. SesskRev(tpartner, kpartner) @ i3
       & AcceptedI(tpartner,I,R,hki,hkr) @ i4
     )
     &
     not (Ex #r. LtkReveal(I) @ r & r < i)
     & 
     not (Ex #r. LtkReveal(R) @ r & r < i)
     )
  "



end
