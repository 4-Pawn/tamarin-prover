/*
 * Protocol: SSH, with a single agent forwarding

   Proverif : everything in a few seconds.

   Tamarin : everything in ?
*/


theory temp

begin

builtins: diffie-hellman, symmetric-encryption, signing

functions: hash/1, kdfPtoS(bitstring):skey, kdfStoP(bitstring):skey, tc(bitstring):bitstring

let P =
    in(~secretchannelP,<pkS,~skP:skey,pkP>);
    new ~a;
    let A='g'^~a in
    event Honnest(A);
    out(A);
    in(<sig,opks,B>);
    if pkS=opks then
        (
	let h=hash(<pkS,A,B>) in
	let k=B^~a in
	if verify(sig,<'server_sign',h>,pkS)=true then
	   (
	   event AcceptP(A,B,tc(pkS),tc(pkP),'source');
	   event KeyP(k);
	   let kPS:skey=kdfPtoS(<k,h>) in
	   let kSP:skey=kdfStoP(<k,h>) in
	   out(senc(<'user_auth',pkP>,kPS));
	   in(userauth_answer);
	   if sdec(userauth_answer,kSP)='userauth_pk_ok' then
	        (
		let payload = <'source',h> in
		let sig2 = sign(payload,~skP) in
	   	event AcceptP2(A,B,tc(pkS),tc(pkP),'source');
		out(senc(<'user_answer', 'source', sig2 >,kPS)) ;


                !(
		in(signreq);
		let <lvl,ms,'sign_req'> = sdec(signreq,kSP) in
                if lvl= 'nested' then
                            (
			    		event Test();
                            out(senc(<sign(<lvl,ms>,~skP),'sign_ans'>,kPS))
                            )
	           )
		    )
	    )
	 )


let remoteP =
    in(~secretchannelremoteP,<pkS,pkP,nestlvl,~b2,A2>);
    new ~aR;
    let A='g'^~aR in
    event Honnest(A);
    out(A);
    in(<sig,opks,B>);
    if pkS=opks then
        (
	let h=hash(<pkS,A,B>) in
	let k=B^~aR in
	if verify(sig,<'server_sign',h>,pkS)=true then
	   (
	   event AcceptP(A,B,tc(pkS),tc(pkP),'nested');
	   event KeyP(k);
	   let kPS:skey=kdfPtoS(<k,h>) in
	   let kSP:skey=kdfStoP(<k,h>) in
	   out(senc(<'user_auth',pkP>,kPS));
	   in(userauth_answer);
	   if sdec(userauth_answer,kSP)='userauth_pk_ok' then
	        (


		let B2='g'^~b2 in
                let h2=hash(<pkS,A2,B2>) in
                let k2=A2^~b2 in
                let kPS2:skey=kdfPtoS(<k2,h2>) in
                let kSP2:skey=kdfStoP(<k2,h2>) in

                out(senc(<nestlvl,h,'sign_req'>,kSP2));

                in(signans);
		let <sig2,'sign_ans'> = sdec(signans,kPS2) in
	   	event AcceptP2(A,B,tc(pkS),tc(pkP),'nested');
		out(senc(<'user_answer', nestlvl,sig2>,kPS))

                 )
	    )
	 )


let S =
    in(~secretchannelS,<~skS:skey,pkS,pkP>);
    in(A);
    new ~b;
    let B='g'^~b in
    let h=hash(<pkS,A,B>) in
    let k=A^~b in
    event AcceptS(A,B,tc(pkS),tc(pkP));
    let sig=sign(<'server_sign',h>,~skS) in
    out(<sig,pkS,B>);
    let kPS:skey=kdfPtoS(<k,h>) in
    let kSP:skey=kdfStoP(<k,h>) in
    in(userauth);
    let <messa,messpk>=sdec(userauth,kPS) in
    if messa='user_auth' then
       (
       if messpk=pkP then
       	  (

	  out(senc('userauth_pk_ok',kSP));
	  in(signans);

	  let <'user_answer',nestlvl,sig2>=sdec(signans,kPS) in
	  event AcceptS2TT(A,B,tc(pkS),tc(pkP),sig2,h);

	  if verify(sig2,<nestlvl,h>,pkP)=true then
	      (
	      event AcceptS2(A,B,tc(pkS),tc(pkP),nestlvl);
	      event KeyS2(k);
	      if nestlvl = 'source' then
	          out(~secretchannelremoteP,<pkS,pkP,'nested',~b,A>)
	      )

	  )
    )

process:
new ~secretchannelP:channel; new ~secretchannelS:channel; new ~secretchannelremoteP:channel;
!(remoteP) || !(P) || !(S) || !(new ~skS:skey;
                 out(pk(~skS));
                 !(new ~skP:skey;
                  out(pk(~skP));
                  !( out(~secretchannelP,<pk(~skS),~skP,pk(~skP)>) ||
		     out(~secretchannelS,<~skS,pk(~skS),pk(~skP)>)
                     ))
		     )




lemma reach: // sanity check
  exists-trace
  "Ex  a b skS skP #i #j. AcceptS2(a,b,skS,skP,'source')@i & Honnest(a)@j "

lemma reach_nested: // sanity check
  exists-trace
  "Ex  a b skS skP #i #j. AcceptS2(a,b,skS,skP,'nested')@i & Honnest(a)@j"

lemma true_secretP[reuse]: //secrecy of the key
  "(not (Ex k #i #j. ( KeyP(k)@i & KU(k)@j ) ))"

lemma true_injPS[reuse]: // if P accepts, some S also accepted in the first step (but no authentication of P at this stage)
 "All a b skS skP t #i. AcceptP(a,b,skS,skP,t)@i ==>
    (Ex skP2 #j. #j<#i & AcceptS(a,b,skS,skP2)@j)"

lemma true_unique_AcceptP[reuse]: // unicity of event
 "All t a b skS skP #i #j. AcceptP(a,b,skS,skP,t)@i & AcceptP(a,b,skS,skP,t)@j ==> #i =#j"

lemma true_unique_AcceptS2[reuse]: //unicity of event
 "All a b skS skP t #i #j. AcceptS2(a,b,skS,skP,t)@i & AcceptS2(a,b,skS,skP,t)@j ==> #i =#j"

lemma true_unique_AcceptP2[reuse]: //unicity of event
 "All a b skS skP t #i #j. AcceptP2(a,b,skS,skP,t)@i & AcceptP2(a,b,skS,skP,t)@j ==> #i =#j"

lemma true_injSP[reuse,use_induction]: // injectivity of final acceptance
 "All a b skS skP t #i. AcceptS2(a,b,skS,skP,t)@i ==>
    (Ex #j. j<i & (AcceptP2(a,b,skS,skP,t)@j))
"
lemma true_secretS[reuse]: //secrecy of the key
  "(not (Ex k #i #j. (KeyS2(k)@i & KU(k)@j)))"

end
