theory NeedhamSchroeder begin

// Function signature and definition of the equational theory E

functions: adec/2[destructor], aenc/2, fst/1, pair/2, pk/1, snd/1,
           test/1[private,destructor]
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2

heuristic: p





lemma source [sources, reuse]:
  all-traces
  "(∀ ni m1 #i.
     (IN_R_1_ni( ni, m1 ) @ #i) ⇒
     ((∃ #j. (!KU( ni ) @ #j) ∧ (#j < #i)) ∨ (∃ #j. OUT_I_1( m1 ) @ #j))) ∧
   (∀ nr m2 #i.
     (IN_I_2_nr( nr, m2 ) @ #i) ⇒
     ((∃ #j. (!KU( nr ) @ #j) ∧ (#j < #i)) ∨ (∃ #j. OUT_R_1( m2 ) @ #j)))"
/*
guarded formula characterizing all counter-examples:
"((∃ ni m1 #i.
    (IN_R_1_ni( ni, m1 ) @ #i)
   ∧
    (∀ #j. (!KU( ni ) @ #j) ⇒ ¬(#j < #i)) ∧
    (∀ #j. (OUT_I_1( m1 ) @ #j) ⇒ ⊥)) ∨
  (∃ nr m2 #i.
    (IN_I_2_nr( nr, m2 ) @ #i)
   ∧
    (∀ #j. (!KU( nr ) @ #j) ⇒ ¬(#j < #i)) ∧
    (∀ #j. (OUT_R_1( m2 ) @ #j) ⇒ ⊥)))"
*/


lemma secrecy:
  all-traces
  "¬(∃ pka pkb k #t1 #t2.
      (((SessionA( pka, pkb, k ) @ #t1) ∧ (K( k ) @ #t2)) ∧
       (∃ #i. HonestA( pka ) @ #i)) ∧
      (∃ #i. HonestB( pkb ) @ #i))"
/*
guarded formula characterizing all counter-examples:
"∃ pka pkb k #t1 #t2.
  (SessionA( pka, pkb, k ) @ #t1) ∧ (K( k ) @ #t2)
 ∧
  (∃ #i. (HonestA( pka ) @ #i)) ∧ (∃ #i. (HonestB( pkb ) @ #i))"
*/


rule (modulo E) Init[color=#ffffff]:
   [ ] --[ Init( ) ]-> [ State_( ) ]

rule (modulo E) I__0_[color=#ffffff]:
   [ State_( ) ] --> [ !Semistate_1( ) ]

rule (modulo E) I__1_[color=#ffffff]:
   [ !Semistate_1( ) ] --> [ State_1( ) ]

rule (modulo E) I__0_1[color=#ffffff]:
   [ State_1( ) ] --> [ State_11( ), State_12( ) ]

rule (modulo E) newskAbitstring_0_11[color=#ffffff]:
   [ State_11( ), Fr( skA ) ] --> [ State_111( skA ) ]

rule (modulo E) eventHonestApkskAbitstring_0_111[color=#ffffff]:
   [ State_111( skA ) ] --[ HonestA( pk(skA) ) ]-> [ State_1111( skA ) ]

rule (modulo E) outpkskAbitstring_0_1111[color=#ffffff]:
   [ State_1111( skA ) ] --> [ State_11111( skA ), Out( pk(skA) ) ]

rule (modulo E) I__0_11111[color=#ffffff]:
   [ State_11111( skA ) ] --> [ !Semistate_111111( skA ) ]

rule (modulo E) I__1_11111[color=#ffffff]:
   [ !Semistate_111111( skA ) ] --> [ State_111111( skA ) ]

rule (modulo E) inpkxBbitstring_0_111111[color=#ffffff]:
   [ State_111111( skA ), In( pk(xB) ) ] --> [ State_1111111( skA, xB ) ]

rule (modulo E) newNabitstring_0_1111111[color=#ffffff]:
   [ State_1111111( skA, xB ), Fr( Na ) ]
  -->
   [ State_11111111( Na, skA, xB ) ]

rule (modulo E) eventOUTIaencNabitstringpkskAbitstringpkxBbitstring_0_11111111[color=#ffffff]:
   [ State_11111111( Na, skA, xB ) ]
  --[ OUT_I_1( aenc(<Na, pk(skA)>, pk(xB)) ) ]->
   [ State_111111111( Na, skA, xB ) ]

rule (modulo E) outaencNabitstringpkskAbitstringpkxBbitstring_0_111111111[color=#ffffff]:
   [ State_111111111( Na, skA, xB ) ]
  -->
   [ State_1111111111( Na, skA, xB ), Out( aenc(<Na, pk(skA)>, pk(xB)) ) ]

rule (modulo E) inaencNabitstringxNbbitstringpkxBbitstringpkskAbitstring_0_1111111111[color=#ffffff]:
   [ State_1111111111( Na, skA, xB ), In( aenc(<Na, xNb, pk(xB)>, pk(skA)) )
   ]
  -->
   [ State_11111111111( Na, skA, xB, xNb ) ]

rule (modulo E) eventINInrxNbbitstringaencNabitstringxNbbitstringpkxBbitstringpkskAbitstring_0_11111111111[color=#ffffff]:
   [ State_11111111111( Na, skA, xB, xNb ) ]
  --[ IN_I_2_nr( xNb, aenc(<Na, xNb, pk(xB)>, pk(skA)) ) ]->
   [ State_111111111111( Na, skA, xB, xNb ) ]

rule (modulo E) newkbitstring_0_111111111111[color=#ffffff]:
   [ State_111111111111( Na, skA, xB, xNb ), Fr( k ) ]
  -->
   [ State_1111111111111( Na, k, skA, xB, xNb ) ]

rule (modulo E) outaencxNbbitstringkbitstringpkxBbitstring_0_1111111111111[color=#ffffff]:
   [ State_1111111111111( Na, k, skA, xB, xNb ) ]
  -->
   [
   State_11111111111111( Na, k, skA, xB, xNb ),
   Out( aenc(<xNb, k>, pk(xB)) )
   ]

rule (modulo E) eventSessionApkskAbitstringpkxBbitstringkbitstring_0_11111111111111[color=#ffffff]:
   [ State_11111111111111( Na, k, skA, xB, xNb ) ]
  --[ SessionA( pk(skA), pk(xB), k ) ]->
   [ State_111111111111111( Na, k, skA, xB, xNb ) ]

rule (modulo E) I__0_111111111111111[color=#ffffff]:
   [ State_111111111111111( Na, k, skA, xB, xNb ) ] --> [ ]

rule (modulo E) I__0_12[color=#ffffff]:
   [ State_12( ) ] --> [ !Semistate_121( ) ]

rule (modulo E) I__1_12[color=#ffffff]:
   [ !Semistate_121( ) ] --> [ State_121( ) ]

rule (modulo E) newskBbitstring_0_121[color=#ffffff]:
   [ State_121( ), Fr( skB ) ] --> [ State_1211( skB ) ]

rule (modulo E) eventHonestBpkskBbitstring_0_1211[color=#ffffff]:
   [ State_1211( skB ) ] --[ HonestB( pk(skB) ) ]-> [ State_12111( skB ) ]

rule (modulo E) outpkskBbitstring_0_12111[color=#ffffff]:
   [ State_12111( skB ) ] --> [ State_121111( skB ), Out( pk(skB) ) ]

rule (modulo E) I__0_121111[color=#ffffff]:
   [ State_121111( skB ) ] --> [ !Semistate_1211111( skB ) ]

rule (modulo E) I__1_121111[color=#ffffff]:
   [ !Semistate_1211111( skB ) ] --> [ State_1211111( skB ) ]

rule (modulo E) inaencxNabitstringpkxAbitstringpkskBbitstring_0_1211111[color=#ffffff]:
   [ State_1211111( skB ), In( aenc(<xNa, pk(xA)>, pk(skB)) ) ]
  -->
   [ State_12111111( skB, xA, xNa ) ]

rule (modulo E) eventINRnixNabitstringaencxNabitstringpkxAbitstringpkskBbitstring_0_12111111[color=#ffffff]:
   [ State_12111111( skB, xA, xNa ) ]
  --[ IN_R_1_ni( xNa, aenc(<xNa, pk(xA)>, pk(skB)) ) ]->
   [ State_121111111( skB, xA, xNa ) ]

rule (modulo E) newNbbitstring_0_121111111[color=#ffffff]:
   [ State_121111111( skB, xA, xNa ), Fr( Nb ) ]
  -->
   [ State_1211111111( Nb, skB, xA, xNa ) ]

rule (modulo E) eventOUTRaencxNabitstringNbbitstringpkskBbitstringpkxAbitstring_0_1211111111[color=#ffffff]:
   [ State_1211111111( Nb, skB, xA, xNa ) ]
  --[ OUT_R_1( aenc(<xNa, Nb, pk(skB)>, pk(xA)) ) ]->
   [ State_12111111111( Nb, skB, xA, xNa ) ]

rule (modulo E) outaencxNabitstringNbbitstringpkskBbitstringpkxAbitstring_0_12111111111[color=#ffffff]:
   [ State_12111111111( Nb, skB, xA, xNa ) ]
  -->
   [
   State_121111111111( Nb, skB, xA, xNa ),
   Out( aenc(<xNa, Nb, pk(skB)>, pk(xA)) )
   ]

rule (modulo E) inaencNbbitstringxkbitstringpkskBbitstring_0_121111111111[color=#ffffff]:
   [ State_121111111111( Nb, skB, xA, xNa ), In( aenc(<Nb, xk>, pk(skB)) ) ]
  -->
   [ State_1211111111111( Nb, skB, xA, xNa, xk ) ]

rule (modulo E) eventSessionBpkxAbitstringpkskBbitstringxkbitstring_0_1211111111111[color=#ffffff]:
   [ State_1211111111111( Nb, skB, xA, xNa, xk ) ]
  --[ SessionB( pk(xA), pk(skB), xk ) ]->
   [ State_12111111111111( Nb, skB, xA, xNa, xk ) ]

rule (modulo E) F__0_12111111111111[color=#ffffff]:
   [ State_12111111111111( Nb, skB, xA, xNa, xk ) ] --> [ ]

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

end
