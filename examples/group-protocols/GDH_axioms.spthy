theory GDH_axioms
begin

builtins: diffie-hellman, multiset

functions: one/0

/* ************************************************************************ */
/* Axioms                                                                   */

// This rule might cause too many case distinctions.
// axiom IsNat_no_junk:
//  "All #i x. IsNzNat(x) @ i ==> x = one | (Ex y z. x = y + z)"

// The adversary can start a group member at most once.
axiom Start_once:
  "All #i #j gid idx A B.
     Member( gid, idx, A ) @ i & Member( gid, idx, B ) @ j ==> #i = #j"

// Unique cannot occur twice with the same argument.
axiom Unique:
  "All #i #j x. Unique( x ) @ i & Unique( x ) @ j ==> #i = #j"

// The same identity cannot be associated to different indices in a group.
axiom Participants_unique:
  "All #i #j gid idx1 idx2 A.
     Member( gid, idx1, A ) @ i & Member( gid, idx2, A ) @ j ==> #i = #j"

// Arguments of InEq are not equal.
axiom InEq:
  "not (Ex #i x. InEq(x,x) @ i)"

// Arguments of InEq are not equal.
axiom Eq:
  "All #i x y. Eq(x,y) @ i ==> x = y"

/*
  // Leq(x,y) implies that x <= y.
  axiom Leq:
    "All #i x y. Leq(x,y) @ i ==> Ex z. x + z = y | x = y"
*/

/* ************************************************************************ */
/* We model an authentic channel (with replay) using the fact !Authout.     */

// The adversary can overhear messages on the authentic channel
rule AuthOut:
  [ !AuthOut(t, x) ]
  -->
  [ Out(x) ]

/* ************************************************************************ */
/* Adversary queries to start group and set participants                    */

rule StartGroup:
  [ Fr( ~gid ), In( rounds ) ]
 --[ Unique( 'StartGroup' ), StartGroup( rounds ) ]->  // --[ IsNzNat(rounds) ]->  
  [ !Group( ~gid, rounds) ]
  // rounds - 1 = participants, i.e., we count the last round where everyone
  // receives except for the last participant as a round.

rule StartGroupMember:
  [ !Group( ~gid, idx + rest ) ]
 --[ Member( ~gid, idx, $A ) ]->
  [ Start( ~gid, idx )
  , !Agent( ~gid, idx, $A ) ]

/* ************************************************************************ */
/* Send rules for group member 1                                            */

rule InitiatorStart:
  [ Start( ~gid, one )
  , Fr( ~x ) ]
 --[ Nonce(one, ~x ) ]->
  [ !AuthOut( <~gid, 'ForRound', one + one, 'KeyFor'  , one>, 'g'   )
  , !AuthOut( <~gid, 'ForRound', one + one, 'RoundKey'>,      'g'^~x )
  , WaitAccept( ~gid, one, ~x ) ]

/* ************************************************************************ */
/* Send rules for remaining group members                                   */

rule ResponderStart:
  [ Start( ~gid, idx )
  , Fr( ~x ) ]
 --[ InEq(idx, one)
   , Nonce(idx, ~x ) ]->
  [ !WaitForKey( ~gid, idx, ~x ) ]

rule ResponderSendKeyFor:
  let Y = 'g'^y in // think of this as a group element check
  [ !WaitForKey( ~gid, idx, ~x )
  , !AuthOut( < ~gid, 'ForRound', idx, 'KeyFor', fidx>, Y )
  ]
 --[ Unique( < ~gid, idx, fidx > )
   , Exp( idx, y)
   , ExpKeyFor( idx, y)
   , ExpR( y )  // we use this for the variants
   ]->
  [ !AuthOut( < ~gid, 'ForRound', idx + one, 'KeyFor', fidx>, Y^~x ) ]

rule ResponderSendRoundKey:
  let Y = 'g'^y in
  [ !WaitForKey( ~gid, idx, ~x )
  , !Group( ~gid, rounds )
  , !AuthOut( < ~gid, 'ForRound', idx, 'RoundKey'>, Y )
  ]
 --[ Unique( < ~gid, idx, 'RoundKey' > )
   , InEq(idx + one, rounds)
   , Exp( idx, y)
   , ExpRoundKey( idx, y)
   , ExpR( y )]->
  [ !AuthOut( < ~gid, 'ForRound', idx + one, 'KeyFor', idx>, Y )
  , !AuthOut( < ~gid, 'ForRound', idx + one, 'RoundKey'>, Y^~x )
  , WaitAccept( ~gid, idx, ~x )]

rule ResponderLastRoundKey:
  let Y = 'g'^y in
  [ !WaitForKey( ~gid, idx, ~x )
  , !Group( ~gid, rounds )
  , !AuthOut( < ~gid, 'ForRound', idx, 'RoundKey'>, Y )
  ]
 --[ Unique( < ~gid, idx, 'RoundKey' > )
   , Eq(idx + one, rounds)
   , LastNonce( ~x )
   , Accept( ~gid, rounds, idx, Y^~x )
   , AcceptLast( ~gid, rounds, idx, Y^~x )   
   , ExpRoundKey( idx, y)
   , Exp( idx, y)
   , ExpR( y )
   ]->
  [ ]

/* ************************************************************************ */
/* Accept rules for group members                                           */

rule Accept:
  let Y = 'g'^y in
  [ WaitAccept( ~gid, idx, ~x )
  , !Group( ~gid, rounds)
  , !AuthOut( <~gid, 'ForRound', rounds, 'KeyFor', idx>, Y) ]
 --[ Accept( ~gid, rounds, idx, Y^~x )
   , ExpR( y )
   ]->
  []

/* ************************************************************************ */
/* Secrecy and related lemmas                                               */

lemma No_Inv_exp[use_induction,reuse,typing]:
  all-traces
  "not ((Ex #i x. ExpR( inv(x) ) @ i) | (Ex #i x y. ExpR( x * inv(y) ) @ i))"

lemma Nonce_secret[reuse]:
  all-traces
  "not (Ex #i #j x r. KU(x) @ i & Nonce(r, x) @ j)"

// check if really required
lemma nonce_fresh_name[reuse]:
  "All #i x r. Nonce(r, x) @ i ==> Ex ~n. x = ~n"

/* We can prove this one, but it is too prolific for proving the secrecy lemma. 
lemma Exp_earlier_Nonce[use_induction, reuse]:
  "All #i x ~n r1. Exp(r1, x * ~n) @ i
     ==> Ex r2 r3 #j. Nonce(r2, ~n) @ j & r1 = r2 + r3"
*/

/* We can prove this one using the earlier lemma. */
lemma Exp_earlier_Nonce_2[reuse]:
  all-traces
  "All #i #j x n r1 r2. Exp(r2, x * n) @ i & Nonce(r1, n) @ j
     ==> Ex r3. r2 = r1 + r3"

lemma roundkey_keyfor_different[use_induction,reuse]:
  all-traces
  "not (Ex #i #j idx y. ExpKeyFor( idx, y) @ i & ExpRoundKey( idx, y) @ j)"

/*
1. first \/ split
2. spliteq
3. !Authout
*/
lemma Exp_nonce_or_product2[use_induction,reuse]:
  all-traces
  "All #i x z. ExpR( x * z) @ i ==>
     (Ex #j r.  Nonce( r, x ) @ j) | (Ex #j ~n r. Nonce( r, ~n ) @ j & Ex y. x = y * ~n)"
  // It would be sufficient here to have `factorOf(n,x)' instead of
  // Ex y. x = y * n
  // we could maybe perform the proof using only introduction rules for factorOf

lemma Exp_factor_secret[reuse]:
  all-traces
  "not (Ex #i #j x y. ExpR( x * y ) @ i & KU( x ) @ j)"

// We prove the lemma for last participant first
lemma Key_secret:
  all-traces
  "not (Ex #i #j gid rounds idx k. K(k) @ i & AcceptLast( gid, rounds, idx, k) @ j)"


/* ************************************************************************ */
/* Executability lemmas                                                     */

lemma Accept_2:
  exists-trace
  "Ex #i1 #i2 gid k.
       Accept( gid, one + one + one, one,       k ) @ i1
     & Accept( gid, one + one + one, one + one, k ) @ i2"

lemma Accept_3:
  exists-trace
  "Ex #i1 #i2 #i3 gid k.
       Accept( gid, one + one + one + one, one,             k ) @ i1
     & Accept( gid, one + one + one + one, one + one,       k ) @ i2
     & Accept( gid, one + one + one + one, one + one + one, k ) @ i3"

lemma Accept_4:
  exists-trace
  "Ex #i1 #i2 #i3 #i4 gid k.
       Accept( gid, one + one + one + one + one, one,             k ) @ i1
     & Accept( gid, one + one + one + one + one, one + one,       k ) @ i2
     & Accept( gid, one + one + one + one + one, one + one + one, k ) @ i3
     & Accept( gid, one + one + one + one + one, one + one + one + one, k ) @ i4"

/* ************************************************************************ */
/* Experiments                                                             */

/*
lemma FactorOf_intro1[reuse]:
  all-traces
  "All #i x y. ExpR(x * y) @ i ==> Ex #j. FactorOf( y, x * y ) @ j"

lemma FactorOf_intro2[reuse]:
  all-traces
  "All #i x. ExpR(x) @ i ==> Ex #j. FactorOf( x, x ) @ j"

lemma FactorOf_trans[reuse]:
  all-traces
  "All #i #j x y z. FactorOf(y,x) @ i & FactorOf(z,y) @ j ==> Ex #k. FactorOf(z,x) @ k"

lemma FactorOf_destr_one[reuse]:
  all-traces
  "All #i x. FactorOf(x,one) @ i ==> x = one"


lemma Exp_Factor_nonce[reuse]:
  all-traces
  "All #i #j x y. ExpR( x ) @ i & FactorOf( y, x ) @ j ==>
    (Ex #j r.  Nonce( r, y ) @ j) | (Ex #j #k ~n r. Nonce( r, ~n ) @ j & FactorOf( ~n, y ) @ k )"

lemma Exp_factor_secret2[reuse]:
  all-traces
  "not (Ex #i #j #k x y. ExpR( x) @ i & FactorOf(y,x) @ k & KU( y ) @ j)"
*/

end