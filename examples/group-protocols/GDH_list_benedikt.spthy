theory GDH_List
begin

builtins: diffie-hellman, multiset

functions: nil/0, g/0, list_to_mset/1

axiom InEq_not_eq: "not (Ex x #i. InEq(x,x)@i)"

// this is a pre-fix closed version of IsLast which does not interfere with the lemma "No_inverses":
axiom IsLast: "All x A #i. IsLast(x,A) @ i ==> Ex #j. Last(x,A) @ j & j < i"

axiom MembersUnique: "All x A #i #j. Mem(x,A) @ i & Mem(x,A) @ j ==> #i = #j"


/*************************************************************************/
/* Setup                                                                 */
/*************************************************************************/

rule ChooseParticipants1:
  [ Fr(~gid) ]
 --[ Mem(~gid,$I), InEq($I, $R)
   , Mem(~gid,$R)
   , Last(~gid, $R)
 ]-> // groups have initiator (first) and responders
  [ F_StartGroup(~gid, $I, <$R, nil>) ]

rule ChooseParticipants2:
  [ F_StartGroup(~gid, $I, responders) ]
 --[ Mem(~gid,$R), StepC() ]->
  [ F_StartGroup(~gid, $I, <$R,responders>) ]

rule StartGroup1:
  [ F_StartGroup(~gid, $I, responders) ]
 --[ Step() , Started(~gid, $I) ]->
  [ F_Initiator1(~gid, $I, responders)                   // fork initiator which is round 0 (represented as nil)
  , F_StartResponders(~gid, responders, <$I,nil>, 1) ] // loop for starting responders

rule StartGroup2:
  [ F_StartResponders(~gid, <$R,notstarted>, started, round) ]
 --[ Started(~gid, $R) ]->
  [ F_Responder1(~gid, $R, started, notstarted, round)
  , F_StartResponders(~gid, notstarted, <$R,started>, round+1) ]

/*************************************************************************/
/* Initiator                                                             */
/*************************************************************************/

rule Initiator:
  let responders = <$R,other> in
  [ F_Initiator1(~gid, $I, responders)
  , Fr(~ei) ]
--[ AOut(~gid, $I, $I), AOut(~gid, $I, $R) 
  , Nonce(~gid, $I, ~ei)
  , NonceUsed(~gid, $I, ~ei)
  , Exp(~gid, $I, 1)   // assuming 1 is the neutral element of the multiplication in the exponents
  , Exp(~gid, $I, ~ei) // duplicate of ExpLast needed for inductive proof of "no inverses in exponent"
//  , ExpLast(~gid, nil, ~ei)
  , InvalidGKey(~gid, $I, g^~ei)
  , IsInitiator(~gid, $I)
  , Sent(~gid, $I, g)
  , Sent(~gid, $I, g^~ei)
  , InEq2($I, $R)
  ]->
  [ F_Initiator2(~gid, ~ei, $I, responders)
  , AuthOut(<~gid, $I, $I, g   >)    // from $I, key for $I
  , AuthOut(<~gid, $I, $R, g^~ei>)   // from $I, key for first responder $R
  , Out(g^~ei)
  ]

rule Initiator2:
  let Y = g^y in
  [ F_Initiator2(~gid, ~ei, $I, responders)
  , AuthOut(<~gid, $S, $I, Y>) ]  // $S unspecified, should be last(responders)
 --[ Key(~gid, $I, list_to_mset(responders) + $I)
   , KeyValue(~gid, Y^~ei)
   , Secret(~gid, Y^~ei)
//   , ExpInLast(~gid, 'final', y) 
   , NonceUsed(~gid, $I, ~ei)
   , InEq($S,$I) // the initiator will not accept it's own message from the prior step here
   , IsLast(~gid, $S)
  ]->
  [ ]

/*************************************************************************/
/* Responders                                                            */
/*************************************************************************/

rule Responder1:
  let Y = g^y in
  [ F_Responder1(~gid, $R, <$S, before_missing>, after, round)
  , Fr(~ec) 
  , AuthOut(<~gid, $S, $S, Y>) ]     // key for $S sent by $S
--[ AOut(~gid, $R, $S)
  , ReceiveFrom(~gid, $R, $S) 
  , Nonce(~gid, $R, ~ec)
  , NonceUsed(~gid, $R, ~ec)
  , Exp(~gid, $R, y*~ec) 
  , ExpIn(~gid, $R, y)
  , Sent(~gid, $R, Y^~ec)
  , InEq2($R, $S) // the participant will never send a message for itself at this point (only at very end!), the responder list is such that won't happen; also it is a simple check here that leads to failure if the participant itself appears in the list
  ]->
  [ F_Responder2(~gid, ~ec, $R, $S, before_missing, <$S, nil>, after, round)
  , AuthOut(<~gid, $R, $S, Y^~ec>)   // new key for $S sent by $R 
  , Out(Y^~ec)
  ]

rule Responder2:
  let Y = g^y in
  [ F_Responder2(~gid, ~ec, $R, $S, <$KR, before_missing>, before_rcvd, after, round)
  , AuthOut(<~gid, $S, $KR, Y>) ]     // key for $KR sent by $S
--[ AOut(~gid, $R, $KR) 
  , ReceiveFrom(~gid, $R, $S) 
  , NonceUsed(~gid, $R, ~ec)
  , Exp(~gid, $R, y*~ec)
  , ExpIn(~gid, $R, y)
  , Sent(~gid, $R, Y^~ec)
  , InEq2($R, $KR) // the participant will never send a message for itself at this point (only at very end!), the responder list is such that won't happen; also it is a simple check here that leads to failure if the participant itself appears in the list
  ]->
  [ F_Responder2(~gid, ~ec, $R, $S, before_missing, <$KR, before_rcvd>, after, round)
  , AuthOut(<~gid, $R, $KR, Y^~ec>)   // new key for $KR sent by $R
  , Out(Y^~ec)
  ]

rule Responder3:
  let Y = g^y 
      after = <$KR, after_missing>
  in
  [ F_Responder2(~gid, ~ec, $R, $S, nil, before_rcvd, after, round)
  , AuthOut(<~gid, $S, $R, Y>) ]      // key for $R sent by $S (groupkey last round)
--[ AOut(~gid, $R, $KR), AOut(~gid, $R, $R) 
  , ReceiveFrom(~gid, $R, $S) 
  , NonceUsed(~gid, $R, ~ec)
  , Exp(~gid, $R, y)     // this has been stated before (prior round, by sender of the message received here), but it needs to be stated again as otherwise an infinite loop is possible due to the second message (Y) being sent out
  , Exp(~gid, $R, y*~ec) // duplicate of ExpLast needed for inductive proof of "no inverses in exponent"
//  , ExpLast(~gid, round, y*~ec)
  , ExpInLast(~gid, $R, y)
  , InvalidGKey(~gid, $R, Y^~ec)
  , Sent(~gid, $R, Y^~ec)
  , InEq2($R, $KR) // the participant will never send two (different) message for itself, the responder list is such that won't happen; also it is a simple check here that leads to failure if the participant itself appears in the list
  ]->
  [ F_Responder3(~gid, ~ec, $R, before_rcvd, after, round)
  , AuthOut(<~gid, $R, $KR, Y^~ec>)   // group key this round - sent to next participant
  , AuthOut(<~gid, $R, $R, Y>)        // key for $R sent by $R
  , Out(Y^~ec)
  ]
  
rule Responder3_last:
  let Y = g^y in
  [ F_Responder2(~gid, ~ec, $R, $S, nil, before_rcvd, nil, round)
  , AuthOut(<~gid, $S, $R, Y>) ] // key for $R sent by $S (groupkey from last round)
--[ Key(~gid, $R, list_to_mset(before_rcvd) + $R ) 
  , ReceiveFrom(~gid, $R, $S) 
  , KeyValue(~gid, Y^~ec)
  , NonceUsed(~gid, $R, ~ec)
//  , ExpLast(~gid, round, y*~ec)
  , Exp(~gid, $R, y*~ec) // duplicate of ExpLast (that is actually NOT) needed for inductive proof of "no inverses in exponent"
  , ExpInLast(~gid, $R, y)
//  , ExpInLast(~gid, 'final', y)
  , Secret(~gid, Y^~ec)
  , InvalidGKey(~gid, $R, Y^~ec)
  ]->
  [ ]

rule Responder4:
  let Y = g^y in
  [ F_Responder3(~gid, ~ec, $R, p1, p2, round)
  , AuthOut(<~gid, $S, $R, Y>) ] // $S should be last ... 
 --[ Key(~gid, $R, list_to_mset(p1) + list_to_mset(p2) + $R )
   , KeyValue(~gid, Y^~ec)
   , NonceUsed(~gid, $R, ~ec)
   , Secret(~gid, Y^~ec)
//   , Exp(~gid, 'finalkey', y*~ec) // this seems unnecessary and potentially counter-productive 
//   , ExpInLast(~gid, 'final', y) // make these into ExpInFinal(~gid, y) instead, if they seem useful for anything (not the case now)
   , IsLast(~gid, $S) 
  ]->
  [ ]

axiom Start_unique:
  "All #i #j id R. Started(id,R) @ i & Started(id,R) @ j ==> #i=#j"

axiom ReceiveFrom_sender_determined:
  "All #i #j id R S1 S2. ReceiveFrom(id,R,S1) @ i & ReceiveFrom(id,R,S2) @ j ==> S1=S2"

// this should be a Lemma
axiom AOut_unique:
  "All #i #j id A B. AOut(id,A,B)@i & AOut(id,A,B)@j ==> #i = #j"

// get rid of non-trivial variants of rules due to inverses in exponents 
// works
lemma No_inverses_Exp[use_induction,reuse,typing]:
 all-traces
 "not (  (Ex #i x round id.   Exp(id, round, inv(x)  ) @ i)
       | (Ex #i x y round id. Exp(id, round, inv(x)*y) @ i))"

// get rid of non-trivial variants of rules due to inverses in exponents 
// works; needs "No_inverses_Exp" lemma above
lemma No_inverses_ExpIn[use_induction,reuse,typing]:
 all-traces
 "not (  (Ex #i x round id.   ExpIn(id, round, inv(x)  ) @ i)
       | (Ex #i x y round id. ExpIn(id, round, inv(x)*y) @ i))"

// get rid of non-trivial variants of rules due to inverses in exponents 
// works; probably needs "No_inverses_Exp" lemma above
lemma No_inverses_ExpInLast[use_induction,reuse,typing]:
 all-traces
 "not (  (Ex #i x round id.   ExpInLast(id, round, inv(x)  ) @ i)
       | (Ex #i x y round id. ExpInLast(id, round, inv(x)*y) @ i))"


// powerful since whenever adv. knows product with factor ~x, then he also knows ~x.
// works currently ; when "Nonce" only given in the rule that creates the fresh nonce, otherwise does NOT work!
lemma B[reuse]:
 all-traces
 "not (Ex id round #i1 x #i2. Nonce(id, round, x ) @ i1 &  KU( x ) @ i2)"

lemma Nonce_used[use_induction,reuse]:
  all-traces
  "All id round #i1 x. NonceUsed(id, round, x) @ i1 ==> (Ex #i2. Nonce(id, round, x) @i2)"

lemma Nonce_used_after[use_induction,reuse]:
  all-traces
  "All id round #i1 x. NonceUsed(id, round, x) @ i1 ==> (Ex #i2. Nonce(id, round, x) @i2 & (i2 < i1 | #i2 = #i1))"

lemma Nonce_Unique_issuer[reuse]:
  all-traces
  "All id1 id2 r1 r2 X #i1 #i2. Nonce(id1, r1, X) @i1 & Nonce(id2, r2, X) @i2 
                            ==> (id1 = id2 & r1 = r2)"

lemma NonceUsed_Unique_issuer[reuse]:
  all-traces
  "All id1 id2 r1 r2 X #i1 #i2. NonceUsed(id1, r1, X) @i1 & NonceUsed(id2, r2, X) @i2 
                            ==> (id1 = id2 & r1 = r2)"

// easily provable manually by always picking "Nonce" facts to resolve in a minute or so;
// automatic proof does work but takes a lot of time, about 8 minutes guesstimated
lemma NonceUsed_after_nonce[reuse]:  
  all-traces
  "All id round #i1 #i2 x. NonceUsed(id, round, x) @ i1 & Nonce(id, round, x) @i2 
                       ==>  (#i2 = #i1 | #i2 < #i1)"

lemma B_nonce_used[use_induction,reuse]:
  all-traces
  "not (Ex id round #i1 x #i2. NonceUsed(id, round, x ) @ i1 &  KU( x ) @ i2)"

lemma OnlyInitSends_gtotheone2[use_induction,reuse]:
  all-traces
  "not (Ex id R #i. ExpInLast(id, R, 1) @i)"

// needs 8 minutes with induction (24% mem)
// needs 15 minutes without induction
// OLD numbers above; now very quick, probably due to the $SAME_NAME_2 lemma above!
lemma OnlyInitSends_gtotheone[use_induction,reuse]:
  all-traces
  "All id R S #i. ExpIn(id, R, 1) @i & ReceiveFrom(id, R, S)@i
              ==> Ex #j. IsInitiator(id, S) @j & j < i"


// The use of the InEq2 axiom is reasonable, in that the participants can otherwise make simple checks and just stop execution. [TODO: get second opinion on this] // could have used InEq also, but wanted to make these clearly identifiably distinct.
axiom InEq2: "not (Ex x #i. InEq2(x,x)@i)"

lemma NextParticipantStartsAfterPriorFinishes[use_induction,reuse]:
  "All id R S #i. ReceiveFrom(id, R, S) @i 
              ==> (Ex X #j. InvalidGKey(id, S, X) @j & j<i)"

// Above WORKS - below DOES NOT
// TODO: continue here!





/*
//All terms that are sent are actually distinct - cannot be proven yet
lemma SentTermsDistinct[use_induction,reuse]:
  all-traces
  "not (Ex id R1 R2 X #i #j. Sent(id, R1, X) @i & Sent(id, R2, X) @j & (not (#i = #j)))"
//  "All id R1 X1 R2 X2 #i #j. Sent(id, R1, X1) @i & Sent(id, R2, X2) @j ==> not (X1 = X2)"
*/



/*
// UNIQUE appearance of IGK??? cannot be proven yet
lemma InvalidateGroupKeyUnique[use_induction,reuse]:
  "All id S X1 #i1 X2 #i2. InvalidGKey(id, S, X1) @i1 & InvalidGKey(id, S, X2) @i2
                       ==> #i1 = #i2"
*/

/*
// cannot be proven yet
//"half" this lemma already takes 35 minutes/40% memory, could be problematic... do long-time testrun - that longtime run failed (oom)
lemma InvalidateGroupKey[use_induction,reuse]:
  all-traces
  "All id R X #i #j. InvalidGKey(id, R, X) @i & KU(X) @j 
                ==> i < j"
*/


// cannot be proven yet
lemma ConnectExpInLastAndExpInByNonce[use_induction,reuse]:
  all-traces
  "All id R x y #i #j. ExpInLast(id, R, x) @i & ExpIn(id, R, y) @j & j < i 
                   ==> (Ex #k R2 z. NonceUsed(id, R2, z) @k & k < j & x = y * z)"



/*
for each round: [round-group-key = Y^z] where Y is sent out (exclude GK here obv.!) and z is a nonce from a PRIOR round! (then do induction)



we need some kind of LOCAL invariant that stays true in each iteration
from one sender to the next - but needs to be in relation to the group
key at the end - aka "incM ^ missingNonce = groupkey"; the problem for
this is the disconnect between the sort of local invariant and the
group key of that round - connecting that over arbitrary many vertical
and horizontal steps is hard! this might be a case of us getting
bitten by our choice to deal with each message separately instead of
having a whole list of it, so each local point has LESS information
and it is unclear if it is enough


Add 'invalidate(key)' at the point of ExpInLast message being sent -
and say that the key for that group is secret UNTIL invalidate has
happened - that should be useful for the induction at the end...



uniqueness of g^X for all such sent? would that help?


   Fr(n) @i [by using Nonce]
 & Sent(g^X)@j 
 & j < i 
==> not (Ex Y. X = Y*n)   [need to require that Y cannot be an inverse, otherwise this might not be true]

*/



// does NOT yet work
lemma ExpInLastHasOneMoreFACTORThanExpIn[reuse,use_induction]:
 all-traces
  "All id round x y #ix #iy. (  ExpInLast(id, round, x) @ix 
                              & ExpIn    (id, round, y) @iy 
         ==> (Ex z .  x = y*z) )" 


// does NOT yet work
lemma LastExpInHasOneMoreNonceThanExpIn[reuse,use_induction]:
 all-traces
  "All id round x y #ix #iy. (  ExpInLast(id, round, x) @ix 
                              & ExpIn    (id, round, y) @iy 
         ==> (Ex rz z #iz .  NonceUsed(id, rz, z) @iz 
                           & x = y*z) )" 

// does NOT yet work
lemma ExpIn_equal[reuse,use_induction]:
 all-traces
 "All id round x y #ix #iy. 
   (ExpIn(id, round, x) @ix & ExpIn(id, round, y) @iy ==>
         x = y 
      | (Ex r1 r2 z1 z2 #i1 #i2.  NonceUsed(id, r1, z1) @i1 
                                & NonceUsed(id, r2, z2) @i2 
                                & x * z1 = y * z2))"



// Ultimate goal for secrecy:
// does NOT work
lemma Key_secrecy:
 all-traces
  "All id K #i1. KeyValue(id, K) @i1 
                 ==> not (Ex #i2. KU(K) @i2)"


/*
// FALSE - due to g^1 being sent, and 1 is obviously known to the intruder...
lemma ExpIn_exp_secret[use_induction,reuse]:
  all-traces
  "not (Ex id round #i1 x #i2. ExpIn(id, round, x ) @ i1 &  KU( x ) @ i2)"
*/


// does NOT yet work
// lemma Exp_equal[reuse,use_induction]:
// all-traces
// "All id round x y #ix #iy. 
//   (Exp(id, round, x) @ix & Exp(id, round, y) @iy ==>
//         x = y 
//      | (Ex r1 r2 z1 z2 #i1 #i2.  Nonce(r1, z1) @i1 
//                                & Nonce(r2, z2) @i2 
//                                & x * z1 = y * z2)
//      | ExpLast(id, round, x) @ix
//      | ExpLast(id, round, y) @iy)"


/*
lemma key_agreement_2:
  exists-trace
  "Ex #j1 #j2 A B  id. Key(id, A, list_to_mset(<B,nil>) + A) @ j1
                     & Key(id, B, list_to_mset(<A,nil>) + B) @ j2
                     & not (A = B)"

// A initiator
// B middle
// C last
lemma key_agreement_3:
  exists-trace
  "Ex #j1 #j2 #j3 A B C id. 
      Key(id, A, list_to_mset(<B,C,nil>) + A) @ j1
    & Key(id, B, list_to_mset(<A,nil>) + list_to_mset(<C,nil>)+ B) @ j2
    & Key(id, C, list_to_mset(<A,B,nil>) + C) @ j3
    & not (A = B)
    & not (A = C)
    & not (B = C)"

//note that this order is not the one they have been created at; creation order is: A(initiator), C(last), B2, B1, ... (rest in reverse order)
// A initiator
// B1 middle (before B2)
// B2 middle (after B1)
// C last
lemma key_agreement_4:
  exists-trace
  "Ex #j1 #jb1 #jb2 #j3 A B1 B2 C id. 
      Key(id, A, list_to_mset(<B1,B2,C,nil>) + A) @ j1
    & Key(id, B1, list_to_mset(<A,nil>) + list_to_mset(<B2,C,nil>)+ B1) @ jb1 
    & Key(id, B2, list_to_mset(<A,B1,nil>) + list_to_mset(<C,nil>)+ B2) @ jb2 
    & Key(id, C, list_to_mset(<A,B1,B2,nil>) + C) @ j3
    & not (A = B1)
    & not (A = B2)
    & not (A = C)
    & not (B1 = B2)
    & not (B1 = C)
    & not (B2 = C)"

// A initiator
// B1 middle (before B2)
// B2 middle (after B1, before B3)
// B3 middle (after B2)
// C last
lemma key_agreement_5:
  exists-trace
  "Ex #j1 #jb1 #jb2 #jb3 #j3 A B1 B2 B3 C id. 
      Key(id, A, list_to_mset(<B1,B2,B3,C,nil>) + A) @ j1
    & Key(id, B1, list_to_mset(<A,nil>) + list_to_mset(<B2,B3,C,nil>)+ B1) @ jb1 
    & Key(id, B2, list_to_mset(<A,B1,nil>) + list_to_mset(<B3,C,nil>)+ B2) @ jb2 
    & Key(id, B3, list_to_mset(<A,B1,B2,nil>) + list_to_mset(<C,nil>)+ B3) @ jb3 
    & Key(id, C, list_to_mset(<A,B1,B2,B3,nil>) + C) @ j3
    & not (A = B1)
    & not (A = B2)
    & not (A = B3)
    & not (A = C)
    & not (B1 = B2)
    & not (B1 = B3)
    & not (B1 = C)
    & not (B2 = B3)
    & not (B2 = C)
    & not (B3 = C)"

// A initiator
// B1 middle (before B2)
// B2 middle (after B1, before B3)
// B3 middle (after B2, before B4)
// B4 middle (after B3)
// C last
lemma key_agreement_6:
  exists-trace
  "Ex #j1 #jb1 #jb2 #jb3 #jb4 #j3 A B1 B2 B3 B4 C id. 
      Key(id, A, list_to_mset(<B1,B2,B3,B4,C,nil>) + A) @ j1
    & Key(id, B1, list_to_mset(<A,nil>) + list_to_mset(<B2,B3,B4,C,nil>)+ B1) @ jb1 
    & Key(id, B2, list_to_mset(<A,B1,nil>) + list_to_mset(<B3,B4,C,nil>)+ B2) @ jb2 
    & Key(id, B3, list_to_mset(<A,B1,B2,nil>) + list_to_mset(<B4,C,nil>)+ B3) @ jb3 
    & Key(id, B4, list_to_mset(<A,B1,B2,B3,nil>) + list_to_mset(<C,nil>)+ B4) @ jb4 
    & Key(id, C, list_to_mset(<A,B1,B2,B3,B4,nil>) + C) @ j3
    & not (A = B1)
    & not (A = B2)
    & not (A = B3)
    & not (A = B4)
    & not (A = C)
    & not (B1 = B2)
    & not (B1 = B3)
    & not (B1 = B4)
    & not (B1 = C)
    & not (B2 = B3)
    & not (B2 = B4)
    & not (B2 = C)
    & not (B3 = B4)
    & not (B3 = C)
    & not (B4 = C)"
*/




end
