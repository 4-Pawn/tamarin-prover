# Axioms #
InEq, IsLast, MembersUnique

# Setup #
Creates one fact

    Initiator1(~gid, I, responders)

with list of responders [R1,..,Rk] and for each responder a fact

    Responder1(~gid, Ri, [Ri-1,..,R1,I], [Ri+1,Ri+2,..,Rk])

where the first list is of esponders that send before Ri and the second list is of
responders that send after Ri. Note that the list of previous responders is
reversed.

# Initiator #
There are two rules. In the first rule, the initiator sends `g` and `g^ei`.
In the second rule, he waits for "his" key material from the last responder.

# Responder #
There are 5 rules:

1. Responder1: Determine the sender (last element in the before list) and
   receive the key message for the sender. Creates a fact of the form
   ``Responder2(~gid, R, S, before_missing, before_received, after)``

2. Responder2: Receive (and forward) keys for other members of before list.
   Executed until before_missing is empty.

3. Responder3: Last forward step for non-last responder (after <> nil). Receive
   group key from last round. Forward directly (for ) 

4. Responder3_last: Last step for last responder. Computes key instead of
   forwarding anything.

5. Responder4: Receive key material and compute key for non-last responders.

# Executability proofs #

Consider the key_agreement_2 proof and the different branches:

1. Solve first key fact with Initiator and then solve everything up to
   StartGroup. Next, solve the other Key fact. The case where this is also an
   initiator is contradictory. Next, the case where this is a non-last
   responder pops up. Here, the proof search loops.

# Implementation Changes #
It seems like using the same heuristics for `trace-exists` and `all-traces`
is often a problem. In the first case, it often makes sense to unroll loop-facts
since the arguments already prevent looping.