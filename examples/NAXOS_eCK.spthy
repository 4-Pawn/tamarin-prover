theory NAXOS_eCK
begin

section{* The NAXOS Key-Exchange Protocol *}

/* Protocol rules */

/* In the description in the paper, we omitted the sorts. 
 * In this description they are made explicit.
 * '$A' is equivalent to 'A:pub'
 * '~x' is equivalent to 'x:fresh'
 */

/* Generate long-term keypair */
rule generate_ltk:
   [ Fresh( <'RegisterKey',$A> ), Fresh(~lkA) ] -->
   [ !Ltk( $A, ~lkA ), !Pk( $A, 'g'^~lkA ), Out( 'g'^~lkA ) ]

/* Initiator */
/* To formulate the responder property, we also define a SidI action for
 * the first rule. For brevity, we omitted this from the description in
 * the paper because there the responder property is not specified. */

rule Init_1:
   [ Fresh( ~ekI ), !Ltk( $I, ~lkI ) ]
   --[ SidI_1(~ekI,$I,$R, 'g'^h(< '1', ~ekI, ~lkI >)) ]->
   [ Init_1( ~ekI, $I, $R, ~lkI, 'g'^h(< '1', ~ekI, ~lkI >) ),
     !Ephk(~ekI),
     Out( 'g'^h(< '1', ~ekI, ~lkI >) ) ]

rule Init_2:
   [ Init_1( ~ekI, $I, $R, ~lkI , hkI), In( Y ), !Pk( $R,'g'^~lkR ) ]
   --[SidI_2( ~ekI, $I, $R, hkI, Y,
       h( < '2', Y^~lkI, ('g'^~lkR)^h(< '1', ~ekI, ~lkI>), Y^h(< '1', ~ekI, ~lkI>), $I, $R> ) ) ]->
   [ !Sessk( ~ekI, 
       h(< '2', Y^~lkI, ('g'^~lkR)^h(< '1', ~ekI, ~lkI> ), Y^h(< '1', ~ekI, ~lkI >), $I, $R>) ) ]

/* Responder */
rule Resp_1:
   [ In( X ), Fresh( ~ekR ), !Ltk($R, ~lkR), !Pk($I, 'g'^~lkI) ]
   --[ SidR_1( ~ekR, $I, $R, X, 'g'^h( < '1', ~lkR, ~ekR > ),
       h(< '2', ('g'^~lkI)^h(< '1', ~ekR, ~lkR >) ,X^~lkR, X^h(< '1', ~ekR, ~lkR >), $I, $R >) ) ]->
   [ Out( 'g'^h(<'1', ~ekR, ~lkR >) ),
     !Ephk(~ekR),
     !Sessk( ~ekR, 
       h(< '2', ('g'^~lkI)^h(<'1', ~ekR, ~lkR >) ,X^~lkR, X^h(<'1', ~ekR, ~lkR >), $I, $R >) ) ]

/* Key Reveals for the eCK model */
rule Sessk_reveal: 
   [ !Sessk(~tid, k) ]
   --[ SesskRev(~tid) ]->
   [ Out(k) ]

rule Ephk_reveal:
   [ !Ephk(~ekA) ]
   --[ EphkRev(~ekA) ]->
   [ Out(~ekA) ]

rule Ltk_reveal:
   [ !Ltk($A, k) ]
   --[ LtkRev($A) ]->
   [ Out(k) ]

rule log_deducible:
  [ In(x) ]
  --[ Deducible(x) ]-> []

/* Security properties */

/*
lemma key_agreement_reachable:
  "not (Ex #i1 #i2 ekI ekR I R k hkI hkR.
          SidI_2(ekI, I, R, hkI, hkR, k) @ i1 & SidR_1(ekR, I, R, hkI, hkR, k) @ i2)"
*/

/* An attack is valid in eCK if the session key of the test session is deduced and
   the test session is clean.
*/
lemma eCK_initiator_key:
  "not (Ex #i1 #i2 ttest I R k hkI hkR.
            SidI_2(ttest, I, R, hkI, hkR, k) @ i1 & Deducible( k ) @ i2

            /* Not both longterm-key-reveal _and_ ephemeral-key-reveal of actor . */
            & (All #i3 #i4. LtkRev( I ) @ i3 & EphkRev( ttest ) @ i4 ==> F)

            /* No session-key-reveal of test thread. */
            & (All #i3. SesskRev( ttest ) @ i3 ==> F)

            /* No session-key-reveal of partner thread. */
            & (All #i3 #i4 tpartner kpartner.
                   SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i3
		   & SesskRev( tpartner ) @ i4 ==> F)

            /* If there is a partner thread, then not long-term-key-reveal and ephemeral-key-reveal */
            & (All #i4 #i5 #i6 tpartner kpartner.
                  SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4
		  & LtkRev( R ) @ i5
		  & EphkRev( tpartner ) @ i6 ==> F)

	    /* If there is no partner thread, then there is no longterm-key-reveal for
	       the intended partner.
	       (We model eCK-wpfs, for eCK-pfs, add i1 < i3 to conclusion) */
            & (All #i3. LtkRev( R ) @ i3 ==>
	          (Ex #i4 tpartner kpartner.
                      (* (i1 < i3) | *)
                      SidR_1( tpartner,I,R,hkI,hkR,kpartner ) @i4)))"

/* An attack is valid in eCK if the session key of the test session is deduced and
   the test session is clean.
*/
lemma eCK_responder_key:
  "not (Ex #i1 #i2 ttest I R k hkI hkR.
            SidR_1(ttest, I, R, hkI, hkR, k) @ i1 & Deducible( k ) @ i2

            /* Not longterm-key-reveal _and_ ephemeral-key-reveal of actor . */
            & (All #i3 #i4. LtkRev( R ) @ i3 & EphkRev( ttest ) @ i4 ==> F)

            /* Not session-key-reveal of test thread. */
            & (All #i3. SesskRev( ttest ) @ i3 ==> F)

            /* Not session-key-reveal of partner thread. Note that we use SidI_2 here.
	       A session key reveal can only happen after SidI_2 is logged anyways.
	    */
            & (All #i3 #i4 tpartner kpartner.
                   SidI_2( tpartner,I,R,hkI,hkR,kpartner ) @i3
		   & SesskRev( tpartner ) @ i4 ==> F)

            /* If there is a partner thread, then not long-term-key-reveal and ephemeral-key-reveal. */
            & (All #i4 #i5 #i6 tpartner.
                  SidI_1( tpartner,I,R,hkI ) @i4
		  & LtkRev( I ) @ i5
		  & EphkRev( tpartner ) @ i6 ==> F)

	    /* If there is no partner thread, then there is no longterm-key-reveal for
	       the intended partner.
	       (We model eCK-wpfs, for eCK-pfs, add i1 < i3 to conclusion)
	       */
            & (All #i3. LtkRev( I ) @ i3 ==>
	          (Ex #i4 tpartner.
                       (* (i1 < i3) | *)
                       SidI_1( tpartner,I,R,hkI ) @i4)))"

end
