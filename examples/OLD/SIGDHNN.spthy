theory SIGDHNN
begin






















section{* Signed Diffie-Hellman Key-Exchange Protocol without partner identities in signatures *}

text{*
*}

rule Reveal_pk:
  [ ] --> [ Send( pk(lts($m)) ) ]

rule Reveal_lts:
  [ Knows( m ) ] --> [ LTSR( m ), Send( lts(m) ) ]

/* Protocol rules */


rule reveal_pk:
   [ ] --> [ Send('g'^sk(lts($X))) ]

rule sigdhnn_I_1:
   [ Fresh( ~ni ) ]
   -->
   [ sigdhnn_I_1( $I, $R, ~ni ), Send( <$I, sign{'1', 'g'^~ni}sk(lts($I)) >) ]

rule sigdhnn_I_2:
   [ sigdhnn_I_1( $I, $R, ~ni ), Knows( <$R, sign{'2', Gr}sk(lts($R)) > ) ]
   -->
   [ sigdhnn_I_2( $I, $R, ~ni, Gr ) ]

rule sigdhnn_R_1:
   [ Knows( <I, sign{'1', Gi}sk(lts(I)) > ) ] --> [ sigdhnn_R_1( I, $R, Gi ) ]

rule sigdhnn_R_2:
   [ sigdhnn_R_1( I, $R, Gi ), Fresh( ~nr ) ]
   -->
   [ sigdhnn_R_2( I, $R, Gi, ~nr ), Send( <$R, sign{'2', 'g'^~nr}sk(lts($R)) >) ]


/* Session keys */


rule SeKeyI:
  [ sigdhnn_I_2( $I, $R, ~ni, Gr ) ]
  -->
  [ SeKeyI(Gr^~ni , <$I,$R,'g'^~ni,Gr> ) ]


rule SeKeyR:
  [ sigdhnn_R_2( I, $R, Gi, ~nr ) ]
  -->
  [ SeKeyR(Gi^~nr , <I,$R,Gi,'g'^~nr> ) ]


subsection{* Secrecy Properties *}


/*
Security Model (Compromise Rules without premises)
Filtering is done in the property conclusions (property violation ==> security model violation)
*/

	
 
/*
lemma I_executable:
  "not(v :> sigdhnn_I_2( $I, $R, ~ni, Gr ) )"

lemma R_executable:
  "not(v :> sigdhnn_R_2( I, $R, Gi, ~nr ) )"
*/

 
lemma I_secrecy_ephkeys:
  "( v :> sigdhnn_I_2( $I, $R, ~ni, Gr ) & u :> Knows(~ni) )
   ==>  (Ex #rN Agv. ( rN :> LTSR(Agv) & ((Agv = $I) | (Agv = $R)))) "

lemma R_secrecy_ephkeys:
  "( v :> sigdhnn_R_2( I, $R, Gi, ~nr ) & u :> Knows(~nr) )
   ==>  (Ex #rN Agv. ( rN :> LTSR(Agv) & ((Agv = $R) | (Agv = I)))) "

 
lemma I_secrecy_key:
  "vkey :> SeKeyI(k, <$I, $R, Gi, Gr>) & vk :> Knows(k)
  ==>  (Ex #rN Agv. ( rN :> LTSR(Agv) & ((Agv = $I) | (Agv = $R)))) "

lemma R_secrecy_key:
  "vkey :> SeKeyR(k, <I, $R, Gi, Gr>) & vk :> Knows(k)
  ==>  (Ex #rN Agv. ( rN :> LTSR(Agv) & ((Agv = $R) | (Agv = I)))) "


end
