divert(-1)
dnl 
dnl Generic macros for generating .spthy files.
dnl 
dnl Contrary to advice, switch quotes, otherwise too hard to generate
dnl 'g' strings.
dnl
changequote()
changequote(<!,!>)
dnl
dnl  Long-term keys
dnl
define(<!SK!>,<!sk(lts($1))!>)
define(<!PK!>,<!'g'^SK($1)!>)
dnl
dnl Include compromise model macros
dnl 
include(compromise.m4h)
dnl
dnl Basic DH structure with just exchanged exponents
dnl
dnl Critical: the parameters eki and ekr must use ni and nr as the
dnl underlying nonces, because these are freshly generated and stored in
dnl the state.
dnl The parameters eki and ekr may in fact be instantiated with ~ni and
dnl ~nr.
dnl
dnl Parameters: name, eki, ekr 
dnl
define(<!basicDH!>,<!
rule reveal_pk:
   [ ] --> [ Out(PK($X)) ]

rule $1_I_1:
   [ Fr( ~ni ) ]
   -->
   [ $1_I_1( $I, $R, ~ni ), Out( <$I, 'g'^$2 revealRNR(~ni)>) ]

rule $1_I_2:
   [ $1_I_1( $I, $R, ~ni ), In( <$R, Gr> ) ]
   -->
   [ $1_I_2( $I, $R, ~ni, Gr ) ]

rule $1_R_1:
   [ In( <I, Gi> ) ] --> [ $1_R_1( I, $R, Gi ) ]

rule $1_R_2:
   [ $1_R_1( I, $R, Gi ), Fr( ~nr ) ]
   -->
   [ $1_R_2( I, $R, Gi, ~nr ), Out( <$R, 'g'^$3 revealRNR(~nr)>) ]
!>)
dnl
dnl Alternative: signed DH without names
dnl
define(<!sigDHnn!>,<!
rule reveal_pk:
   [ ] --> [ Out(PK($X)) ]

rule $1_I_1:
   [ Fr( ~ni ) ]
   -->
   [ $1_I_1( $I, $R, ~ni ), Out( <$I, sign{'1', 'g'^$2}SK($I) revealRNR(~ni)>) ]

rule $1_I_2:
   [ $1_I_1( $I, $R, ~ni ), In( <$R, sign{'2', Gr}SK($R) > ) ]
   -->
   [ $1_I_2( $I, $R, ~ni, Gr ) ]

rule $1_R_1:
   [ In( <I, sign{'1', Gi}SK(I) > ) ] --> [ $1_R_1( I, $R, Gi ) ]

rule $1_R_2:
   [ $1_R_1( I, $R, Gi ), Fr( ~nr ) ]
   -->
   [ $1_R_2( I, $R, Gi, ~nr ), Out( <$R, sign{'2', 'g'^$3}SK($R) revealRNR(~nr)>) ]
!>)
dnl
dnl Alternative 2: signed DH with names
dnl
define(<!sigDH!>,<!
rule reveal_pk:
   [ ] --> [ Out(PK($X)) ]

rule $1_I_1:
   [ Fr( ~ni ) ]
   -->
   [ $1_I_1( $I, $R, ~ni ), Out( <$I, sign{'1', 'g'^$2, $R}SK($I) revealRNR(~ni)>) ]

rule $1_I_2:
   [ $1_I_1( $I, $R, ~ni ), In( <$R, sign{'2', Gr, $I}SK($R) > ) ]
   -->
   [ $1_I_2( $I, $R, ~ni, Gr ) ]

rule $1_R_1:
   [ In( <I, sign{'1', Gi, $R}SK(I) > ) ] --> [ $1_R_1( I, $R, Gi ) ]

rule $1_R_2:
   [ $1_R_1( I, $R, Gi ), Fr( ~nr ) ]
   -->
   [ $1_R_2( I, $R, Gi, ~nr ), Out( <$R, sign{'2', 'g'^$3, I }SK($R) revealRNR(~nr)>) ]
!>)
dnl
dnl Generic construction for session keys
dnl
dnl parameters: name,K,eki,ekr
dnl
define(<!sessionkeyI!>,<!
rule SeKeyI:
  [ $1_I_2( $I, $R, ~ni, Gr ) ]
  -->
  [ SeKeyI($2, <$I,$R,'g'^$3,Gr> ) ]
!>)
dnl
dnl parameters:name,K,eki,ekr
dnl
define(<!sessionkeyR!>,<!
rule SeKeyR:
  [ $1_R_2( I, $R, Gi, ~nr ) ]
  -->
  [ SeKeyR($2, <I,$R,Gi,'g'^$4> ) ]
!>)
dnl
dnl Security properties
dnl
dnl Executability
dnl parameters: name
dnl
dnl Note: disabled for now
dnl
define(<!DHPExecutable!>,<! 
/*
lemma I_executable:
  "not(v :> $1_I_2( $I, $R, ~ni, Gr ) )"

lemma R_executable:
  "not(v :> $1_R_2( I, $R, Gi, ~nr ) )"
*/
!>)
dnl
dnl
dnl Security Model
dnl
dnl Maybe we can parameterize it later, with similar parameter names in
dnl the violation code.
dnl
define(<!SecModel!>,<!
/*
Security Model (Compromise Rules without premises)
Filtering is done in the property conclusions (property violation ==> security model violation)
*/
addAdversaryConclusions(DolevYao)
!>)
dnl
dnl Security Model Violation (aka filtering)
dnl
dnl Parameter list might have to be extended later for more complicated models
dnl
dnl parameters: node (end of test), actor name, peer name, outgoing DH
dnl public key, incoming DH public key
dnl
define(<!SecModelViolation!>,defn(<!addAdversaryPremise!>))
dnl
dnl Secrecy
dnl
dnl parameters: protocol name, lemma subname, I's secret, R's secret
dnl
define(<!DHPSecrecy!>,<! 
dnl
lemma I_secrecy_$2:
  "( v :> $1_I_2( $I, $R, ~ni, Gr ) & u :> In($3) )
   ==> SecModelViolation(v,$I,$R,'g'^~ni,Gr)"

lemma R_secrecy_$2:
  "( v :> $1_R_2( I, $R, Gi, ~nr ) & u :> In($4) )
   ==> SecModelViolation(v,$R,I,Gi,'g'^~nr)"
!>)
dnl
dnl
dnl Session Key Secrecy
dnl
dnl parameters: protocol name
dnl
define(<!DHPKeySecrecy!>,<! 
lemma I_secrecy_key:
  "vkey :> SeKeyI(k, <$I, $R, Gi, Gr>) & vk :> In(k)
  ==> SecModelViolation(vkey,$I,$R,Gi,Gr)"

lemma R_secrecy_key:
  "vkey :> SeKeyR(k, <I, $R, Gi, Gr>) & vk :> In(k)
  ==> SecModelViolation(vkey,$R,I,Gi,Gr)"
!>)

divert
