theory Envelope begin

text{* Envelope protocol example from:

Stephanie Delaune, Steve Kremer, Mark D. Ryan, Graham Steel, "Formal Analysis
of Protocols Based on TPM State Registers," csf, pp.66-80, 2011 IEEE 24th
Computer Security Foundations Symposium, 2011.
*}


// TPM PCR model
rule PCR_Init:
    [ Fr('PCRInit')   // initialization happens at most once
    , Fr(~aik)        // Authentication identity key
    ]
  --[ // PCR_Init('pcr0',~aik)
      PCR_Write('pcr0')
    ]->
    [ PCR('pcr0')            // the initial PCR value is 'pcr0'
    , PCR_Write('pcr0')      // We also track the writes.
    , !AIK(~aik)             // the auth. id. key is persistent
    , Out(pk(~aik))          // publish the public key of the auth. id. key
    ]


rule PCR_Reboot:
    [ PCR(x), PCR_Write(x) ] 
  --[ PCR_Write('pcr0')
    ]-> 
    [ PCR_Write('pcr0')
    , PCR('pcr0')
    ]  // reset the PCR to 'pcr0'

rule PCR_Extend:
    [ PCR_Write(x)
    , PCR(x)
    , In(y) 
    ] 
  --[ PCR_Write(h(x,y))
    ]-> 
    [ PCR(h(x,y)) 
    , PCR_Write(h(x,y))
    ]

rule PCR_CertKey:
    [ !AIK(aik)
    , !KeyTable(lock, sk)
    ]
  --[ ]->
    [ Out(sign{'certkey', lock, pk(sk)}aik) 
    ]

rule PCR_Quote:
    [ PCR(x)
    , !AIK(aik)
    ]
  --[ PCR_Read(x) 
    ]->
    [ Out(sign{'certpcr', x}aik) 
    , PCR(x)
    ]

rule PCR_Unbind:
    [ PCR(x)
    , !KeyTable(x, sk)
    , In( aenc{m}pk(sk) )
    ]
  --[ PCR_Unbind(x,sk,m)
    , PCR_Read(x)
    ]->
    [ PCR(x)
    , Out(m) ]

// Alice
rule Alice1:
    [ Fr(~n)
    , PCR(x)
    , PCR_Write(x)
    ]
  --[ // PCR_Alice1(h(x,~n))
      //Use(x)
    //, Update(x, h(x,~n))
      PCR_Write(h(x,~n))
    ]->
    [ PCR(h(x,~n))
    , PCR_Write(h(x,~n))
    , Alice1(~n)
    ]

rule Alice2:
    [ Alice1(n)
    , Fr(~s)
    , !AIK(aik)
    , In(sign{'certkey', h(h('pcr0',n),'obtain'), pk}aik)
    ]
  --[ Secret(~s) 
    ]->
    [ Out(aenc{~s}pk)
    , Alice2(n,~s)
    ]

rule Alice3:
    [ Alice2(n,s)
    , !AIK(aik)
    , In(sign{'certpcr', h(h('pcr0',n),'deny')}aik)
    ]
  --[ Denied(s) ]->
    []

// Bob
rule CreateLockedKey:
    [ PCR(x)
    , Fr(~sk)
    , In(lock) // multiple keys can be locked to the same PCR value.
    ]
  --[ //CreateKey(x,~sk,lock)
    // , Use(x)
      PCR_Read(x)
    ]->
    [ PCR(x)
    , !KeyTable(h(x,lock), ~sk)
    , Out(pk(~sk))
    ]

// Deducability
rule Deducible: [ In(x) ] --[ Deducible(x) ]-> []

lemma types [typing]:
  " (All x #i. PCR_Read(x) @ i ==>
      (Ex #j. PCR_Write(x) @ j)
    )
  & (All m d1 d2 #i. PCR_Unbind(d1, d2, m) @ i ==>
        (m --| i)
      | (Ex #j. Secret(m) @ j)
    )
  "

/*
lemma PCR_Read_Write [reuse]:
  "(All x #i. PCR_Read(x) @ i ==>
     (Ex #j. PCR_Write(x) @ j)
   )"
*/

/*
lemma PCR_Update_Unique [reuse]:
  "(All x y1 #i1. Update(x, y1) @ i1 ==>
      (All y2 #i2. Update(x, y2) @ i2 ==>
           y1 = y2        
        & #i1 = #i2
      )
   )"
*/

lemma reachable_Denied:
  "not(Ex s #i #j #k. Secret(s) @ i & Denied(s) @ j & Deducible(s) @ k)"

// lemma reachable_Denied:
  // "not(Ex s #i #j. Secret(s) @ i & Denied(s) @ j)"

/* Lemmas from mutual secrecy access.


lemma types [typing]:
  " (All m d1 d2 #i. PCR_Unbind(d1, d2, m) @ i ==>
        (m --| i)
      | (Ex s #j. Secrets(m, s) @ j)
      | (Ex s #j. Secrets(s, m) @ j)
    )
  "

lemma Unbind_PCR_Value [reuse]:
    "All x sk m #i.
        PCR_Unbind(x, sk, m) @ i
        ==>
        ( (Ex aik #j.     PCR_Init(x, aik) @ j  )
        | (Ex y xPrev #j. PCR_Extend(xPrev,y,x) @ j)
        )
    "

lemma secrecy:
  "not(
      (All t #e. Ineq(t,t) @ e ==> F)
    & (Ex s0 s1 #i #d0 #d1. 
          Secrets(s0, s1) @ i
        & Deducible(s0) @ d0
        & Deducible(s1) @ d1
      )
    )"

*/

end
