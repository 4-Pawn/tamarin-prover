theory CSF11_RunningExample begin

section{* Finite Variants of the Intruder Rules *}

 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, x.4 )
   -->
    !KD( 'exp', x.2^(x.4*x.3) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, inv(x.3) ) --> !KD( 'exp', x.2 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, x.3 ) --> !KD( 'exp', x.2 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, inv(x.4) )
   -->
    !KD( 'exp', x.2^inv((x.4*x.3)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, x.4 )
   -->
    !KD( 'exp', x.2^x.3 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, inv(x.3) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, x.3 )
   -->
    !KD( 'exp', x.2^inv(x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, (x.4*inv(x.3)) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, inv((x.4*x.3)) )
   -->
    !KD( 'exp', x.2^inv(x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, (x.4*x.3) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, inv(x.5) )
   -->
    !KD( 'exp', x.2^(x.3*inv((x.5*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, (x.4*inv(x.5)) )
   -->
    !KD( 'exp', x.2^(x.4*inv((x.5*x.3))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, x.4 )
   -->
    !KD( 'exp', x.2^(x.3*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.5*x.4) )
   -->
    !KD( 'exp', x.2^(x.5*x.3) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, (x.5*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.5*x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, inv((x.5*x.3)) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, (x.5*x.3) )
   -->
    !KD( 'exp', x.2^(x.5*inv(x.4)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, (x.4*inv((x.5*x.3))) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.5*inv(x.6)) )
   -->
    !KD( 'exp', x.2^((x.5*x.3)*inv((x.6*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.4*inv(x.3)) )
   -->
    !KD( 'exp', x.2 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, inv((x.5*x.3)) )
   -->
    !KD( 'exp', x.2^inv((x.5*x.4)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, (x.3*inv(x.5)) )
   -->
    !KD( 'exp', x.2^inv((x.5*x.4)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, (x.6*x.4) )
   -->
    !KD( 'exp', x.2^((x.6*x.3)*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, (x.5*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^((x.5*x.4)*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ), !KU( f_, (x.5*inv(x.3)) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, (x.4*inv(x.3)) )
   -->
    !KD( 'exp', x.2^inv(x.5) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, ((x.5*x.4)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^x.5 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.4*inv((x.5*x.3))) )
   -->
    !KD( 'exp', x.2^inv(x.5) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ), !KU( f_, inv((x.6*x.3)) )
   -->
    !KD( 'exp', x.2^(x.4*inv((x.6*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, ((x.5*x.3)*inv(x.6)) )
   -->
    !KD( 'exp', x.2^(x.5*inv((x.6*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, (x.4*inv(x.6)) )
   -->
    !KD( 'exp', x.2^(x.3*inv((x.6*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.5*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^(x.5*inv((x.6*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ),
    !KU( f_, ((x.5*x.4)*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^(x.5*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ),
    !KU( f_, (x.5*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ),
    !KU( f_, (x.4*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^inv((x.6*x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ),
    !KU( f_, ((x.6*x.4)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.6*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ),
    !KU( f_, (x.5*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ),
    !KU( f_, ((x.6*x.5)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.6*x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ),
    !KU( f_, (x.6*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^((x.6*x.4)*inv((x.7*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ),
    !KU( f_, ((x.6*x.4)*inv(x.7)) )
   -->
    !KD( 'exp', x.2^((x.6*x.3)*inv((x.7*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ),
    !KU( f_, ((x.6*x.5)*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^((x.6*x.4)*inv(x.7)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ),
    !KU( f_, ((x.7*x.5)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^((x.7*x.4)*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ),
    !KU( f_, ((x.6*x.4)*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^(x.6*inv((x.7*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ),
    !KU( f_, (x.5*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^(x.4*inv((x.7*x.6))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ),
    !KU( f_, ((x.7*x.5)*inv((x.8*x.3))) )
   -->
    !KD( 'exp', x.2^((x.7*x.4)*inv((x.8*x.6))) )
 
 rule (modulo AC) Inv:
    !KD( f_, inv(x.1) ) --> !KD( 'noexp', x.1 )
 
 rule (modulo AC) snd:
    !KD( f_, <x.1, x.2> ) --> !KD( 'noexp', x.2 )
 
 rule (modulo AC) fst:
    !KD( f_, <x.1, x.2> ) --> !KD( 'noexp', x.1 )
 
 rule (modulo AC) adec:
    !KD( f1_, aenc{x.3}pk(x.2) ), !KU( f2_, x.2 )
   -->
    !KD( 'noexp', x.3 )
 
 rule (modulo AC) sdec:
    !KD( f1_, senc{x.3}x.2 ), !KU( f2_, x.2 ) --> !KD( 'noexp', x.3 )
 
 rule (modulo AC) verify:
    !KD( f1_, sign{x.3}x.2 ), !KU( f2_, pk(x.2) )
   -->
    !KD( 'noexp', x.3 )
 
 rule (modulo AC) Exp:
    !KU( 'noexp', x ), !KU( f_, x.1 ) --> !KU( 'exp', x^x.1 )
 
 rule (modulo AC) Unit:
   --> !KU( 'noexp', 1 )
 
 rule (modulo AC) h:
    !KU( f_, x ) --> !KU( 'noexp', h(x) )
 
 rule (modulo AC) pk:
    !KU( f_, x ) --> !KU( 'noexp', pk(x) )
 
 rule (modulo AC) snd:
    !KU( f_, x ) --> !KU( 'noexp', snd(x) )
 
 rule (modulo AC) fst:
    !KU( f_, x ) --> !KU( 'noexp', fst(x) )
 
 rule (modulo AC) senc:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', senc{x}x.1 )
 
 rule (modulo AC) aenc:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', aenc{x}x.1 )
 
 rule (modulo AC) adec:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', adec(x.1, x) )
 
 rule (modulo AC) sdec:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', sdec(x.1, x) )
 
 rule (modulo AC) sign:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', sign{x}x.1 )
 
 rule (modulo AC) verify:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', verify(x.1, x) )
 
 rule (modulo AC) coerce:
    !KD( f_, x ) --> !KU( f_, x )
 
 rule (modulo AC) pub:
   --> !KU( f_, $x )
 
 rule (modulo AC) gen_fresh:
    Fr( ~x ) --> !KU( 'noexp', ~x )

text{* Running example from:

Stephanie Delaune, Steve Kremer, Mark D. Ryan, Graham Steel, "Formal Analysis
of Protocols Based on TPM State Registers," csf, pp.66-80, 2011 IEEE 24th
Computer Security Foundations Symposium, 2011.
*}

rule (modulo E) PCR_Init:
   Fr( 'PCRInit' ), Fr( ~aik )
  --[ PCR_Init( 'pcr0', ~aik ) ]->
   PCR( 'pcr0' ), !AIK( ~aik ), Out( pk(~aik) )

rule (modulo E) PCR_Extend:
   PCR( x ), In( y )
  --[ PCR_Extend( x, y, h(<x, y>) ) ]->
   PCR( h(<x, y>) )

rule (modulo E) PCR_CertKey:
   !AIK( aik ), !KeyTable( x, sk )
  --[ PCR_CertKey_Inst( x ) ]->
   Out( sign{<'certkey', x, pk(sk)>}aik )

rule (modulo E) PCR_Unbind:
   PCR( x ), !KeyTable( x, sk ), In( aenc{m}pk(sk) )
  --[ PCR_Unbind( x, sk, m ) ]->
   PCR( x ), Out( m )

rule (modulo E) Deducible:
   In( x ) --[ Deducible( x ) ]->

rule (modulo E) Alice_Init:
   Fr( ~s ), Fr( ~s.1 ), !AIK( aik ),
   In( sign{<'certkey', x, pk>}aik ),
   In( sign{<'certkey', x.1, pk.1>}aik )
  --[ Ineq( x, x.1 ), Secrets( ~s, ~s.1 ) ]->
   Out( aenc{~s}pk ), Out( aenc{~s.1}pk.1 )

rule (modulo E) MkKey:
   Fr( <'MkKey', $a> ), Fr( ~ska )
  -->
   !KeyTable( h(<'pcr0', $a>), ~ska )

lemma (modulo E) types [typing]:
  "All m d.1 d.2 #i.3.
    (PCR_Unbind( d.1, d.2, m ) @ #i.3) ==>
    (((m --| #i.3) | (Ex s.4 #j.5. Secrets( m, s.4 ) @ #j.5)) |
     (Ex s.6 #j.7. Secrets( s.6, m ) @ #j.7))"
/* proof based on the same lemma modulo AC */
/*
doubly-guarded formula characterizing all attacks:
"Ex m d.1 d.2 #i.3.
  (PCR_Unbind( d.1, d.2, m ) @ #i.3)
 &
  (All. (m --| #i.3) ==> F) &
  (All s.4 #j.5. (Secrets( m, s.4 ) @ #j.5) ==> F) &
  (All s.6 #j.7. (Secrets( s.6, m ) @ #j.7) ==> F)"
*/
/*
proof by induction possible over the formula:
"(Ex m d.1 d.2 #i.3.
   (PCR_Unbind( d.1, d.2, m ) @ #i.3)
  &
   (All. (m --| #i.3) ==> F) &
   (All s.4 #j.5. (Secrets( m, s.4 ) @ #j.5) ==> F) &
   (All s.6 #j.7. (Secrets( s.6, m ) @ #j.7) ==> F)) &
 (All m.8 d.9 d.10 #i.11.
   (PCR_Unbind( d.9, d.10, m.8 ) @ #i.11)
  ==>
   (Last(#i.11)) |
   (Ex. (m.8 --| #i.11) & T) |
   (Ex s.12 #j.13.
     (Secrets( m.8, s.12 ) @ #j.13)
    &
     All. (Last(#j.13)) ==> F) |
   (Ex s.14 #j.15.
     (Secrets( s.14, m.8 ) @ #j.15)
    &
     All. (Last(#j.15)) ==> F))"
*/
induction
  case induction
  simplify
  solve( Disj(Last(#i.3)) | (Ex. (m --| #i.3) & T) |
             (Ex s.1 #j.2.
               (Secrets( m, s.1 ) @ #j.2)
              &
               All. (Last(#j.2)) ==> F) |
             (Ex s.1 #j.2.
               (Secrets( s.1, m ) @ #j.2)
              &
               All. (Last(#j.2)) ==> F) )
    case case_1
    solve( (#i.3, 0)[PCR( d.1 )] )
      case PCR_Extend
      solve( (#i.3, 1)[!KeyTable( h(<x.11, y.12>), d.2 )] )
        case MkKey
        solve( (#vf.7, 0)[!KU( f_.8, aenc{m}pk(~ska.19) )] )
          case Alice_Init_case_1
          by contradiction // from formulas
        next
          case Alice_Init_case_2
          by contradiction // from formulas
        next
          case PCR_Unbind
          solve( Disj(Last(#vr.28)) | (Ex. (t.27 --| #vr.28) & T) |
                     (Ex s.28 #j.29.
                       (Secrets( t.27, s.28 ) @ #j.29)
                      &
                       All. (Last(#j.29)) ==> F) |
                     (Ex s.28 #j.29.
                       (Secrets( s.28, t.27 ) @ #j.29)
                      &
                       All. (Last(#j.29)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by contradiction // cyclic
          next
            case case_3
            by solve( (#vl.26, 0) ~~> (#vr.25, 0) )
          next
            case case_4
            by solve( (#vl.26, 0) ~~> (#vr.25, 0) )
          qed
        next
          case aenc
          by contradiction // from formulas
        qed
      qed
    next
      case PCR_Init
      by solve( (#i.3, 1)[!KeyTable( 'pcr0', d.2 )] )
    next
      case PCR_Unbind
      solve( Disj(Last(#vr.10)) | (Ex. (m.13 --| #vr.10) & T) |
                 (Ex s.14 #j.15.
                   (Secrets( m.13, s.14 ) @ #j.15)
                  &
                   All. (Last(#j.15)) ==> F) |
                 (Ex s.14 #j.15.
                   (Secrets( s.14, m.13 ) @ #j.15)
                  &
                   All. (Last(#j.15)) ==> F) )
        case case_1
        by contradiction // cyclic
      next
        case case_2
        solve( (#i.3, 1)[!KeyTable( h(<'pcr0', $a.11>), d.2 )] )
          case MkKey
          solve( (#vf.7, 0)[!KU( f_.8, aenc{m}pk(~ska.12) )] )
            case Alice_Init_case_1
            by contradiction // from formulas
          next
            case Alice_Init_case_2
            by contradiction // from formulas
          next
            case PCR_Unbind
            solve( Disj(Last(#vr.36)) | (Ex. (t.35 --| #vr.36) & T) |
                       (Ex s.36 #j.37.
                         (Secrets( t.35, s.36 ) @ #j.37)
                        &
                         All. (Last(#j.37)) ==> F) |
                       (Ex s.36 #j.37.
                         (Secrets( s.36, t.35 ) @ #j.37)
                        &
                         All. (Last(#j.37)) ==> F) )
              case case_1
              by contradiction // cyclic
            next
              case case_2
              by contradiction // cyclic
            next
              case case_3
              by solve( (#vl.34, 0) ~~> (#vr.33, 0) )
            next
              case case_4
              by solve( (#vl.34, 0) ~~> (#vr.33, 0) )
            qed
          next
            case aenc
            by contradiction // from formulas
          qed
        qed
      next
        case case_3
        solve( (#i.3, 1)[!KeyTable( h(<'pcr0', $a.11>), d.2 )] )
          case MkKey
          solve( (#vf.7, 0)[!KU( f_.8, aenc{m}pk(~ska.12) )] )
            case Alice_Init_case_1
            by contradiction // from formulas
          next
            case Alice_Init_case_2
            by contradiction // from formulas
          next
            case PCR_Unbind
            solve( Disj(Last(#vr.51)) | (Ex. (t.50 --| #vr.51) & T) |
                       (Ex s.51 #j.52.
                         (Secrets( t.50, s.51 ) @ #j.52)
                        &
                         All. (Last(#j.52)) ==> F) |
                       (Ex s.51 #j.52.
                         (Secrets( s.51, t.50 ) @ #j.52)
                        &
                         All. (Last(#j.52)) ==> F) )
              case case_1
              by contradiction // cyclic
            next
              case case_2
              by contradiction // cyclic
            next
              case case_3
              by solve( (#vl.49, 0) ~~> (#vr.48, 0) )
            next
              case case_4
              by solve( (#vl.49, 0) ~~> (#vr.48, 0) )
            qed
          next
            case aenc
            by contradiction // from formulas
          qed
        qed
      next
        case case_4
        solve( (#i.3, 1)[!KeyTable( h(<'pcr0', $a.11>), d.2 )] )
          case MkKey
          solve( (#vf.7, 0)[!KU( f_.8, aenc{m}pk(~ska.12) )] )
            case Alice_Init_case_1
            by contradiction // from formulas
          next
            case Alice_Init_case_2
            by contradiction // from formulas
          next
            case PCR_Unbind
            solve( Disj(Last(#vr.51)) | (Ex. (t.50 --| #vr.51) & T) |
                       (Ex s.51 #j.52.
                         (Secrets( t.50, s.51 ) @ #j.52)
                        &
                         All. (Last(#j.52)) ==> F) |
                       (Ex s.51 #j.52.
                         (Secrets( s.51, t.50 ) @ #j.52)
                        &
                         All. (Last(#j.52)) ==> F) )
              case case_1
              by contradiction // cyclic
            next
              case case_2
              by contradiction // cyclic
            next
              case case_3
              by solve( (#vl.49, 0) ~~> (#vr.48, 0) )
            next
              case case_4
              by solve( (#vl.49, 0) ~~> (#vr.48, 0) )
            qed
          next
            case aenc
            by contradiction // from formulas
          qed
        qed
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  next
    case case_4
    by contradiction // from formulas
  qed
qed

lemma (modulo E) Unbind_PCR_Value [reuse]:
  "All x sk.1 m.2 #i.3.
    (PCR_Unbind( x, sk.1, m.2 ) @ #i.3) ==>
    ((Ex aik.4 #j.5. PCR_Init( x, aik.4 ) @ #j.5) |
     (Ex y.6 xPrev.7 #j.8. PCR_Extend( xPrev.7, y.6, x ) @ #j.8))"
/* proof based on the same lemma modulo AC */
/*
doubly-guarded formula characterizing all attacks:
"Ex x sk.1 m.2 #i.3.
  (PCR_Unbind( x, sk.1, m.2 ) @ #i.3)
 &
  (All aik.4 #j.5. (PCR_Init( x, aik.4 ) @ #j.5) ==> F) &
  (All y.6 xPrev.7 #j.8.
    (PCR_Extend( xPrev.7, y.6, x ) @ #j.8)
   ==>
    F)"
*/
/*
proof by induction possible over the formula:
"(Ex x sk.1 m.2 #i.3.
   (PCR_Unbind( x, sk.1, m.2 ) @ #i.3)
  &
   (All aik.4 #j.5. (PCR_Init( x, aik.4 ) @ #j.5) ==> F) &
   (All y.6 xPrev.7 #j.8.
     (PCR_Extend( xPrev.7, y.6, x ) @ #j.8)
    ==>
     F)) &
 (All x.9 sk.10 m.11 #i.12.
   (PCR_Unbind( x.9, sk.10, m.11 ) @ #i.12)
  ==>
   (Last(#i.12)) |
   (Ex aik.13 #j.14.
     (PCR_Init( x.9, aik.13 ) @ #j.14)
    &
     All. (Last(#j.14)) ==> F) |
   (Ex y.15 xPrev.16 #j.17.
     (PCR_Extend( xPrev.16, y.15, x.9 ) @ #j.17)
    &
     All. (Last(#j.17)) ==> F))"
*/
induction
  case induction
  simplify
  solve( Disj(Last(#i.3)) |
             (Ex aik.1 #j.2.
               (PCR_Init( x, aik.1 ) @ #j.2)
              &
               All. (Last(#j.2)) ==> F) |
             (Ex y.1 xPrev.2 #j.3.
               (PCR_Extend( xPrev.2, y.1, x ) @ #j.3)
              &
               All. (Last(#j.3)) ==> F) )
    case case_1
    solve( (#i.3, 0)[PCR( x )] )
      case PCR_Extend
      by contradiction // from formulas
    next
      case PCR_Init
      by contradiction // from formulas
    next
      case PCR_Unbind
      solve( Disj(Last(#vr.10)) |
                 (Ex aik.12 #j.13.
                   (PCR_Init( h(<'pcr0', $a.11>), aik.12 ) @ #j.13)
                  &
                   All. (Last(#j.13)) ==> F) |
                 (Ex y.12 xPrev.13 #j.14.
                   (PCR_Extend( xPrev.13, y.12, h(<'pcr0', $a.11>) ) @ #j.14)
                  &
                   All. (Last(#j.14)) ==> F) )
        case case_1
        by contradiction // cyclic
      next
        case case_3
        by contradiction // from formulas
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  qed
qed

lemma (modulo E) secrecy:
  "not((All t #e.1. (Ineq( t, t ) @ #e.1) ==> (F)) &
       (Ex s.2 s.3 #i.4 #d.5 #d.6.
         ((Secrets( s.2, s.3 ) @ #i.4) & (Deducible( s.2 ) @ #d.5)) &
         (Deducible( s.3 ) @ #d.6)))"
/* proof based on the same lemma modulo AC */
/*
doubly-guarded formula characterizing all attacks:
"(All t #e.1. (Ineq( t, t ) @ #e.1) ==> F) &
 (Ex s.2 s.3 #i.4 #d.5 #d.6.
   (Secrets( s.2, s.3 ) @ #i.4) &
   (Deducible( s.2 ) @ #d.5) &
   (Deducible( s.3 ) @ #d.6)
  &
   T)"
*/
/*
proof by induction possible over the formula:
"(All t #e.1. (Ineq( t, t ) @ #e.1) ==> F) &
 (Ex s.2 s.3 #i.4 #d.5 #d.6.
   (Secrets( s.2, s.3 ) @ #i.4) &
   (Deducible( s.2 ) @ #d.5) &
   (Deducible( s.3 ) @ #d.6)
  &
   T) &
 ((Ex t.7 #e.8.
    (Ineq( t.7, t.7 ) @ #e.8)
   &
    All. (Last(#e.8)) ==> F) |
  (All s.9 s.10 #i.11 #d.12 #d.13.
    (Secrets( s.9, s.10 ) @ #i.11) &
    (Deducible( s.9 ) @ #d.12) &
    (Deducible( s.10 ) @ #d.13)
   ==>
    (Last(#d.13)) | (Last(#d.12)) | (Last(#i.11))))"
*/
simplify
solve( (#i.2, 2)[!AIK( aik.7 )] )
  case PCR_Init
  solve( (#vf.14, 0)[!KU( f_.15, sign{<'certkey', x.8, pk.9>}~aik.26
                     )] )
    case PCR_CertKey
    solve( (#vf.16, 0)[!KU( f_.17,
                            sign{<'certkey', x.10, pk.11>}~aik.26
                       )] )
      case PCR_CertKey
      solve( (#vf.19, 0)[!KU( f_.20, ~s.5 )] )
        case Alice_Init
        solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
          case Alice_Init
          by solve( (#vr.94, 1)[!KU( f2_.95, ~ska.34 )] )
        next
          case PCR_Unbind
          solve( Disj(Ex aik.114 #j.115.
                       (PCR_Init( h(<'pcr0', $a.113>), aik.114 ) @ #j.115)
                      &
                       T) |
                     (Ex y.114 xPrev.115 #j.116.
                       (PCR_Extend( xPrev.115, y.114, h(<'pcr0', $a.113>) ) @ #j.116)
                      &
                       T) )
            case case_2
            by solve( (#vr.94, 1)[!KU( f2_.95, ~ska.34 )] )
          qed
        qed
      next
        case PCR_Unbind
        solve( Disj(Ex aik.83 #j.84.
                     (PCR_Init( h(<'pcr0', $a.82>), aik.83 ) @ #j.84)
                    &
                     T) |
                   (Ex y.83 xPrev.84 #j.85.
                     (PCR_Extend( xPrev.84, y.83, h(<'pcr0', $a.82>) ) @ #j.85)
                    &
                     T) )
          case case_2
          solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
            case Alice_Init
            solve( (#vr.81, 0)[PCR( h(<'pcr0', $a.82>) )] )
              case PCR_Extend
              solve( (#vf.84, 0)[!KU( f_.85, aenc{~s.5}pk(~ska.83) )] )
                case Alice_Init
                solve( (#j.119, 0)[PCR( 'pcr0' )] )
                  case PCR_Init
                  by solve( (#vr.141, 1)[!KU( f2_.142, ~ska.58 )] )
                qed
              next
                case aenc
                by contradiction // cyclic
              qed
            next
              case PCR_Unbind
              solve( (#vf.84, 0)[!KU( f_.85, aenc{~s.5}pk(~ska.83) )] )
                case Alice_Init
                solve( (#j.119, 0)[PCR( 'pcr0' )] )
                  case PCR_Init
                  by solve( (#vr.141, 1)[!KU( f2_.142, ~ska.58 )] )
                qed
              next
                case aenc
                by contradiction // cyclic
              qed
            qed
          next
            case PCR_Unbind
            solve( Disj(Ex aik.130 #j.131.
                         (PCR_Init( h(<'pcr0', $a.129>), aik.130 ) @ #j.131)
                        &
                         T) |
                       (Ex y.130 xPrev.131 #j.132.
                         (PCR_Extend( xPrev.131, y.130, h(<'pcr0', $a.129>) ) @ #j.132)
                        &
                         T) )
              case case_2
              solve( (#vr.81, 0)[PCR( h(<'pcr0', $a.82>) )] )
                case PCR_Extend
                solve( (#vf.84, 0)[!KU( f_.85, aenc{~s.5}pk(~ska.83) )] )
                  case Alice_Init
                  solve( (#j.119, 0)[PCR( 'pcr0' )] )
                    case PCR_Init
                    solve( (#vr.128, 0)[PCR( h(<'pcr0', $a.129>) )] )
                      case PCR_Extend
                      solve( (#vf.131, 0)[!KU( f_.132, aenc{~s.6}pk(~ska.130) )] )
                        case Alice_Init
                        solve( (#j.166, 0)[PCR( 'pcr0' )] )
                          case PCR_Init
                          by contradiction // from formulas
                        qed
                      next
                        case aenc
                        by contradiction // cyclic
                      qed
                    next
                      case PCR_Unbind
                      solve( (#vf.131, 0)[!KU( f_.132, aenc{~s.6}pk(~ska.130) )] )
                        case Alice_Init
                        solve( (#j.166, 0)[PCR( 'pcr0' )] )
                          case PCR_Init
                          by contradiction // from formulas
                        qed
                      next
                        case aenc
                        by contradiction // cyclic
                      qed
                    qed
                  qed
                next
                  case aenc
                  by contradiction // cyclic
                qed
              next
                case PCR_Unbind
                solve( (#vf.84, 0)[!KU( f_.85, aenc{~s.5}pk(~ska.83) )] )
                  case Alice_Init
                  solve( (#j.119, 0)[PCR( 'pcr0' )] )
                    case PCR_Init
                    solve( (#vr.128, 0)[PCR( h(<'pcr0', $a.129>) )] )
                      case PCR_Extend
                      solve( (#vf.131, 0)[!KU( f_.132, aenc{~s.6}pk(~ska.130) )] )
                        case Alice_Init
                        solve( (#j.166, 0)[PCR( 'pcr0' )] )
                          case PCR_Init
                          by contradiction // from formulas
                        qed
                      next
                        case aenc
                        by contradiction // cyclic
                      qed
                    next
                      case PCR_Unbind
                      solve( (#vf.131, 0)[!KU( f_.132, aenc{~s.6}pk(~ska.130) )] )
                        case Alice_Init
                        solve( (#j.166, 0)[PCR( 'pcr0' )] )
                          case PCR_Init
                          by contradiction // from formulas
                        qed
                      next
                        case aenc
                        by contradiction // cyclic
                      qed
                    qed
                  qed
                next
                  case aenc
                  by contradiction // cyclic
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case sign
      solve( (#vf.19, 0)[!KU( f_.20, ~s.5 )] )
        case Alice_Init
        solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
          case Alice_Init
          by solve( (#vr.56, 1)[!KU( f2_.58, ~aik.26 )] )
        next
          case PCR_Unbind
          solve( Disj(Ex aik.98 #j.99.
                       (PCR_Init( h(<'pcr0', $a.97>), aik.98 ) @ #j.99)
                      &
                       T) |
                     (Ex y.98 xPrev.99 #j.100.
                       (PCR_Extend( xPrev.99, y.98, h(<'pcr0', $a.97>) ) @ #j.100)
                      &
                       T) )
            case case_2
            by solve( (#vr.56, 1)[!KU( f2_.58, ~aik.26 )] )
          qed
        qed
      next
        case PCR_Unbind
        solve( Disj(Ex aik.67 #j.68.
                     (PCR_Init( h(<'pcr0', $a.66>), aik.67 ) @ #j.68)
                    &
                     T) |
                   (Ex y.67 xPrev.68 #j.69.
                     (PCR_Extend( xPrev.68, y.67, h(<'pcr0', $a.66>) ) @ #j.69)
                    &
                     T) )
          case case_2
          solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
            case Alice_Init
            by solve( (#vr.56, 1)[!KU( f2_.58, ~aik.26 )] )
          next
            case PCR_Unbind
            solve( Disj(Ex aik.114 #j.115.
                         (PCR_Init( h(<'pcr0', $a.113>), aik.114 ) @ #j.115)
                        &
                         T) |
                       (Ex y.114 xPrev.115 #j.116.
                         (PCR_Extend( xPrev.115, y.114, h(<'pcr0', $a.113>) ) @ #j.116)
                        &
                         T) )
              case case_2
              by solve( (#vr.56, 1)[!KU( f2_.58, ~aik.26 )] )
            qed
          qed
        qed
      qed
    qed
  next
    case sign
    solve( (#vf.16, 0)[!KU( f_.17,
                            sign{<'certkey', x.10, pk.11>}~aik.26
                       )] )
      case PCR_CertKey
      solve( (#vf.19, 0)[!KU( f_.20, ~s.5 )] )
        case Alice_Init
        solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
          case Alice_Init
          by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
        next
          case PCR_Unbind
          solve( Disj(Ex aik.98 #j.99.
                       (PCR_Init( h(<'pcr0', $a.97>), aik.98 ) @ #j.99)
                      &
                       T) |
                     (Ex y.98 xPrev.99 #j.100.
                       (PCR_Extend( xPrev.99, y.98, h(<'pcr0', $a.97>) ) @ #j.100)
                      &
                       T) )
            case case_2
            by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
          qed
        qed
      next
        case PCR_Unbind
        solve( Disj(Ex aik.67 #j.68.
                     (PCR_Init( h(<'pcr0', $a.66>), aik.67 ) @ #j.68)
                    &
                     T) |
                   (Ex y.67 xPrev.68 #j.69.
                     (PCR_Extend( xPrev.68, y.67, h(<'pcr0', $a.66>) ) @ #j.69)
                    &
                     T) )
          case case_2
          solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
            case Alice_Init
            by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
          next
            case PCR_Unbind
            solve( Disj(Ex aik.114 #j.115.
                         (PCR_Init( h(<'pcr0', $a.113>), aik.114 ) @ #j.115)
                        &
                         T) |
                       (Ex y.114 xPrev.115 #j.116.
                         (PCR_Extend( xPrev.115, y.114, h(<'pcr0', $a.113>) ) @ #j.116)
                        &
                         T) )
              case case_2
              by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
            qed
          qed
        qed
      qed
    next
      case sign
      solve( (#vf.19, 0)[!KU( f_.20, ~s.5 )] )
        case Alice_Init
        solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
          case Alice_Init
          by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
        next
          case PCR_Unbind
          solve( Disj(Ex aik.82 #j.83.
                       (PCR_Init( h(<'pcr0', $a.81>), aik.82 ) @ #j.83)
                      &
                       T) |
                     (Ex y.82 xPrev.83 #j.84.
                       (PCR_Extend( xPrev.83, y.82, h(<'pcr0', $a.81>) ) @ #j.84)
                      &
                       T) )
            case case_2
            by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
          qed
        qed
      next
        case PCR_Unbind
        solve( Disj(Ex aik.51 #j.52.
                     (PCR_Init( h(<'pcr0', $a.50>), aik.51 ) @ #j.52)
                    &
                     T) |
                   (Ex y.51 xPrev.52 #j.53.
                     (PCR_Extend( xPrev.52, y.51, h(<'pcr0', $a.50>) ) @ #j.53)
                    &
                     T) )
          case case_2
          solve( (#vf.22, 0)[!KU( f_.23, ~s.6 )] )
            case Alice_Init
            by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
          next
            case PCR_Unbind
            solve( Disj(Ex aik.98 #j.99.
                         (PCR_Init( h(<'pcr0', $a.97>), aik.98 ) @ #j.99)
                        &
                         T) |
                       (Ex y.98 xPrev.99 #j.100.
                         (PCR_Extend( xPrev.99, y.98, h(<'pcr0', $a.97>) ) @ #j.100)
                        &
                         T) )
              case case_2
              by solve( (#vr.32, 1)[!KU( f2_.34, ~aik.26 )] )
            qed
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end