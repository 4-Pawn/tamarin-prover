
/*
example illustrating two trace lemmas
*/

theory TwoTrace
begin

let P = new a; event Secret(a); out (c, a);  out(c)
let Q = in(c, x); event Received(x)

new c; (P || Q)

lemma secret:
  all-traces 
  "All x #i. ( Secret(x) @ i ==> not (Ex #j. K(x) @ j) )"

lemma received:
  exists-trace
  "Ex x #i. Received(x) @ i"

lemma freshness [two_trace]:
  all-traces
  "All a id1 #i. Secret(a)@i & Event(id1)@i ==> not Ex id2 #j. Secret(a)@j & Event(id2)@j & not (id1 = id2)"

/* restriction secret:
  "All x #i. Secret(x)@i ==> Ex #j. Received(x)@j"

test tau1:
  "Ex #i. Did(x)"

lemma test [two_trace]:
  all-traces
  "All id1 x #i. (Did(x)@i & Event(id1)@i & Ex id2 #j. K(x)@ j & Did(x)@j & Event(id2)@j) ==> not(x = x)"

// A lemma of the following form cannot be shown as it is possible to find a violating trace, that is
   a trace such that Ex id1. phi(id1) /\ All id2. ~psi(id1, id2)
   i.e. we can always do something completely different in the second trace than in the first
lemma test:
  all-traces
  "All id1. phi(id1) ==> Ex id2. psi(id1, id2)" 

 However, we should be able to express such a lemma using a restriction for the premise and a lemma for the conclusion.
 To be consistent, we require Init(id1) to occur before Init(id2)

 restriction pre [two_trace]:
   "Ex id.  First(id) & phi(id)"

 Note that this restriction doesn't impose any restrictions on the second trace.

 lemma cons [two_trace]:
   exists-trace
   "Ex id1 id2. First(id1) & Second(id2) & psi(id1, id2)"
/*

restriction two_execs [two_trace]:
  "All id1 id2 id3 #i #j #k. Init(id1)@i & Init(id2)@j & Init(id3)@k ==> id1 = id2 | id1 = id3 | id2 = id3"

end

/* vim: set filetype=apip */