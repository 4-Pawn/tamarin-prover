theory FOO_Vote_Privacy
begin


/*
 * Protocol: Protocol by Fujioka, Okamoto and Ohta (FOO) (Vote-Privacy)
 * Modeler: Charles DumÃ©nil
 * Date: July 2016	
 * Source: Formal verification of voting and auction protocols by Jannik Dreier
 * Status: To be tested (Anonymous channels are modelled differently) 
 */


/*
  Protocol FOO {                                 ( Administration and collector are considered corrupted )
    Phase 1:
     V -> A: < blind(commit(v,r),b), sign(blind(commit(v,r),b),skV) >      " v1( diff(A,B) ) & v2( diff(B,A) ) "
     A -> V: < blind(commit(v,r),b), sign(blind(commit(v,r),b),skA) >      "Registered" + "Check sign Voter"
    Phase 2:
     V -> C: < commit(vote,r), sign(commit(vote,r),ltkA) >                 "Check sign Admin" + "Check commit"
    Phase 3:
     C -> Pub: < commit(vote,r), sign(commit(vote,r),ltkA) >               "Check sign Admin"
     V -> C:  r                                                            "Check commit"
     C -> Pub: v                                                           "VotePublished" + "Check r"
  }
*/


builtins: multiset
functions: pk/1, sign/2, checksign/2, blind/2, unblind/2, open/2, commit/2
equations: open(commit(m,r),r)=m,
           checksign( sign(m,sk),pk(sk) ) = m,
           unblind(blind(m,r),r) = m,
           unblind(sign(blind(m,r),sk),r) = sign(m,sk)


// Public key infrastructure

rule Register_Voter_pk:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk('v1', ~ltkV), !Pk('v1', pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Voter_pk2:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk('v2', ~ltkV), !Pk('v2', pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Admin_pk:
  [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(~ltkA) ]


// Generates votes

rule setup:
  [  ]
  --[ OnlyOnce() ]->
  [ Vote1( diff($candA, $candB) ), Vote2( diff($candB, $candA) ) ]


// Rules

rule V_1_1:
  let e = blind( commit( $vote , ~r ), ~b )
      s = sign ( blind( commit( $vote , ~r ), ~b ) , ~ltkV1 )
in
    [ Fr( ~r ), Fr( ~b ), Vote1($vote), !Ltk( 'v1', ~ltkV1 )]
  --[ V_1_1( ) ]->
    [ Out( < e , s > ), St_V_1( 'v1', $vote, ~r, ~b )]

rule V_1_2:
  let e = blind( commit( $vote , ~r ), ~b )
      s = sign ( blind( commit( $vote , ~r ), ~b ) , ~ltkV2 )
in
    [ Fr( ~r ), Fr( ~b ), Vote2($vote), !Ltk( 'v2', ~ltkV2 )]
  --[ V_1_2( ) ]->
    [ Out( < e , s > ), St_V_1( 'v2', $vote, ~r, ~b )]

rule V_2:
  let e = blind(commit($vote,~r),~b)
      d = sign(blind(commit($vote,~r),~b),~ltkA)
      y = sign(commit($vote,~r),~ltkA)
      x = commit($vote,~r)
  in
    [ In( <e,d> ), St_V_1( V, $vote, ~r, ~b),  !AdminPk(A, pk(~ltkA)) ]
  --[ V_2( ) ]->     
    [ St_V_2_sync( <x,y>),St_V_3_sync(V, $vote, ~r) ]

rule V_2_sync:  
    [ St_V_2_sync( m1), St_V_2_sync( m2) ]
  --[ V_2_sync( ) ]->     
    [ Anonym_Ch_Out( m1 + m2) ]

rule V_3:
  let x = commit($vote1,~r1)
      y = commit($vote2,~r2)
  in
    [ Anonym_Ch_In( x + y), St_V_3_sync(V1, $vote1, ~r1), St_V_3_sync(V2, $vote2, ~r2) ]
  --[ V_3( ) ]->
    [ /*Anonym_Ch_Out( ~r1+ ~r2)*/ Out( <~r1, ~r2>) ]

rule Anonymous_Ch_Out:
  [ Anonym_Ch_Out( m1 + m2) ]
  --[  ]->
  [ Out(m1), Out(m2) ]

rule Anonymous_Ch_In:
  [ In(m1), In(m2) ]
  --[  ]->
  [ Anonym_Ch_In( m1 + m2) ]


// Axioms

axiom onlyOnce:
  " All #i #j. OnlyOnce()@i & OnlyOnce()@j ==> #i = #j "


// Executability

lemma exec2:
  exists-trace
  " Ex #i. V_3( )@i  "

end
