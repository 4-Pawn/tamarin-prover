theory FOO
begin

/*
 * Protocol: Protocol by Fujioka, Okamoto and Ohta (FOO)
 * Modeler: Charles DumÃ©nil
 * Date: 19/07/2016	
 * Source: Formal verification of voting and auction protocols by Jannik Dreier
 * Status: Working 
 */


/*
  Protocol FOO {
    Phase 1:
     V -> A: < blind(commit(v,r),b), sign(blind(commit(v,r),b),skV) >
     A -> V: < blind(commit(v,r),b), sign(blind(commit(v,r),b),skA) >      "Registered" + "Check sign Voter"
    Phase 2:
     V -> C: < commit(vote,r), sign(commit(vote,r),ltkA) >                 "Check sign Admin" + "Check commit"
    Phase 3:
     C -> Pub: commit(vote,r)                                              "Check sign Admin"
     V -> C:  r                                                            "Check commit"
     C -> Pub: v                                                           "VotePublished" + "Check r"
  }
*/


builtins: signing
functions: getmess/1, blind/2, unblind/2, open/2, commit/2
equations: getmess(sign(m,sk)) = m,
           open(commit(m,r),r) = m,
           unblind(blind(m,r),r) = m,
           unblind(sign(blind(m,r),sk),r)=sign(m,sk)

// Public key infrastructure
rule Register_Voter_pk:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk($V, ~ltkV), !Pk($V, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Admin_pk:
  [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(pk(~ltkA)) ]


//Rules

rule V_1:
  let x = commit( ~vote , ~r )
      e = blind( x, ~b )
      s = sign ( e , ~ltkV )
  in
    [ Fr( ~r ), Fr( ~b ), Fr( ~vote ), !Ltk( V, ~ltkV ) ]
  --[ Created_V_1(~vote), Create_V_1(e) ]->
    [ Out( <e,s> ), St_V_1( V, ~vote, ~r, ~b ) ]

rule A_1:
  let d = sign( e, ~ltkA )
      verif = verify( s,e, pkV)
  in
    [ In( <e,s> ), !AdminLtk( A, ~ltkA ), !Pk( V, pkV ) ]
  --[ Eq( verif, true ) ,  Registered(e), In_A_1(e) ]->
    [ Out(  <e,d>  ) ]

rule V_2:    // Check Admin_Signature & Check the commit 
  let y = unblind(d,~b)   // = sign(x,ltkA)
      x = commit(~vote,~r)
      verif = verify( d, e, pkA)
  in
    [ In( <e,d> ), St_V_1( V, ~vote, ~r, ~b),  !AdminPk(A, pkA) ]
  --[ Eq( verif, true ) , Eq( e, blind(commit(~vote,~r),~b) ), In_V_2( e ) ]->     
    [ Out( <x,y> ) , St_V_2( V, A, ~vote, ~r ) ]

rule C_1:
  let verif = verify( y, x, pkA)
  in
    [ In( <x,y> ), !AdminPk(A, pkA)]
  --[ Eq( verif, true ) ]->
    [ St_C_1( A, x), Out(x) ]

rule V_3:
    [ In(x), St_V_2(V, A, ~vote, ~r )]
  --[ Eq( x, commit(~vote,~r) ) ]->
    [ Out( ~r ) ]

rule C_2:
  let v = open( x, r)
  in
    [ In( r ), St_C_1( A, x ) ]
  --[ Eq ( x, commit(open(x,r),r) ), VotePublished( v ), Out_C_2(v) ]->
    [ Out( v ) ]


// Axioms

axiom Equality:
"All x y #i. Eq(x,y) @i ==> x = y"

axiom OnlyOneVotPerVoter:
  "
  All e1 e2 #i #j. Registered(e1) @i & Registered(e2)@j
  ==>
  #i = #j"


// typing lemma

lemma types [typing]:
  " (
  All e #i. In_A_1(e) @ i
  ==>
  ( (Ex #j . Create_V_1( e )  @ j & j<i )
  ) ) & (
  All e #i. In_V_2(e) @ i
  ==>
  ( (Ex #j. In_A_1(e)@j & j<i )
  ) ) & (
  All v #i. Out_C_2(v) @ i
  ==>
  ( (Ex #j. Created_V_1(v)@j & j<i )
  ) )"


// Property

lemma elligibility:
  " 
  All v #j.
  VotePublished (v) @ j
  ==> 
  ( ( Ex r b #i.  Registered(blind(commit(v,r),b)) @ i & #i < #j )  )"


end

