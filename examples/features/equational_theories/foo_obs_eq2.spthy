theory FOO_Equiv2
begin

/*
 * Protocol: Foo	
 * Modeler: 	
 * Date: 	
 * Source:	
 *
 * Status: Working, to be optimized
 */

builtins: multiset

functions: pk/1, sign/2, checksign/2, blind/2, unblind/2, open/2, commit/2, v1/0, v2/0

equations: open(commit(m,r),r)=m,
           checksign( sign(m,sk),pk(sk) ) = m,
           unblind(blind(m,r),r) = m,
           unblind(sign(blind(m,r),sk),r)=sign(m,sk)

/* We formalize the following protocol

  protocol FOO {
    Phase 1:
     V -> A: < blind(commit(v,r),b), sign(blind(commit(v,r),b),skV) >
     A -> V: < blind(commit(v,r),b), sign(blind(commit(v,r),b),skA) >      "Registered" + "Check sign Voter"
    Phase 2:
     V -> C: < commit(vote,r), sign(commit(vote,r),ltkA) >                 "Check sign Admin" + "Check commit"
    Phase 3:
     C -> Pub: commit(vote,r)                                              "Check sign Admin"
     V -> C:  r                                                            "Check commit"
     C -> Pub: v                                                           "VotePublished" + "Check r"
  }
*/


// Public key infrastructure

rule Register_Voter_pk:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk(v1, ~ltkV), !Pk(v1, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Voter_pk2:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk(v2, ~ltkV), !Pk(v2, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Admin_pk:
  [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(~ltkA) ]


// Generates votes

rule setup:
  [ Fr(candA), Fr(candB) ]
  --[ Setup() ]->
  [ Vote1( diff(candA, candB) ), Vote2( diff(candB, candA) ) ]


// Rules

rule V_1_1:
  let e = blind( commit( ~vote , ~r ), ~b )
      s = sign ( blind( commit( ~vote , ~r ), ~b ) , ltkV1 )
 
in
    [ Fr( ~r ), Fr( ~b ), Vote1(~vote), !Ltk( v1, ltkV1 )]
  --[ V_1_1( ) ]->
    [ Out( < e , s > ), St_V_1( v1, ~vote, ~r, ~b )]

rule V_1_2:
  let e = blind( commit( ~vote , ~r ), ~b )
      s = sign ( blind( commit( ~vote , ~r ), ~b ) , ltkV2 )
 
in
    [ Fr( ~r ), Fr( ~b ), Vote2(~vote), !Ltk( v2, ltkV2 )]
  --[ V_1_2( ) ]->
    [ Out( < e , s > ), St_V_1( v2, ~vote, ~r, ~b )]


rule V_2:    
  let e = blind(commit(~vote,~r),~b)
      d = sign(blind(commit(~vote,~r),~b),~ltkA)
      y = sign(commit(~vote,~r),~ltkA)
      x = commit(~vote,~r)
  in
    [ In( <e,d> ), St_V_1( V, ~vote, ~r, ~b),  !AdminPk(A, pk(~ltkA)) ]
  --[ V_2( ) ]->     
    [ Out( <x,y> ) , St_V_2( V, A, ~vote, ~r) ]

rule V_3:
  let x1 = commit(~vote1,~r1)
      x2 = commit(~vote2,~r2)
  in
    [ In(x1), St_V_2(v1, A, ~vote1, ~r1), In(x2), St_V_2(v2, A, ~vote2, ~r2)]
  --[ V_3( ) ]->
    [ Out(<~r1,~r2>) ]


axiom uniqueSetup:
  "All #i #j. Setup()@i & Setup()@j ==> #i=#j"


lemma executable_1_1:
  exists-trace
  "Ex #i. V_1_1() @i"

lemma executable_1_2:
  exists-trace
  "Ex #i. V_1_2() @i"

lemma executable_2:
  exists-trace
  "Ex #i. V_2() @i"

lemma executable_3:
  exists-trace
  "Ex #i. V_3() @i"


end

