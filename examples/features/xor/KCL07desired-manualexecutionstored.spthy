theory KCL07desired begin

// Function signature and definition of the equational theory E

builtins: xor
functions: fst/1, h/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2

rule (modulo E) Setup:
   [ Fr( ~k ), Fr( ~id ) ]
  --[ OnlyOnce( ) ]->
   [ !Reader( ~k, ~id ), !Tag( ~k, ~id ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) reader1:
   [ Fr( ~r1 ) ]
  --[ Challenge( ~r1, 'Reader' ) ]->
   [ Out( ~r1 ), Initiated( ~r1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) tag1:
   [ In( r1 ), Fr( ~r2 ), !Tag( ~k, ~id ) ]
  --[ Response( ~k, 'Tag' ) ]->
   [ Out( <(~id⊕~r2), (~r2⊕h(<r1, ~k>))> ) ]

  /*
  rule (modulo AC) tag1:
     [ In( r1 ), Fr( ~r2 ), !Tag( ~k, ~id ) ]
    --[ Response( ~k, 'Tag' ) ]->
     [ Out( <z, (~r2⊕h(<r1, ~k>))> ) ]
    variants (modulo AC)
    1. ~id   = ~id.17
       ~r2   = ~id.17
       z     = zero
    
    2. ~id   = ~id.17
       ~r2   = ~r2.19
       z     = (~id.17⊕~r2.19)
  */

rule (modulo E) reader2:
   [ Initiated( ~r1 ), !Reader( ~k, ~id ), In( <idr2, hashr2> ) ]
  --[ Alive( ~k, 'Tag' ), Eq( (hashr2⊕idr2), (~id⊕h(<~r1, ~k>)) ) ]->
   [ ]

  /*
  rule (modulo AC) reader2:
     [ Initiated( ~r1 ), !Reader( ~k, ~id ), In( <idr2, hashr2> ) ]
    --[ Alive( ~k, 'Tag' ), Eq( z, (~id⊕h(<~r1, ~k>)) ) ]->
     [ ]
    variants (modulo AC)
    1. hashr2
             = hashr2.19
       idr2  = hashr2.19
       z     = zero
    
    2. hashr2
             = hashr2.19
       idr2  = zero
       z     = hashr2.19
    
    3. hashr2
             = hashr2.20
       idr2  = idr2.21
       z     = (hashr2.20⊕idr2.21)
    
    4. hashr2
             = hashr2.22
       idr2  = (hashr2.22⊕z.25)
       z     = z.25
    
    5. hashr2
             = zero
       idr2  = idr2.21
       z     = idr2.21
    
    6. hashr2
             = (idr2.23⊕z.25)
       idr2  = idr2.23
       z     = z.25
    
    7. hashr2
             = (x.218⊕x.219)
       idr2  = (x.219⊕x.220)
       z     = (x.218⊕x.220)
  */

restriction equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction unique:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma recentalive_tag:
  all-traces
  "∀ x #i.
    (Alive( x, 'Tag' ) @ #i) ⇒
    (∃ y #j #k.
      (((Challenge( y, 'Reader' ) @ #k) ∧ (Response( x, 'Tag' ) @ #j)) ∧
       (#k < #j)) ∧
      (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i.
  (Alive( x, 'Tag' ) @ #i)
 ∧
  ∀ y #j #k.
   (Challenge( y, 'Reader' ) @ #k) ∧ (Response( x, 'Tag' ) @ #j)
  ⇒
   ((¬(#k < #j)) ∨ (¬(#j < #i)))"
*/
by sorry

lemma executable:
  exists-trace
  "∃ x #i #j. (Alive( x, 'Tag' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ x #i #j. (Alive( x, 'Tag' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)"
*/
by sorry

lemma executablesimplifiedsearch:
  exists-trace
  "∃ x #i #j.
    ((((Alive( x, 'Tag' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)) ∧
      (∀ y z #k #l.
        ((Alive( y, 'Tag' ) @ #k) ∧ (Alive( z, 'Tag' ) @ #l)) ⇒
        (#k = #l))) ∧
     (∀ y z #k #l.
       ((Challenge( y, 'Reader' ) @ #k) ∧
        (Challenge( z, 'Reader' ) @ #l)) ⇒
       (#k = #l))) ∧
    (∀ y z #k #l.
      ((Response( y, 'Tag' ) @ #k) ∧ (Response( z, 'Tag' ) @ #l)) ⇒
      (#k = #l))"
/*
guarded formula characterizing all satisfying traces:
"∃ x #i #j.
  (Alive( x, 'Tag' ) @ #i) ∧ (Response( x, 'Tag' ) @ #j)
 ∧
  (∀ y z #k #l.
    (Alive( y, 'Tag' ) @ #k) ∧ (Alive( z, 'Tag' ) @ #l) ⇒ #k = #l) ∧
  (∀ y z #k #l.
    (Challenge( y, 'Reader' ) @ #k) ∧ (Challenge( z, 'Reader' ) @ #l)
   ⇒
    #k = #l) ∧
  (∀ y z #k #l.
    (Response( y, 'Tag' ) @ #k) ∧ (Response( z, 'Tag' ) @ #l)
   ⇒
    #k = #l)"
*/
simplify
solve( Initiated( ~r1 ) ▶₀ #i )
  case reader1
  solve( !Reader( ~k, ~id ) ▶₁ #i )
    case Setup
    solve( !Tag( ~k, ~id.1 ) ▶₂ #j )
      case Setup
      solve( splitEqs(1) )
        case split
        solve( splitEqs(0) )
          case split_case_01
          by sorry
        next
          case split_case_02
          by sorry
        next
          case split_case_03
          by sorry
        next
          case split_case_04
          by sorry
        next
          case split_case_05
          by sorry
        next
          case split_case_06
          by sorry
        next
          case split_case_07
          by sorry
        next
          case split_case_08
          by sorry
        next
          case split_case_09
          by sorry
        next
          case split_case_10
          by sorry
        next
          case split_case_11
          by sorry
        next
          case split_case_12
          by sorry
        next
          case split_case_13
          by sorry
        next
          case split_case_14
          by sorry
        next
          case split_case_15
          by sorry
        next
          case split_case_16
          by sorry
        next
          case split_case_17
          by sorry
        next
          case split_case_18
          by sorry
        next
          case split_case_19
          by sorry
        next
          case split_case_20
          by sorry
        next
          case split_case_21
          solve( !KU( (~id⊕x) ) @ #vk.1 )
            case coerce
            solve( !KD( (~id⊕x) ) ▶₀ #vk )
              case tag1
              solve( (#vl, 0) ~~> (#vk, 0) )
                case d_0_fst
                solve( (#vr.2, 0) ~~> (#vk, 0) )
                  case Xor
                  solve( !KU( (~r2⊕h(<~r1, ~k>)) ) @ #vk.2 )
                    case coerce
                    solve( !KD( (~r2⊕h(<~r1, ~k>)) ) ▶₀ #vk.1 )
                      case tag1
                      solve( (#vl, 0) ~~> (#vk.1, 0) )
                        case d_0_snd
                        solve( (#vr.3, 0) ~~> (#vk.1, 0) )
                          case Xor
                          solve( !KU( ~r1 ) @ #vk.3 )
                            case reader1
                            SOLVED // trace found
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        next
          case split_case_22
          by sorry
        next
          case split_case_23
          by sorry
        next
          case split_case_24
          by sorry
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end