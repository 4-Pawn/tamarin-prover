theory EAP_AKA_SQN_Failure_Handling_f5star begin

/* EAP-AKA protocol modeled after RFC 4187 and ETSI TS 133 102 V5.1.0 (2002-12)

  There are slight differences between the descriptions of RFC 4187 and the ETSI description.
  I have used the ETSI specification. 

  Peer: P (Client), has an ID known to server, 
          shares a secret key K with server and is synch'ed with server 
          wrt sequence number SQN (within a certain range, 
          re-synch is possible)
  Authenticator: A (Server)

SQN:  freshly generated by A in the protocol (next number in sequence)
RAND: freshly generated by A in the protocol (random number)
AMF: authentication and key management field, modeled as a public constant, '0'.

CK  = f3(K,RAND)   Cipher key    // to be used after the authentication protocol
IK  = f4(K,RAND)   Integrity key // to be used after the authentication protocol
AK  = f5(K,RAND)   Anonymity key, could be zero

AV = <RAND, XRES, CK, IK, AUTN>  Authentication vector

f1, f2 are message auth functions (HMAC keyed with K)
f3, f4, f5 are key generating functions, f5 could be zero (but is not in practice)

The following is one possible flow:

                              A: knows(ID, K, SQN)
                              P: knows(ID, K, SQN)
(EAP-Request/Identity)        A -> P: ID_REQ  // We'll simply send A
(EAP-Response/Identity)       P -> A: ID
                              A: fresh(RAND, SQN')
			      A: let MAC = f1(K,<SQN',RAND,AMF>)  
			      A: let AK  = f5(K,RAND)   
                              A: let AUTN = <SQN' xor AK , <AMF , MAC>>
(EAP-Request/AKA-Challenge)   A -> P: RAND, AUTN
			      P: let SQN'' = fst(AUTN) xor f5(K,RAND)
                              P: verify f1(K, <SQN'',RAND,AMF>) =?= snd(snd(AUTN))
                         fail-P: if the previous verification fails, send mac_failure
			      P: verify SQN'' is in expected range (i.e., == SQN [or in a range])
			 fail-P: if mac 3 above succeeds, but SQN'' is NOT as expected, send sync-failure and AUTS
			 fail-P: let MAC* = f1(<SQN,AMF,RAND>,K)
			 fail-P: let CONC* = SQN xor f5*(RAND,K)
			 fail-P: let AUTS = <CONC*,MAC*>
			      P: let RES = f2(K, RAND)
(EAP-Response/AKA-Challenge)  P -> A: RES
			 fail-P -> A: AUTS
                              A: verify RES 
(EAP-Success)                 A -> P: success

 */

/*
This version uses multisets to represent numbers, starting from a fresh value as initial sequence number. Otherwise the adversary trivially violates the weak secrecy property for the sequence number, because it will be 0,1,2,etc. which are of course known. Moroever, this modeling is in line with a threat model where the attacker is not MiM *all* sessions of peers since their first use. Therefore, the attacker cannot keep track of SQN.

We use a sources lemma based on the secrecy of the anonymity key to get rid of partial deconstructions created from the sequence numbers.
*/

/* Extended with:
- the mac_failure message in case the mac received by client is not correct.
- the sync_failure message in case the mac received by client is correct while the sequence number is wrong; this includes the re-synchronization term AUTS (and an additional annotation about the secrecy of the anonymity key to remove partial deconstructions)
*/

builtins: xor,multiset
functions: f1/2, f2/2, f5/2, f5star/2

rule Setup:
   [ Fr( ~k )
   , Fr(~id)
   , Fr(~sqn)
   ]
 --[ InitialSqn(~id, ~sqn), Sub() ]-> 
   [ !Client( ~id, $A, ~k, ~sqn), SQN_C(~id,~sqn+'1')        // the +1 are needed as otherwise a pattern-match on ~sqn+x will fail initially! 
   , !Server( ~id, $A, ~k, ~sqn), SQN_S(~id,~sqn+'1' + '1')  // Server is in advance compared to client
   ]

/* Skipping the following rule for simplicity 
rule Server_0: 
   [ !Server( ~id, $A, ~k, ~initsqn) ]
 --[]->
   [ Out($A)
   , Server_0(~id,$A)
   ]
*/

rule Client_0: 
   [ !Client( ~id, $A, ~k, ~initsqn)
   , In($A) 
   ]
 --[ Cl() ]->
   [ Out(~id) 
   , Client_0(~id,$A)
   ]

rule Server_1: 
   let amf  = '0'
       sqn  = ~initsqn + x
       sqn1 = sqn + '1'
       mac  = f1(~k,<sqn,~rand,amf>)
       ak   = f5(~k,~rand)
       autn = <sqn XOR ak, <amf, mac>>
   in
   [ !Server( ~id, $A, ~k, ~initsqn)
//   , Server_0(~id,$A)
   , In(~id)
   , Fr(~rand)
   , SQN_S(~id,sqn)
   ]
 --[ Sr()
   , RunningS(~id,$A,~k,~rand) 
   , SecretAK(ak)
   ]->
   [ Out(<~rand,autn>) 
   , SQN_S(~id,sqn1)
   , Server_1(~id,sqn1,~rand)
   ]

rule Client_1_success:
   let amf  = fst(snd(autn))
       sqnS = fst(autn) XOR f5(~k,rand)
       sqn2 = sqnS + '1'
       xmac = f1(~k, <sqnS,rand,amf>)
       res  = f2(~k,rand)
       mac  = snd(snd(autn))
   in
   [ !Client(~id, $A, ~k, ~initsqn)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   ]
 --[ Eq(mac,xmac)
   , Eq(sqn + '1',sqnS) 
   , RunningC(~id,$A,~k,rand)
   , CommitC(~id,$A,~k,rand)
   , SecretC(sqn2)
   ]->
   [ SQN_C(~id,sqn2)
   , Out(res)
   ]

rule Client_1_macfailure:
   let amf  = fst(snd(autn))
       sqnS = fst(autn) XOR f5(~k,rand)
       xmac = f1(~k, <sqnS,rand,amf>)
       mac  = snd(snd(autn))
   in
   [ !Client(~id, $A, ~k, ~initsqn)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   ]
 --[ InEq(mac,xmac)
   , MacFailure()
   ]->
   [ SQN_C(~id,sqn) // sqn does NOT change in this case
   , Out('macfailure')
   ]

rule Client_1_syncfailure:
   let sqn  = ~initsqn + x
       amf  = fst(snd(autn))
       sqnS = fst(autn) XOR f5(~k,rand)
       xmac = f1(~k, <sqnS,rand,amf>)
       mac  = snd(snd(autn))
       macstar  = f1(~k, <sqn,rand,amf>)
       akstar   = f5star(~k, rand)  // this is the version using f5star =/= f5
       concstar = sqn XOR akstar
       auts     = <'syncfailure',concstar, macstar>
   in
   [ !Client(~id, $A, ~k, ~initsqn)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   ]
 --[ Eq(mac,xmac)
   , InEq(sqn + '1',sqnS) // we check exact match of sequence number, mismatch handled in this rule
   , SyncFailure()
   , SecretC(sqn)
   , SecretDiff(sqn XOR sqnS)   // this value should not be knwon by the attacker (induce critial privacy attacks)
   , SecretDiff2(sqn XOR (sqn+'1'))   // this value should not be knwon by the attacker (induce critial privacy attacks)
   , SecretAK(akstar)
   ]->
   [ SQN_C(~id,sqn) // sequence number does NOT change in this case
   , Out(auts)
   ]

rule Server_2:
   [ !Server(~id,$A,~k,~initsqn)
   , Server_1(~id,sqn1,~rand)
   , In(res) 
   ]
 --[ Eq(res,f2(~k,~rand))
   , CommitS(~id,$A,~k,~rand)
   , Success()
   , SecretS(sqn1) ]->
   [   ]

/************************************/
/*        RESTRICTIONS              */
/************************************/
#ifdef smallTraces  // carefull, if this block is enabled then Tamarin will not explore a large class of executions. Use it ONLY for proving existential lemmas.
restriction smallTraces:
  " (All #j #k. Sub()@j & Sub()@k ==> (#j=#k)) &  // max 1 subscriber
    (All #j #k #l #m. Cl()@j & Cl()@k & Cl()@l & Cl()@m==> (#j = #k | #j = #l | #j = #m | #k = #l | #k = #m | #m = #l)) &  // max 4 clients sessions
    (All #j #k #l. Sr()@j & Sr()@k & Sr()@l ==> (#j = #k | #j = #l | #k = #l ))   // max 2 server sessions
  "
#endif

restriction equality:
  "All x y #i. (Eq( x, y ) @ #i) ==> (x = y)"

restriction inequality:
  "All x #i. (InEq( x, x ) @ #i) ==> F"


/************************************/
/*        LEMMAS                    */
/************************************/
// Sources lemma to ensure no anonymity key is known to the adversary, therefore removing all partial deconstructions
//Auto-proof -- 2017-06-19
lemma aksecret [sources]:
  "All ak #i. SecretAK(ak)@i ==> not (Ex #k. KU(ak) @k)"

// SHOWS CORRECT EXECUTION 
// Auto-proof - about 2-3 minutes 2017-06-19
lemma executable:
  exists-trace "Ex #i. Success()@i"

// SHOWS CORRECT EXECUTION, slightly smaller trace
// Auto-proof - quick 2017-06-19
lemma executable2:
  exists-trace "Ex #i. Success()@i & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k) & (All #j #k. Sub()@j & Sub()@k ==> (#j=#k)) "

// SHOWS CORRECT EXECUTION 
// Auto-proof - quick 2017-06-19
lemma executable_macfailure:
  exists-trace "Ex #i. MacFailure()@i & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k) & (All #j #k. Sub()@j & Sub()@k ==> (#j=#k)) "

//lemma executable_syncfailure:
//  exists-trace "Ex #i. SyncFailure()@i"// & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k) & (All #j #k. Sub()@j & Sub()@k ==> (#j=#k)) "

// HOLDS, AUTOMATICALLY finds solution (2017-06-19), takes a few minutes though
lemma executable_syncfailure2:
  exists-trace "Ex #i. SyncFailure()@i & (All #j #k #l. Cl()@j & Cl()@k & Cl()@l ==> (#j=#k | #j = #l | #k = #l)) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k) & (All #j #k. Sub()@j & Sub()@k ==> (#j=#k)) "

// HOLDS, quick auto-proof 2017-06-19
lemma agreeS:
  "All id A k rand #i. CommitS(id,A,k,rand)@i ==> Ex #j. RunningC(id,A,k,rand) @j"

// no quick auto-proof - not sure what happens
// XXXX ?
// lemma agreeC:
//  "All id A k rand #i. CommitC(id,A,k,rand)@i ==> Ex #j. RunningS(id,A,k,rand) @j"

// HOLDS, quick proof 2017-06-19
lemma secretsqnC:
  "All sqn #i. SecretC(sqn) @i ==> not (Ex #j. K(sqn)@j)"

// HOLDS, quick proof 2017-06-19
lemma secretsqnS:
  "All sqn #i. SecretS(sqn) @i ==> not (Ex #j. K(sqn)@j)"

// DID NOT TRY TO RUN THIS, see below for the limited version that takes a long time already.
// ???
lemma secretsqndiff:
  "All sqn #i. SecretDiff(sqn) @i ==> not (Ex #j. K(sqn)@j)"

// Try to find attack under added restrictions of only one server and two client steps -- actually proven secure!
// Proven automatically after about 30 minutes CPU time using 5GB of RAM (so, 10-15 minutes wall clock) 2017-06-19
lemma secretsqndifflimited:
" (
   (All #j #k #l. Cl()@j & Cl()@k & Cl()@l ==> (#j=#k | #j = #l | #k = #l))
 & (All #j #k. Sr()@j & Sr()@k ==> #j=#k)
  )
==> (All sqn #i. SecretDiff(sqn) @i ==> not (Ex #j. K(sqn)@j))"

// This one captures our AUTS-based attacks that work even if f5 =/= f5star
// ???
lemma secretsqndiff2:
  "All sqn #i. SecretDiff2(sqn) @i ==> not (Ex #j. K(sqn)@j)"

end
