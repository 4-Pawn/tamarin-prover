theory CR
begin

/*
A&B:
A->B: na
B->A: <h(na, k,nb), nb>
achieves recent aliveness

A->B: na
B->A: <h(na ⊕ k ⊕ nb), nb>
should find attack:
- after watching one run and storing data
- uses nb'=na+nb+na'
 ((( na'+k+nb'= na'+k + na +nb+na' = k + na + nb )))
*/

builtins: hashing

rule Setup:
  [ Fr(~k) ]
--[ OnlyOnce() ]->
  [ !InitLTK(~k), !RespLTK(~k) ]

rule initiator:
  [ Fr(~na) ]
--[ Challenge(~na) ]->
  [ Out(~na), Initiated(~na) ]

rule responder:
  [ In(na), Fr(~nb), !RespLTK(~k) ]
--[ Response(na)]->
  [Out(<h(na,~k,~nb), ~nb>) ]

rule initiator2:
  [ Initiated(~na), !InitLTK(~k), In(<m,nb>) ]
--[ Alive(~na) , Eq(h(~na,~k,nb),m) ]->
  []

restriction equality:
  "All x y #i. Eq(x,y)@i ==> x=y"

restriction unique:
  "All #i #j. OnlyOnce() @i & OnlyOnce() @j ==> #i = #j"

// FINDS PROOF AUTOMATICALLY (2017-03-22)
lemma recentalive:
  "All x #i. Alive(x) @i ==> Ex #j. Response(x)@j"
  
// SHOWS CORRECT EXECUTION (2017-03-22)
lemma executable:
  exists-trace
  "Ex x #i #j. Alive(x)@i & Response(x)@j"

end
