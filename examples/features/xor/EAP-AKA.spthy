theory EAP_AKA begin

/* EAP-AKA protocol modeled after RFC 4187 and ETSI TS 133 102 V5.1.0 (2002-12)

  There are slight differences between the descriptions of RFC 4187 and the ETSI description.
  I have used the ETSI specification. 

  Peer: P (Client), has an ID known to server, 
          shares a secret key K with server and is synch'ed with server 
          wrt sequence number SQN (within a certain range, 
          re-synch is possible)
  Authenticator: A (Server)

SQN:  freshly generated by A in the protocol (next number in sequence)
RAND: freshly generated by A in the protocol (random number)
AMF: authentication and key management field, modeled as a public constant, '0'.

CK  = f3(K,RAND)   Cipher key    // to be used after the authentication protocol
IK  = f4(K,RAND)   Integrity key // to be used after the authentication protocol
AK  = f5(K,RAND)   Anonymity key, could be zero

AV = <RAND, XRES, CK, IK, AUTN>  Authentication vector

f1, f2 are message auth functions (HMAC keyed with K)
f3, f4, f5 are key generating functions, f5 could be zero

The following is one possible flow:

                              A: knows(ID, K, SQN)
                              P: knows(ID, K, SQN)
(EAP-Request/Identity)        A -> P: ID_REQ  // We'll simply send A
(EAP-Response/Identity)       P -> A: ID
                              A: fresh(RAND, SQN')
			      A: let MAC = f1(K,<SQN',RAND,AMF>)  
			      A: let AK  = f5(K,RAND)   
                              A: let AUTN = <SQN' xor AK , <AMF , MAC>>
(EAP-Request/AKA-Challenge)   A -> P: RAND, AUTN
			      P: let SQN'' = fst(AUTN) xor f5(K,RAND)
                              P: verify f1(K, <SQN'',RAND,AMF>) =?= snd(snd(AUTN))
			      P: verify SQN'' is in expected range
			      P: let RES = f2(K, RAND)
(EAP-Response/AKA-Challenge)  P -> A: RES
                              A: verify RES 
(EAP-Success)                 A -> P: success

 */

builtins: xor
functions: f1/2, f2/2, f5/2, next/1

rule Setup:
   let sqn = '0' in 
   [ Fr( ~k )
   , Fr(~id) 
   ]
 --[ ]-> 
   [ !Client( ~id, $A, ~k), SQN_C(~id,sqn)
   , !Server( ~id, $A, ~k), SQN_S(~id,sqn) 
   ]

/* Skipping the following rule for simplicity 
rule Server_0: 
   [ !Server( ~id, $A, ~k) ]
 --[]->
   [ Out($A)
   , Server_0(~id,$A)
   ]
*/

rule Client_0: 
   [ !Client( ~id, $A, ~k)
   , In($A) 
   ]
 --[ Cl() ]->
   [ Out(~id) 
   , Client_0(~id,$A)
   ]

rule Server_1: 
   let amf  = '0'
       sqn1 = next(sqn)
       mac  = f1(~k,<sqn1,~rand,amf>)
       ak   = f5(~k,~rand)
       autn = <sqn1 XOR ak, <amf, mac>>
   in
   [ !Server( ~id, $A, ~k)
//   , Server_0(~id,$A)
   , In(~id)
   , Fr(~rand)
   , SQN_S(~id,sqn)
   ]
 --[ Sr() ]->
   [ Out(<~rand,autn>) 
   , SQN_S(~id,sqn1)
   , Server_1(~id,sqn1,~rand)
   ]

rule Client_1:
   let amf  = fst(snd(autn))
       sqn2 = fst(autn) XOR f5(~k,rand)
       xmac = f1(~k, <sqn2,rand,amf>)
       res  = f2(~k,rand)
       mac  = snd(snd(autn))
   in
   [ !Client(~id, $A, ~k)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   ]
 --[ Eq(mac,xmac)
   , Eq(next(sqn),sqn2) 
   ]->
   [ SQN_C(~id,sqn2)
   , Out(res)
   ]

rule Server_2:
   [ !Server(~id,$A,~k)
   , Server_1(~id,sqn1,~rand)
   , In(res) 
   ]
 --[ Eq(res,f2(~k,~rand))
   , Success() ]->
   [   ]

restriction equality:
  "All x y #i. (Eq( x, y ) @ #i) ==> (x = y)"

// SHOWS CORRECT EXECUTION 
lemma executable:
  exists-trace "Ex #i. Success()@i"

// SHOWS CORRECT EXECUTION, slightly smaller trace 
lemma executable2:
  exists-trace "Ex #i. Success()@i & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k)"


end
