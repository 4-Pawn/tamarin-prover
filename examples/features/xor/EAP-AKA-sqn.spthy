theory EAP_AKA_SQN begin

/* EAP-AKA protocol modeled after RFC 4187 and ETSI TS 133 102 V5.1.0 (2002-12)

  There are slight differences between the descriptions of RFC 4187 and the ETSI description.
  I have used the ETSI specification. 

  Peer: P (Client), has an ID known to server, 
          shares a secret key K with server and is synch'ed with server 
          wrt sequence number SQN (within a certain range, 
          re-synch is possible)
  Authenticator: A (Server)

SQN:  freshly generated by A in the protocol (next number in sequence)
RAND: freshly generated by A in the protocol (random number)
AMF: authentication and key management field, modeled as a public constant, '0'.

CK  = f3(K,RAND)   Cipher key    // to be used after the authentication protocol
IK  = f4(K,RAND)   Integrity key // to be used after the authentication protocol
AK  = f5(K,RAND)   Anonymity key, could be zero

AV = <RAND, XRES, CK, IK, AUTN>  Authentication vector

f1, f2 are message auth functions (HMAC keyed with K)
f3, f4, f5 are key generating functions, f5 could be zero

The following is one possible flow:

                              A: knows(ID, K, SQN)
                              P: knows(ID, K, SQN)
(EAP-Request/Identity)        A -> P: ID_REQ  // We'll simply send A
(EAP-Response/Identity)       P -> A: ID
                              A: fresh(RAND, SQN')
			      A: let MAC = f1(K,<SQN',RAND,AMF>)  
			      A: let AK  = f5(K,RAND)   
                              A: let AUTN = <SQN' xor AK , <AMF , MAC>>
(EAP-Request/AKA-Challenge)   A -> P: RAND, AUTN
			      P: let SQN'' = fst(AUTN) xor f5(K,RAND)
                              P: verify f1(K, <SQN'',RAND,AMF>) =?= snd(snd(AUTN))
			      P: verify SQN'' is in expected range
			      P: let RES = f2(K, RAND)
(EAP-Response/AKA-Challenge)  P -> A: RES
                              A: verify RES 
(EAP-Success)                 A -> P: success

 */

/*
This version uses multisets to represent numbers, starting from a fresh value as initial sequence number. Otherwise the adversary trivially violates the weak secrecy property for the sequence number, because it will be 0,1,2,etc. which are of course known. Moroever, this modeling is in line with a threat model where the attacker is not MiM *all* sessions of peers since their first use. Therefore, the attacker cannot, a priori, keep track of SQN.

We use a sources lemma based on the secrecy of the anonymity key to get rid of partial deconstructions created from the sequence numbers.
*/

builtins: xor,multiset
functions: f1/2, f2/2, f5/2

rule Setup:
   [ Fr( ~k )
   , Fr(~id)
   , Fr(~sqn)
   ]
 --[ InitialSqn(~id, ~sqn), Sub() ]->
   [ !Client( ~id, $A, ~k, ~sqn), SQN_C(~id,~sqn+'1')        // the +1 are needed as otherwise a pattern-match on ~sqn+x will fail initially!
   , !Server( ~id, $A, ~k, ~sqn), SQN_S(~id,~sqn+'1' + '1')  // Server is in advance compared to client
   ]

/* Skipping the following rule for simplicity 
rule Server_0: 
   [ !Server( ~id, $A, ~k, ~initsqn) ]
 --[]->
   [ Out($A)
   , Server_0(~id,$A)
   ]
*/

rule Client_0: 
   [ !Client( ~id, $A, ~k, ~initsqn)
   , In($A) 
   ]
 --[ Cl() ]->
   [ Out(~id) 
   , Client_0(~id,$A)
   ]

rule Server_1: 
   let amf  = '0'
       sqn  = ~initsqn + x
       sqn1 = sqn + '1'
       mac  = f1(~k,<sqn,~rand,amf>)
       ak   = f5(~k,~rand)
       autn = <sqn XOR ak, <amf, mac>>
   in
   [ !Server( ~id, $A, ~k, ~initsqn)
//   , Server_0(~id,$A)
   , In(~id)
   , Fr(~rand)
   , SQN_S(~id,sqn)
   ]
 --[ Sr()
   , RunningS(~id,$A,~k,~rand) 
   , SecretAK(ak)
   ]->
   [ Out(<~rand,autn>) 
   , SQN_S(~id,sqn1)
   , Server_1(~id,sqn1,~rand)
   ]

rule Client_1:
   let amf  = fst(snd(autn))
       sqnS = fst(autn) XOR f5(~k,rand)
       sqn2 = sqnS + '1'
       xmac = f1(~k, <sqnS,rand,amf>)
       res  = f2(~k,rand)
       mac  = snd(snd(autn))
   in
   [ !Client(~id, $A, ~k, ~initsqn)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   ]
 --[ Eq(mac,xmac)
   , Eq(sqn + '1',sqnS) 
   , RunningC(~id,$A,~k,rand)
   , CommitC(~id,$A,~k,rand)
   , SecretC(sqn2)
   ]->
   [ SQN_C(~id,sqn2)
   , Out(res)
   ]

rule Server_2:
   [ !Server(~id,$A,~k,~initsqn)
   , Server_1(~id,sqn1,~rand)
   , In(res) 
   ]
 --[ Eq(res,f2(~k,~rand))
   , CommitS(~id,$A,~k,~rand)
   , Success()
   , SecretS(sqn1) ]->
   [   ]

restriction equality:
  "All x y #i. (Eq( x, y ) @ #i) ==> (x = y)"

// automatically proved 2017-06-19
lemma aksecret [sources]:
  "All ak #i. SecretAK(ak)@i ==> not (Ex #k. KU(ak) @k)"

// SHOWS CORRECT EXECUTION 
lemma executable:
  exists-trace "Ex #i. Success()@i"

// SHOWS CORRECT EXECUTION, slightly smaller trace 
lemma executable2:
  exists-trace "Ex #i. Success()@i & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k)"

lemma agreeS:
  "All id A k rand #i. CommitS(id,A,k,rand)@i ==> Ex #j. RunningC(id,A,k,rand) @j"

lemma agreeC:
  "All id A k rand #i. CommitC(id,A,k,rand)@i ==> Ex #j. RunningS(id,A,k,rand) @j"

lemma secretsqnC:
  "All sqn #i. SecretC(sqn) @i ==> not (Ex #j. K(sqn)@j)"

lemma secretsqnS:
  "All sqn #i. SecretS(sqn) @i ==> not (Ex #j. K(sqn)@j)"

end
