theory CRXOR begin

// Function signature and definition of the equational theory E

builtins: xor
functions: fst/1, h/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2

rule (modulo E) Setup:
   [ Fr( ~k ) ] --[ OnlyOnce( ) ]-> [ !InitLTK( ~k ), !RespLTK( ~k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) initiator:
   [ Fr( ~na ) ]
  --[ Challenge( ~na ) ]->
   [ Out( ~na ), Initiated( ~na ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) responder:
   [ In( na ), Fr( ~nb ), !RespLTK( ~k ) ]
  --[ Response( na ) ]->
   [ Out( <h((~k⊕~nb⊕na)), ~nb> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) initiator2:
   [ Initiated( ~na ), !InitLTK( ~k ), In( <m, nb> ) ]
  --[ Alive( ~na ), Eq( h((~k⊕~na⊕nb)), m ) ]->
   [ ]

  /* has exactly the trivial AC variant */

restriction equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction unique:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma recentalive:
  all-traces "∀ x #i. (Alive( x ) @ #i) ⇒ (∃ #j. Response( x ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (Alive( x ) @ #i) ∧ ∀ #j. (Response( x ) @ #j) ⇒ ⊥"
*/
simplify
solve( Initiated( ~na ) ▶₀ #i )
  case initiator
  solve( !InitLTK( ~k ) ▶₁ #i )
    case Setup
    solve( !KU( h((~k⊕~na⊕nb)) ) @ #vk.1 )
      case c_h
      by sorry
    next
      case responder_case_1
      by sorry
    next
      case responder_case_2
      by contradiction /* from formulas */
    next
      case responder_case_3
      by sorry
    next
      case responder_case_4
      solve( !KU( (~na⊕x) ) @ #vk.3 )
        case c_xor_case_1
        solve( !KU( ~na ) @ #vk.5 )
          case initiator
          solve( !KU( (~nb⊕x) ) @ #vk.4 )
            case c_xor_case_1
            solve( !KU( ~nb ) @ #vk.6 )
              case responder
              SOLVED // trace found
            qed
          next
            case c_xor_case_2
            by sorry
          next
            case c_xor_case_3
            by sorry
          next
            case c_xor_case_4
            by sorry
          next
            case coerce
            by sorry
          qed
        qed
      next
        case c_xor_case_2
        by sorry
      next
        case c_xor_case_3
        by sorry
      next
        case c_xor_case_4
        by sorry
      next
        case coerce
        by sorry
      qed
    qed
  qed
qed

lemma executable:
  exists-trace "∃ x #i #j. (Alive( x ) @ #i) ∧ (Response( x ) @ #j)"
/*
guarded formula characterizing all satisfying traces:
"∃ x #i #j. (Alive( x ) @ #i) ∧ (Response( x ) @ #j)"
*/
by sorry

/* All well-formedness checks were successful. */

end