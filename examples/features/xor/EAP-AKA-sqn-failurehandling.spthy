theory EAP_AKA_SQN_Failure_Handling begin

/* EAP-AKA protocol modeled after RFC 4187 and ETSI TS 133 102 V5.1.0 (2002-12)

  There are slight differences between the descriptions of RFC 4187 and the ETSI description.
  I have used the ETSI specification. 

  Peer: P (Client), has an ID known to server, 
          shares a secret key K with server and is synch'ed with server 
          wrt sequence number SQN (within a certain range, 
          re-synch is possible)
  Authenticator: A (Server)

SQN:  freshly generated by A in the protocol (next number in sequence)
RAND: freshly generated by A in the protocol (random number)
AMF: authentication and key management field, modeled as a public constant, '0'.

CK  = f3(K,RAND)   Cipher key    // to be used after the authentication protocol
IK  = f4(K,RAND)   Integrity key // to be used after the authentication protocol
AK  = f5(K,RAND)   Anonymity key, could be zero

AV = <RAND, XRES, CK, IK, AUTN>  Authentication vector

f1, f2 are message auth functions (HMAC keyed with K)
f3, f4, f5 are key generating functions, f5 could be zero

The following is one possible flow:

                              A: knows(ID, K, SQN)
                              P: knows(ID, K, SQN)
(EAP-Request/Identity)        A -> P: ID_REQ  // We'll simply send A
(EAP-Response/Identity)       P -> A: ID
                              A: fresh(RAND, SQN')
			      A: let MAC = f1(K,<SQN',RAND,AMF>)  
			      A: let AK  = f5(K,RAND)   
                              A: let AUTN = <SQN' xor AK , <AMF , MAC>>
(EAP-Request/AKA-Challenge)   A -> P: RAND, AUTN
			      P: let SQN'' = fst(AUTN) xor f5(K,RAND)
                              P: verify f1(K, <SQN'',RAND,AMF>) =?= snd(snd(AUTN))
                         fail-P: if the previous verification fails, send mac_failure
			      P: verify SQN'' is in expected range (i.e., == SQN [or in a range])
			 fail-P: if mac 3 above succeeds, but SQN'' is NOT as expected, send sync-failure and AUTS
			 fail-P: let MAC* = f1(<SQN,AMF,RAND>,K)
			 fail-P: let CONC* = SQN xor f5*(RAND,K)
			 fail-P: let AUTS = <CONC*,MAC*>
			      P: let RES = f2(K, RAND)
(EAP-Response/AKA-Challenge)  P -> A: RES
			 fail-P -> A: AUTS
                              A: verify RES 
(EAP-Success)                 A -> P: success

 */

/*
This version uses multisets to represent numbers, starting from a fresh value as initial sequence number. Otherwise the adversary trivially violates the weak secrecy property for the sequence number, because it will be 0,1,2,etc. which are of course known.

To remove partial deconstructions, the adversary is the one providing the delta of '1'+'1'+'1'+... to the starting value, which is not ideal, but works for now.
*/

/* Extended with:
- the mac_failure message in case the mac received by client is not correct.
- the sync_failure message in case the mac received by client is correct, but the sequence number is wrong; this includes the re-synchronization term AUTS
*/

builtins: xor,multiset
functions: f1/2, f2/2, f5/2

rule Setup:
   [ Fr( ~k )
   , Fr(~id)
   , Fr(~sqn)
   ]
 --[ InitialSqn(~id, ~sqn) ]-> 
   [ !Client( ~id, $A, ~k, ~sqn), SQN_C(~id,~sqn+'1')
   , !Server( ~id, $A, ~k, ~sqn), SQN_S(~id,~sqn+'1') // the +1 are needed as otherwise a pattern-match on ~sqn+x will fail initially! 
   ]

/* Skipping the following rule for simplicity 
rule Server_0: 
   [ !Server( ~id, $A, ~k, ~initsqn) ]
 --[]->
   [ Out($A)
   , Server_0(~id,$A)
   ]
*/

rule Client_0: 
   [ !Client( ~id, $A, ~k, ~initsqn)
   , In($A) 
   ]
 --[ Cl() ]->
   [ Out(~id) 
   , Client_0(~id,$A)
   ]

rule Server_1: 
   let amf  = '0'
       sqn  = ~initsqn + x
       sqn1 = sqn + '1'
       mac  = f1(~k,<sqn1,~rand,amf>)
       ak   = f5(~k,~rand)
       autn = <sqn1 XOR ak, <amf, mac>>
   in
   [ !Server( ~id, $A, ~k, ~initsqn)
//   , Server_0(~id,$A)
   , In(~id)
   , Fr(~rand)
   , SQN_S(~id,sqn)
   , In(x) // try and replace this by sources lemma as in EAP-AKA-sqn.spthy
   ]
 --[ Sr()
   , RunningS(~id,$A,~k,~rand) 
   , SqnRelationS(~id, sqn, ~initsqn)
   ]->
   [ Out(<~rand,autn>) 
   , SQN_S(~id,sqn1)
   , Server_1(~id,sqn1,~rand)
   ]

rule Client_1_success:
   let amf  = fst(snd(autn))
       sqn2 = fst(autn) XOR f5(~k,rand)
       xmac = f1(~k, <sqn2,rand,amf>)
       res  = f2(~k,rand)
       mac  = snd(snd(autn))
   in
   [ !Client(~id, $A, ~k, ~initsqn)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   ]
 --[ Eq(mac,xmac)
   , Eq(sqn + '1',sqn2) 
   , RunningC(~id,$A,~k,rand)
   , CommitC(~id,$A,~k,rand)
   , SecretC(sqn2)
   , SqnRelationC(~id, sqn2, ~initsqn)
   ]->
   [ SQN_C(~id,sqn2)
   , Out(res)
   ]

rule Client_1_macfailure:
   let amf  = fst(snd(autn))
       sqn2 = fst(autn) XOR f5(~k,rand)
       xmac = f1(~k, <sqn2,rand,amf>)
//       res  = f2(~k,rand)
       mac  = snd(snd(autn))
   in
   [ !Client(~id, $A, ~k, ~initsqn)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   ]
 --[ InEq(mac,xmac)
   , MacFailure()
//   , Eq(sqn + '1',sqn2) 
//   , RunningC(~id,$A,~k,rand)
//   , CommitC(~id,$A,~k,rand)
//   , SecretC(sqn2)
//   , SqnRelationC(~id, sqn2, ~initsqn)
   ]->
   [ // SQN_C(~id,sqn2)
     SQN_C(~id,sqn) // sqn does NOT change in this case
   , Out('macfailure')
   ]

rule Client_1_syncfailure:
   let sqn  = ~initsqn + x
       amf  = fst(snd(autn))
       sqn2 = fst(autn) XOR f5(~k,rand)
       xmac = f1(~k, <sqn2,rand,amf>)
//       res  = f2(~k,rand)
       mac  = snd(snd(autn))
       macstar  = f1(~k, <sqn +'1',rand,amf>)
       akstar   = f5(~k, rand)  // this is the naive version, need to change to "f5*" function!
       concstar = (sqn+'1') XOR akstar
       auts     = <'syncfailure',concstar, macstar>
   in
   [ !Client(~id, $A, ~k, ~initsqn)
   , Client_0(~id,$A)
   , SQN_C(~id,sqn)
   , In(<rand,autn>)
   , In(x) // can we remove this by sources lemma, similar to above and EAP-AKA-sqn.spthy?
   ]
 --[ Eq(mac,xmac)
   , InEq(sqn + '1',sqn2) // we check exact match of sequence number, mismatch handled in this rule
   , SyncFailure()
//   , RunningC(~id,$A,~k,rand)
//   , CommitC(~id,$A,~k,rand)
   , SecretC(sqn)
   , SecretDiff(sqn +'1' XOR sqn2)
   , SqnRelationC(~id, sqn, ~initsqn)
   ]->
   [ //SQN_C(~id,sqn2)
     SQN_C(~id,sqn) // sequence number does NOT change in this case
   , Out(auts)
   ]

rule Server_2:
   [ !Server(~id,$A,~k,~initsqn)
   , Server_1(~id,sqn1,~rand)
   , In(res) 
   ]
 --[ Eq(res,f2(~k,~rand))
   , CommitS(~id,$A,~k,~rand)
   , Success()
   , SecretS(sqn1) ]->
   [   ]

restriction equality:
  "All x y #i. (Eq( x, y ) @ #i) ==> (x = y)"

restriction inequality:
  "All x #i. (InEq( x, x ) @ #i) ==> F"

// SHOWS CORRECT EXECUTION 
lemma executable:
  exists-trace "Ex #i. Success()@i"

// SHOWS CORRECT EXECUTION, slightly smaller trace 
lemma executable2:
  exists-trace "Ex #i. Success()@i & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k)"

lemma executable_macfailure:
  exists-trace "Ex #i. MacFailure()@i & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k)"

//lemma executable_syncfailure:
//  exists-trace "Ex #i. SyncFailure()@i"// & (All #j #k. Cl()@j & Cl()@k ==> #j=#k) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k)"

// HOLDS, AUTOMATICALLY finds solution (2017-06-17), takes a few minutes though
lemma executable_syncfailure2:
  exists-trace "Ex #i. SyncFailure()@i & (All #j #k #l. Cl()@j & Cl()@k & Cl()@l ==> (#j=#k | #j = #l | #k = #l)) & (All #j #k. Sr()@j & Sr()@k ==> #j=#k)"

lemma agreeS:
  "All id A k rand #i. CommitS(id,A,k,rand)@i ==> Ex #j. RunningC(id,A,k,rand) @j"

lemma agreeC:
  "All id A k rand #i. CommitC(id,A,k,rand)@i ==> Ex #j. RunningS(id,A,k,rand) @j"

//lemma sqnrelationS [sources]:
//  "All id sqn initsqn #i . SqnRelationS(id, sqn, initsqn) @i ==> (Ex #j. InitialSqn(id, initsqn) @j) & (Ex x. sqn = initsqn + x)"

//lemma sqnrelationC [sources]:
//  "All id sqn initsqn #i . SqnRelationC(id, sqn, initsqn) @i ==> (Ex #j. InitialSqn(id, initsqn) @j) & (Ex x. sqn = initsqn + x)"

lemma secretsqnC:
  "All sqn #i. SecretC(sqn) @i ==> not (Ex #j. K(sqn)@j)"

lemma secretsqnS:
  "All sqn #i. SecretS(sqn) @i ==> not (Ex #j. K(sqn)@j)"

lemma secretsqndiff:
  "All sqn #i. SecretDiff(sqn) @i ==> not (Ex #j. K(sqn)@j)"

end
