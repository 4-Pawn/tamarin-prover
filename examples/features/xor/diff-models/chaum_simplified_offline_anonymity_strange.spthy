theory Chaum_simplified_Offline_Anonymity begin

// Function signature and definition of the equational theory E

builtins: xor
functions: blind/2, checksign/2, fst/1, pair/2, pk/1, sign/2, snd/1
equations:
    checksign(sign(m, k), pk(k)) = m,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2

rule (modulo E) Register_Corrupted_Bank_pk:
   [ Fr( ~ltkB ), Fr( ~c ) ]
  --[ OnlyOnce( ) ]->
   [
   !Bank_Ltk( $B, ~ltkB ), !Bank_Pk( $B, pk(~ltkB) ), Out( ~ltkB ),
   !TestSubject( ~c )
   ]

rule (modulo E) agent_id:
   [ Fr( ~C ) ] --> [ !Customer( ~C ) ]

rule (modulo E) C_1_2:
   [ Fr( ~x ), Fr( ~r ), !Customer( ~c1 ), !TestSubject( ~c2 ) ]
  --[
  Mint( (~x⊕diff(~c1, ~c2)), ~x, ~r ), Mint( ~x, ~x, ~r ),
  !TestSubject( diff(~c1, ~c2) )
  ]->
   [
   Out( <blind((~x⊕diff(~c1, ~c2)), ~r), blind(~x, ~r)> ),
   !St_C_1( diff(~c1, ~c2), ~x, ~r )
   ]

rule (modulo E) C_2:
   [ !St_C_1( C, ~y, ~r ), In( blind(x, ~r) ) ]
  --[ Coin( x, ~y, ~r ), Spend( C, ~y, ~r ) ]->
   [ Out( x ) ]

restriction OnlyOnce [right]:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction OnlyOnce [left]:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction TestSubjectsAreHonest [right]:
  "∀ C x r #i #j #k.
    (((Spend( C, x, r ) @ #i) ∧ (Spend( C, x, r ) @ #j)) ∧
     (!TestSubject( C ) @ #k)) ⇒
    (#i = #j)"
  // safety formula

restriction TestSubjectsAreHonest [left]:
  "∀ C x r #i #j #k.
    (((Spend( C, x, r ) @ #i) ∧ (Spend( C, x, r ) @ #j)) ∧
     (!TestSubject( C ) @ #k)) ⇒
    (#i = #j)"
  // safety formula

lemma coins [right, sources]:
  all-traces
  "∀ x y r #i. (Coin( x, y, r ) @ #i) ⇒ (∃ #j. Mint( x, y, r ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x y r #i.
  (Coin( x, y, r ) @ #i) ∧ ∀ #j. (Mint( x, y, r ) @ #j) ⇒ ⊥"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #j. (Mint( x, ~y, ~r ) @ #j) ∧ ¬(last(#j))) )
    case case_1
    solve( !St_C_1( C, ~y, ~r ) ▶₀ #i )
      case C_1_2
      solve( !KU( blind(x, ~r) ) @ #vk )
        case C_1_2_case_1
        by contradiction /* from formulas */
      next
        case C_1_2_case_2
        by contradiction /* from formulas */
      next
        case C_2
        solve( Mint( t, ~y.1, ~r.1 ) @ #j )
          case C_1_2_case_1
          by contradiction /* impossible chain */
        next
          case C_1_2_case_2
          by contradiction /* impossible chain */
        qed
      next
        case c_blind
        solve( !KU( ~r ) @ #vk.2 )
          case C_2
          solve( Mint( t, ~y.1, ~r.1 ) @ #j )
            case C_1_2_case_1
            solve( (#vl, 0) ~~> (#vk.1, 0) )
              case d_xor_case_1
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_2
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_3
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_4
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_5
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_6
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            qed
          next
            case C_1_2_case_2
            by solve( (#vl, 0) ~~> (#vk.1, 0) )
          qed
        qed
      qed
    qed
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma coins [left, sources]:
  all-traces
  "∀ x y r #i. (Coin( x, y, r ) @ #i) ⇒ (∃ #j. Mint( x, y, r ) @ #j)"
/*
guarded formula characterizing all counter-examples:
"∃ x y r #i.
  (Coin( x, y, r ) @ #i) ∧ ∀ #j. (Mint( x, y, r ) @ #j) ⇒ ⊥"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (last(#i))  ∥
         (∃ #j. (Mint( x, ~y, ~r ) @ #j) ∧ ¬(last(#j))) )
    case case_1
    solve( !St_C_1( C, ~y, ~r ) ▶₀ #i )
      case C_1_2
      solve( !KU( blind(x, ~r) ) @ #vk )
        case C_1_2_case_1
        by contradiction /* from formulas */
      next
        case C_1_2_case_2
        by contradiction /* from formulas */
      next
        case C_2
        solve( Mint( t, ~y.1, ~r.1 ) @ #j )
          case C_1_2_case_1
          by contradiction /* impossible chain */
        next
          case C_1_2_case_2
          by contradiction /* impossible chain */
        qed
      next
        case c_blind
        solve( !KU( ~r ) @ #vk.2 )
          case C_2
          solve( Mint( t, ~y.1, ~r.1 ) @ #j )
            case C_1_2_case_1
            solve( (#vl, 0) ~~> (#vk.1, 0) )
              case d_xor_case_1
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_2
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_3
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_4
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_5
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            next
              case d_xor_case_6
              by solve( (#vr.5, 0) ~~> (#vk.1, 0) )
            qed
          next
            case C_1_2_case_2
            by solve( (#vl, 0) ~~> (#vk.1, 0) )
          qed
        qed
      qed
    qed
  next
    case case_2
    by contradiction /* from formulas */
  qed
qed

lemma exec [right]:
  exists-trace "∃ x y r #i. Spend( x, y, r ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ x y r #i. (Spend( x, y, r ) @ #i)"
*/
simplify
solve( !St_C_1( x, ~y, ~r ) ▶₀ #i )
  case C_1_2
  solve( !KU( blind(x, ~r) ) @ #vk )
    case C_1_2_case_1
    solve( splitEqs(1) )
      case split
      SOLVED // trace found
    qed
  qed
qed

lemma exec [left]:
  exists-trace "∃ x y r #i. Spend( x, y, r ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ x y r #i. (Spend( x, y, r ) @ #i)"
*/
simplify
solve( !St_C_1( x, ~y, ~r ) ▶₀ #i )
  case C_1_2
  solve( !KU( blind(x, ~r) ) @ #vk )
    case C_1_2_case_1
    solve( splitEqs(1) )
      case split
      SOLVED // trace found
    qed
  qed
qed

lemma anonymity [right]:
  all-traces
  "∀ x #i. (!TestSubject( x ) @ #i) ⇒ (¬(∃ #j. !KU( x ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (!TestSubject( x ) @ #i) ∧ ∃ #j. (!KU( x ) @ #j)"
*/
simplify
solve( !Customer( ~c1 ) ▶₂ #i )
  case agent_id
  solve( !TestSubject( ~c2 ) ▶₃ #i )
    case Register_Corrupted_Bank_pk
    solve( !KU( ~c2 ) @ #j )
      case C_2
      solve( !KU( ~y ) @ #vk.1 )
        case C_2
        by contradiction /* cyclic */
      qed
    qed
  qed
qed

lemma anonymity [left]:
  all-traces
  "∀ x #i. (!TestSubject( x ) @ #i) ⇒ (¬(∃ #j. !KU( x ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x #i. (!TestSubject( x ) @ #i) ∧ ∃ #j. (!KU( x ) @ #j)"
*/
simplify
solve( !Customer( ~c1 ) ▶₂ #i )
  case agent_id
  solve( !TestSubject( ~c2 ) ▶₃ #i )
    case Register_Corrupted_Bank_pk
    solve( !KU( ~c1 ) @ #j )
      case C_2
      solve( !KU( ~y ) @ #vk.1 )
        case C_2
        by contradiction /* cyclic */
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

diffLemma Observational_equivalence:
rule-equivalence
  case Rule_C_1_2
  backward-search
    case LHS
    step( simplify )
    step( solve( !Customer( ~c1 ) ▶₂ #i ) )
      case agent_id
      step( solve( !TestSubject( ~c2 ) ▶₃ #i ) )
        case Register_Corrupted_Bank_pk
        step( solve( splitEqs(0) ) )
          case split
          MIRRORED
        qed
      qed
    qed
  next
    case RHS
    step( simplify )
    step( solve( !Customer( ~c1 ) ▶₂ #i ) )
      case agent_id
      step( solve( !TestSubject( ~c2 ) ▶₃ #i ) )
        case Register_Corrupted_Bank_pk
        step( solve( splitEqs(0) ) )
          case split
          MIRRORED
        qed
      qed
    qed
  qed
next
  case Rule_C_2
  backward-search
    case LHS
    step( simplify )
    step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #i ) )
      case C_1_2
      step( solve( !KU( blind(x, ~r) ) @ #vk ) )
        case C_1_2_case_1
        step( solve( splitEqs(1) ) )
          case split
          MIRRORED
        qed
      next
        case C_1_2_case_2
        step( solve( splitEqs(1) ) )
          case split
          MIRRORED
        qed
      next
        case c_blind
        by step( solve( !KU( ~r ) @ #vk.2 ) )
      qed
    qed
  next
    case RHS
    step( simplify )
    step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #i ) )
      case C_1_2
      step( solve( !KU( blind(x, ~r) ) @ #vk ) )
        case C_1_2_case_1
        step( solve( splitEqs(1) ) )
          case split
          MIRRORED
        qed
      next
        case C_1_2_case_2
        step( solve( splitEqs(1) ) )
          case split
          MIRRORED
        qed
      next
        case c_blind
        by step( solve( !KU( ~r ) @ #vk.2 ) )
      qed
    qed
  qed
next
  case Rule_Destrd_0_checksign
  backward-search
    case LHS
    step( simplify )
    step( solve( !KD( sign(m, k) ) ▶₀ #i ) )
      case C_1_2
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      qed
    next
      case C_2
      step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #vr ) )
        case C_1_2
        step( solve( !KU( blind(t, ~r) ) @ #vk.1 ) )
          case C_1_2_case_1
          step( solve( !KU( pk(k) ) @ #vk.1 ) )
            case c_pk
            step( solve( splitEqs(1) ) )
              case split
              by step( contradiction /* impossible chain */ )
            qed
          qed
        next
          case C_1_2_case_2
          by step( contradiction /* impossible chain */ )
        next
          case c_blind
          by step( contradiction /* forbidden chain */ )
        qed
      qed
    next
      case Register_Corrupted_Bank_pk
      by step( contradiction /* impossible chain */ )
    qed
  next
    case RHS
    step( simplify )
    step( solve( !KD( sign(m, k) ) ▶₀ #i ) )
      case C_1_2
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      qed
    next
      case C_2
      step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #vr ) )
        case C_1_2
        step( solve( !KU( blind(t, ~r) ) @ #vk.1 ) )
          case C_1_2_case_1
          step( solve( !KU( pk(k) ) @ #vk.1 ) )
            case c_pk
            step( solve( splitEqs(1) ) )
              case split
              by step( contradiction /* impossible chain */ )
            qed
          qed
        next
          case C_1_2_case_2
          by step( contradiction /* impossible chain */ )
        next
          case c_blind
          by step( contradiction /* forbidden chain */ )
        qed
      qed
    next
      case Register_Corrupted_Bank_pk
      by step( contradiction /* impossible chain */ )
    qed
  qed
next
  case Rule_Destrd_0_fst
  backward-search
    case LHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case C_1_2
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        step( solve( !Customer( ~c1 ) ▶₂ #vr ) )
          case agent_id
          step( solve( !TestSubject( ~c2 ) ▶₃ #vr ) )
            case Register_Corrupted_Bank_pk
            step( solve( splitEqs(0) ) )
              case split
              MIRRORED
            qed
          qed
        qed
      qed
    next
      case C_2
      step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #vr ) )
        case C_1_2
        step( solve( !KU( blind(t, ~r) ) @ #vk ) )
          case C_1_2_case_1
          step( solve( splitEqs(1) ) )
            case split
            by step( contradiction /* impossible chain */ )
          qed
        next
          case C_1_2_case_2
          by step( contradiction /* impossible chain */ )
        next
          case c_blind
          by step( contradiction /* forbidden chain */ )
        qed
      qed
    next
      case Register_Corrupted_Bank_pk
      by step( contradiction /* impossible chain */ )
    qed
  next
    case RHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case C_1_2
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        step( solve( !Customer( ~c1 ) ▶₂ #vr ) )
          case agent_id
          step( solve( !TestSubject( ~c2 ) ▶₃ #vr ) )
            case Register_Corrupted_Bank_pk
            step( solve( splitEqs(0) ) )
              case split
              MIRRORED
            qed
          qed
        qed
      qed
    next
      case C_2
      step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #vr ) )
        case C_1_2
        step( solve( !KU( blind(t, ~r) ) @ #vk ) )
          case C_1_2_case_1
          step( solve( splitEqs(1) ) )
            case split
            by step( contradiction /* impossible chain */ )
          qed
        next
          case C_1_2_case_2
          by step( contradiction /* impossible chain */ )
        next
          case c_blind
          by step( contradiction /* forbidden chain */ )
        qed
      qed
    next
      case Register_Corrupted_Bank_pk
      by step( contradiction /* impossible chain */ )
    qed
  qed
next
  case Rule_Destrd_0_snd
  backward-search
    case LHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case C_1_2
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        step( solve( !Customer( ~c1 ) ▶₂ #vr ) )
          case agent_id
          step( solve( !TestSubject( ~c2 ) ▶₃ #vr ) )
            case Register_Corrupted_Bank_pk
            step( solve( splitEqs(0) ) )
              case split
              MIRRORED
            qed
          qed
        qed
      qed
    next
      case C_2
      step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #vr ) )
        case C_1_2
        step( solve( !KU( blind(t, ~r) ) @ #vk ) )
          case C_1_2_case_1
          step( solve( splitEqs(1) ) )
            case split
            by step( contradiction /* impossible chain */ )
          qed
        next
          case C_1_2_case_2
          by step( contradiction /* impossible chain */ )
        next
          case c_blind
          by step( contradiction /* forbidden chain */ )
        qed
      qed
    next
      case Register_Corrupted_Bank_pk
      by step( contradiction /* impossible chain */ )
    qed
  next
    case RHS
    step( simplify )
    step( solve( !KD( <x, x.1> ) ▶₀ #i ) )
      case C_1_2
      step( solve( (#vl, 0) ~~> (#i, 0) ) )
        case d_0_fst
        by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
      next
        case d_0_snd
        by step( contradiction /* impossible chain */ )
      next
        case pair
        step( solve( !Customer( ~c1 ) ▶₂ #vr ) )
          case agent_id
          step( solve( !TestSubject( ~c2 ) ▶₃ #vr ) )
            case Register_Corrupted_Bank_pk
            step( solve( splitEqs(0) ) )
              case split
              MIRRORED
            qed
          qed
        qed
      qed
    next
      case C_2
      step( solve( !St_C_1( C, ~y, ~r ) ▶₀ #vr ) )
        case C_1_2
        step( solve( !KU( blind(t, ~r) ) @ #vk ) )
          case C_1_2_case_1
          step( solve( splitEqs(1) ) )
            case split
            by step( contradiction /* impossible chain */ )
          qed
        next
          case C_1_2_case_2
          by step( contradiction /* impossible chain */ )
        next
          case c_blind
          by step( contradiction /* forbidden chain */ )
        qed
      qed
    next
      case Register_Corrupted_Bank_pk
      by step( contradiction /* impossible chain */ )
    qed
  qed
next
  case Rule_Destrd_xor
  backward-search
    case LHS
    step( simplify )
    step( solve( DiffIntrDestrd_xor( ) @ #i ) )
      case d_xor_case_1
      by sorry
    next
      case d_xor_case_2
      step( solve( !KD( (x⊕y) ) ▶₀ #i ) )
        case C_1_2
        step( solve( (#vl, 0) ~~> (#i, 0) ) )
          case d_0_fst
          by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
        next
          case d_0_snd
          by step( contradiction /* impossible chain */ )
        qed
      next
        case C_2
        step( solve( !St_C_1( C, ~y.1, ~r ) ▶₀ #vr ) )
          case C_1_2
          step( solve( !KU( blind(t, ~r) ) @ #vk.3 ) )
            case C_1_2_case_1
            step( solve( splitEqs(1) ) )
              case split
              step( solve( (#vl, 0) ~~> (#i, 0) ) )
                case Xor_case_1
                step( solve( !KU( ~y ) @ #vk.3 ) )
                  case C_2
                  step( solve( !KU( ~c1 ) @ #vk.4 ) )
                    case C_2
                    step( solve( !KU( ~y.1 ) @ #vk.6 ) )
                      case C_2
                      by step( contradiction /* cyclic */ )
                    qed
                  qed
                qed
              next
                case Xor_case_2
                step( solve( !KU( ~c1 ) @ #vk.3 ) )
                  case C_2
                  step( solve( !KU( ~y ) @ #vk.5 ) )
                    case C_2
                    by step( contradiction /* cyclic */ )
                  qed
                qed
              next
                case d_xor_case_1
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_2
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_3
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_4
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_5
                by step( contradiction /* impossible chain */ )
              next
                case d_xor_case_6
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case C_1_2_case_2
            by step( contradiction /* impossible chain */ )
          next
            case c_blind
            by step( contradiction /* forbidden chain */ )
          qed
        qed
      next
        case Register_Corrupted_Bank_pk
        by step( contradiction /* impossible chain */ )
      qed
    next
      case d_xor_case_3
      step( solve( !KD( (x⊕y) ) ▶₀ #i ) )
        case C_1_2
        step( solve( (#vl, 0) ~~> (#i, 0) ) )
          case d_0_fst
          by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
        next
          case d_0_snd
          by step( contradiction /* impossible chain */ )
        qed
      next
        case C_2
        step( solve( !St_C_1( C, ~y.1, ~r ) ▶₀ #vr ) )
          case C_1_2
          step( solve( !KU( blind(t, ~r) ) @ #vk.1 ) )
            case C_1_2_case_1
            step( solve( splitEqs(1) ) )
              case split
              step( solve( (#vl, 0) ~~> (#i, 0) ) )
                case Xor_case_1
                step( solve( !KU( ~y ) @ #vk.1 ) )
                  case C_2
                  step( solve( !KU( ~c1 ) @ #vk.2 ) )
                    case C_2
                    step( solve( !KU( ~y.1 ) @ #vk.4 ) )
                      case C_2
                      by step( contradiction /* cyclic */ )
                    qed
                  qed
                qed
              next
                case Xor_case_2
                step( solve( !KU( ~c1 ) @ #vk.1 ) )
                  case C_2
                  step( solve( !KU( ~y ) @ #vk.3 ) )
                    case C_2
                    by step( contradiction /* cyclic */ )
                  qed
                qed
              next
                case d_xor_case_1
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_2
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_3
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_4
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_5
                by step( contradiction /* impossible chain */ )
              next
                case d_xor_case_6
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case C_1_2_case_2
            by step( contradiction /* impossible chain */ )
          next
            case c_blind
            by step( contradiction /* forbidden chain */ )
          qed
        qed
      next
        case Register_Corrupted_Bank_pk
        by step( contradiction /* impossible chain */ )
      qed
    qed
  next
    case RHS
    step( simplify )
    step( solve( DiffIntrDestrd_xor( ) @ #i ) )
      case d_xor_case_1
      step( solve( !KD( (x⊕y) ) ▶₀ #i ) )
        case C_1_2
        step( solve( (#vl, 0) ~~> (#i, 0) ) )
          case d_0_fst
          by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
        next
          case d_0_snd
          by step( contradiction /* impossible chain */ )
        qed
      next
        case C_2
        step( solve( !St_C_1( C, ~y.1, ~r ) ▶₀ #vr ) )
          case C_1_2
          step( solve( splitEqs(1) ) )
            case split
            step( solve( !KU( blind(t, ~r) ) @ #vk.1 ) )
              case C_1_2_case_1
              step( solve( (#vl, 0) ~~> (#i, 0) ) )
                case Xor_case_1
                step( solve( !KU( (~y⊕z) ) @ #vk.1 ) )
                  case coerce
                  step( solve( !KD( (~y⊕z) ) ▶₀ #vk.1 ) )
                    case C_1_2
                    step( solve( !Customer( ~c1.1 ) ▶₂ #vr.5 ) )
                      case agent_id
                      step( solve( !TestSubject( ~c2.1 ) ▶₃ #vr.5 ) )
                        case Register_Corrupted_Bank_pk
                        step( solve( splitEqs(6) ) )
                          case split
                          step( solve( (#vl.2, 0) ~~> (#vk.1, 0) ) )
                            case d_0_fst
                            by step( solve( (#vr.7, 0) ~~> (#vk.1, 0) ) )
                          next
                            case d_0_snd
                            by step( contradiction /* impossible chain */ )
                          qed
                        qed
                      qed
                    qed
                  next
                    case C_2
                    step( solve( !KU( blind(t, ~r.1) ) @ #vk.2 ) )
                      case C_1_2_case_1
                      step( solve( !St_C_1( C, ~y.1, ~r.1 ) ▶₀ #vr.5 ) )
                        case C_1_2
                        step( solve( splitEqs(7) ) )
                          case split
                          step( solve( (#vl.2, 0) ~~> (#vk.1, 0) ) )
                            case d_xor_case_1
                            by step( solve( (#vr.9, 0) ~~> (#vk.1, 0) ) )
                          next
                            case d_xor_case_2
                            step( solve( (#vr.9, 0) ~~> (#vk.1, 0) ) )
                              case Xor_case_1
                              step( solve( !KU( (~c2⊕~y) ) @ #vk.3 ) )
                                case coerce
                                step( solve( !KD( (~c2⊕~y) ) ▶₀ #vk.3 ) )
                                  case C_1_2
                                  step( solve( !Customer( ~c1.2 ) ▶₂ #vr.10 ) )
                                    case agent_id
                                    step( solve( !TestSubject( ~c2.1 ) ▶₃ #vr.10 ) )
                                      case Register_Corrupted_Bank_pk
                                      step( solve( splitEqs(14) ) )
                                        case split
                                        step( solve( (#vl.4, 0) ~~> (#vk.3, 0) ) )
                                          case d_0_fst
                                          by step( solve( (#vr.12, 0) ~~> (#vk.3, 0) ) )
                                        next
                                          case d_0_snd
                                          by step( contradiction /* impossible chain */ )
                                        qed
                                      qed
                                    qed
                                  qed
                                next
                                  case C_2
                                  step( solve( !St_C_1( C, ~y.1, ~r.2 ) ▶₀ #vr.10 ) )
                                    case C_1_2
                                    step( solve( splitEqs(15) ) )
                                      case split
                                      step( solve( !KU( blind(t, ~r.2) ) @ #vk.4 ) )
                                        case C_1_2_case_1
                                        step( solve( (#vl.4, 0) ~~> (#vk.3, 0) ) )
                                          case Xor
                                          by sorry
                                        next
                                          case d_xor_case_1
                                          by sorry
                                        next
                                          case d_xor_case_2
                                          by sorry
                                        next
                                          case d_xor_case_3
                                          by sorry
                                        next
                                          case d_xor_case_4
                                          by sorry
                                        next
                                          case d_xor_case_5
                                          by step( contradiction /* impossible chain */ )
                                        next
                                          case d_xor_case_6
                                          by step( contradiction /* impossible chain */ )
                                        qed
                                      next
                                        case C_1_2_case_2
                                        by step( contradiction /* impossible chain */ )
                                      next
                                        case c_blind
                                        by step( contradiction /* forbidden chain */ )
                                      qed
                                    qed
                                  qed
                                next
                                  case Register_Corrupted_Bank_pk
                                  by step( contradiction /* impossible chain */ )
                                qed
                              qed
                            next
                              case Xor_case_2
                              by sorry
                            next
                              case Xor_case_3
                              by sorry
                            qed
                          next
                            case d_xor_case_3
                            by sorry
                          next
                            case d_xor_case_4
                            by sorry
                          next
                            case d_xor_case_5
                            by step( contradiction /* impossible chain */ )
                          next
                            case d_xor_case_6
                            by step( contradiction /* impossible chain */ )
                          qed
                        qed
                      qed
                    next
                      case C_1_2_case_2
                      by step( contradiction /* impossible chain */ )
                    next
                      case c_blind
                      by step( contradiction /* forbidden chain */ )
                    qed
                  next
                    case Register_Corrupted_Bank_pk
                    by step( contradiction /* impossible chain */ )
                  qed
                qed
              next
                case Xor_case_2
                by sorry
              next
                case d_xor_case_1
                by sorry
              next
                case d_xor_case_2
                by sorry
              next
                case d_xor_case_3
                by sorry
              next
                case d_xor_case_4
                by sorry
              next
                case d_xor_case_5
                by step( contradiction /* impossible chain */ )
              next
                case d_xor_case_6
                by step( contradiction /* impossible chain */ )
              qed
            next
              case C_1_2_case_2
              by step( contradiction /* impossible chain */ )
            next
              case c_blind
              by step( contradiction /* forbidden chain */ )
            qed
          qed
        qed
      next
        case Register_Corrupted_Bank_pk
        by step( contradiction /* impossible chain */ )
      qed
    next
      case d_xor_case_2
      step( solve( !KD( (x⊕y) ) ▶₀ #i ) )
        case C_1_2
        step( solve( (#vl, 0) ~~> (#i, 0) ) )
          case d_0_fst
          by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
        next
          case d_0_snd
          by step( contradiction /* impossible chain */ )
        qed
      next
        case C_2
        step( solve( !St_C_1( C, ~y.1, ~r ) ▶₀ #vr ) )
          case C_1_2
          step( solve( !KU( blind(t, ~r) ) @ #vk.3 ) )
            case C_1_2_case_1
            step( solve( splitEqs(1) ) )
              case split
              step( solve( (#vl, 0) ~~> (#i, 0) ) )
                case Xor_case_1
                step( solve( !KU( ~y ) @ #vk.3 ) )
                  case C_2
                  step( solve( !KU( ~c2 ) @ #vk.4 ) )
                    case C_2
                    step( solve( !KU( ~y.1 ) @ #vk.6 ) )
                      case C_2
                      by step( contradiction /* cyclic */ )
                    qed
                  qed
                qed
              next
                case Xor_case_2
                step( solve( !KU( ~c2 ) @ #vk.3 ) )
                  case C_2
                  step( solve( !KU( ~y ) @ #vk.5 ) )
                    case C_2
                    by step( contradiction /* cyclic */ )
                  qed
                qed
              next
                case d_xor_case_1
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_2
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_3
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_4
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_5
                by step( contradiction /* impossible chain */ )
              next
                case d_xor_case_6
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case C_1_2_case_2
            by step( contradiction /* impossible chain */ )
          next
            case c_blind
            by step( contradiction /* forbidden chain */ )
          qed
        qed
      next
        case Register_Corrupted_Bank_pk
        by step( contradiction /* impossible chain */ )
      qed
    next
      case d_xor_case_3
      step( solve( !KD( (x⊕y) ) ▶₀ #i ) )
        case C_1_2
        step( solve( (#vl, 0) ~~> (#i, 0) ) )
          case d_0_fst
          by step( solve( (#vr.1, 0) ~~> (#i, 0) ) )
        next
          case d_0_snd
          by step( contradiction /* impossible chain */ )
        qed
      next
        case C_2
        step( solve( !St_C_1( C, ~y.1, ~r ) ▶₀ #vr ) )
          case C_1_2
          step( solve( !KU( blind(t, ~r) ) @ #vk.1 ) )
            case C_1_2_case_1
            step( solve( splitEqs(1) ) )
              case split
              step( solve( (#vl, 0) ~~> (#i, 0) ) )
                case Xor_case_1
                step( solve( !KU( ~y ) @ #vk.1 ) )
                  case C_2
                  step( solve( !KU( ~c2 ) @ #vk.2 ) )
                    case C_2
                    step( solve( !KU( ~y.1 ) @ #vk.4 ) )
                      case C_2
                      by step( contradiction /* cyclic */ )
                    qed
                  qed
                qed
              next
                case Xor_case_2
                step( solve( !KU( ~c2 ) @ #vk.1 ) )
                  case C_2
                  step( solve( !KU( ~y ) @ #vk.3 ) )
                    case C_2
                    by step( contradiction /* cyclic */ )
                  qed
                qed
              next
                case d_xor_case_1
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_2
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_3
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_4
                by step( solve( (#vr.5, 0) ~~> (#i, 0) ) )
              next
                case d_xor_case_5
                by step( contradiction /* impossible chain */ )
              next
                case d_xor_case_6
                by step( contradiction /* impossible chain */ )
              qed
            qed
          next
            case C_1_2_case_2
            by step( contradiction /* impossible chain */ )
          next
            case c_blind
            by step( contradiction /* forbidden chain */ )
          qed
        qed
      next
        case Register_Corrupted_Bank_pk
        by step( contradiction /* impossible chain */ )
      qed
    qed
  qed
next
  case Rule_Equality
  by sorry
next
  case Rule_Register_Corrupted_Bank_pk
  backward-search
    case LHS
    step( simplify )
    MIRRORED
  next
    case RHS
    step( simplify )
    MIRRORED
  qed
next
  case Rule_Send
  backward-search
    case LHS
    step( simplify )
    MIRRORED
  next
    case RHS
    step( simplify )
    MIRRORED
  qed
next
  case Rule_agent_id
  backward-search
    case LHS
    step( simplify )
    MIRRORED
  next
    case RHS
    step( simplify )
    MIRRORED
  qed
qed

end