theory LAK06
begin

// This theory models LAK06 as taken from "Attacks on RFID protocols" v1.1
// from Aug 6, 2009, by Ton van Deursen and Sasa Radomirovic
//
// This model only considers two pairs of Reader/Tag but fully models
// the key chaining mechanism.
// Still, it shows that noninjective agreement
// for the Reader is indeed violated (valid attack found!). The proof for
// noninjective agreement for the Tag only holds in this very restricted model.

builtins: xor, hashing

/*
  T: k
  R: k, k0
  R -> T: r0
  T -> R: r1, h(r0 XOR r1 XOR k)               (accept if a matches for k or k0)
  R -> T: h(h(r0 XOR r1 XOR k) XOR k XOR r0)
  T: k'  := h(k) 
 ---- if R finds k (and not k0) that matches then -----
  R: k0' := k
     kk' := h(k)

*/

rule setup:
  let k0 = ~k
      k = h(k0)
  in
  [ Fr(~k), Fr(~id) ]
--[ OnlyOnce('setup'), Key(k0), Key(k) ]->
  [ Reader(~id)
  , Tag(~id)
  , Reader(~id)
  , Tag(~id)
  , ReaderK(~id, k0, k)
  , TagK(~id, k)
  ]

rule initiatereader:
  [ !Reader(~id)
  , Fr(~r0)
  ]
--[ ]->
  [ ReaderState1(~id, ~r0)
  , Out(~r0) ]

rule tag1:
  [ !Tag(~id)
  , TagK(~id, k)
  , Fr(~r1)
  , In(r0) ]
--[ Running(<'R','T',<k,r0,~r1>>)
  , Key(k)
  ]->
  [ TagState1(~id, k, ~r1, r0)
  , Out(<~r1, h(r0 XOR ~r1 XOR k)>)
  , TagK(~id, k)
  ]

rule acceptreaderOld:		// the key k matches
  [ ReaderState1(~id, ~r0)
  , In(<r1, h(~r0 XOR r1 XOR k)>)
  , ReaderK(~id, k0, k)
  ]
--[ Commit(<'R','T',<k,~r0,r1>>)
  , Running(<'T','R',<k,~r0,r1>>)
  , Key(k0), Key(k) ]->
  [ Out(h(h(~r0 XOR r1 XOR k) XOR k XOR ~r0))
  , ReaderK(~id, k, h(k))	// k0 and k are updated in such a case
  ]

rule acceptreaderNew:		//the key k0 matches
  [ ReaderState1(~id, ~r0)
  , In(<r1, h(~r0 XOR r1 XOR k0)>)
  , ReaderK(~id, k0, k)
  ]
--[ Commit(<'R','T',<k0,~r0,r1>>)
  , Running(<'T','R',<k0,~r0,r1>>)
  , Key(k0), Key(k) ]->
  [ Out(h(h(~r0 XOR r1 XOR k0) XOR k0 XOR ~r0))
  , ReaderK(~id, k0, k)		//k0 and k do not change in that case (last message from last session got lost)
  ]

rule accepttag:
  [ TagState1(~id, k, ~r1, r0)
  , In(h(h(r0 XOR ~r1 XOR k) XOR k XOR r0))
  , TagK(~id, k)
  ]
--[ Commit(<'T','R',<k,r0,~r1>>)
  , FinTag()
  , Key(k) ]->
  [ TagK(~id, h(k)) ]		// Tag always updates its key k (he knows Reader did the same)



restriction onylOnce:
  "All x #i1 #i2. OnlyOnce(x)@i1 & OnlyOnce(x)@i2 ==> #i1 = #i2"

// PROVEN, quick autoproof
// (2017-11-01, aa65be43cd4965ffa1c51a991d9139e98ec1662e)
lemma helpingSecrecy[use_induction, reuse]:
  "All k #i. 
     Key(k)@i ==> not(Ex #j. K(k)@j)"

// PROVEN, quick autoproof
// (2017-11-01, aa65be43cd4965ffa1c51a991d9139e98ec1662e)
lemma executable:
  exists-trace
  " (Ex #i. FinTag()@i)
  & (All x #i1 #i2. OnlyOnce(x)@i1 & OnlyOnce(x)@i2 ==> #i1 = #i2)"

// PROVEN, quick autoproof
// (2017-11-01, aa65be43cd4965ffa1c51a991d9139e98ec1662e)
lemma noninjectiveagreementTAG[use_induction]:
  "All t #i. 
    Commit(<'T','R',t>) @i
    ==> (Ex #j. Running(<'T','R',t>) @j)"

// FALSIFIED, quick autoproof
// (2017-11-01, aa65be43cd4965ffa1c51a991d9139e98ec1662e)
lemma noninjectiveagreementREADER[use_induction]:
  "All t #i. 
    Commit(<'R','T',t>) @i
    ==> (Ex #j. Running(<'R','T',t>) @j)"

end
