theory LAK06_state
begin

// This theory models LAK06 as taken from "Attacks on RFID protocols" v1.1
// from Aug 6, 2009, by Ton van Deursen and Sasa Radomirovic
//
// This model considers two pairs of Reader/Tag that can play
// an unbounded number of sessions and fully models
// the key chaining mechanism.
// Still, it shows that noninjective agreement
// for the Reader is indeed violated (valid attack found!). The proof for
// noninjective agreement for the Tag only holds in this very restricted model.

builtins: xor, hashing

/*
  T: k
  R: k, k0
  R -> T: r0
  T -> R: r1, h(r0 XOR r1 XOR k)               (accept if a matches for k or k0)
  R -> T: h(h(r0 XOR r1 XOR k) XOR k XOR r0)
  T: k'  := h(k) 
 ---- if R finds k (and not k0) that matches then -----
  R: k0' := k
     kk' := h(k)

*/

rule setup: // one pair Tag-Reader, unbounded nb. of sessions
  let k0 = h(~k)
      k = h(k0)
  in
  [ Fr(~k), Fr(~id) ]
--[ OnlyOnce('2Users')
  , Update(k, 'T')
  , Update(k0, 'R')
  , Update(k, 'R')
  , Setup()
  ]->
  [ ! Reader(~id)
  , ! Tag(~id)
  , ReaderK(~id, k0, k)
  , TagK(~id, k)
  ]

rule initiatereader:
  [ !Reader(~id)
  , Fr(~r0)
  ]
--[ ]->
  [ ReaderState1(~id, ~r0)
  , Out(~r0) ]

rule tag1:
  [ !Tag(~id)
  , TagK(~id, k)
  , Fr(~r1)
  , In(r0) ]
--[ Running(<'R','T',<k,r0,~r1>>)
  , Key(k, 'T')
  , OutH(r0 XOR ~r1 XOR k)	//for Out != h(SomeKey)
  , Out(<'T','R',<~r1, h(r0 XOR ~r1 XOR k)>>)
  ]->
  [ TagState1(~id, k, ~r1, r0, h(r0 XOR ~r1 XOR k))
  , Out(<~r1, h(r0 XOR ~r1 XOR k)>)
  , TagK(~id, k)
  ]

rule acceptreaderOld:		// the key k matches
  [ ReaderState1(~id, ~r0)
  , In(<r1, x>)			// x = h(~r0 XOR r1 XOR k)
  , ReaderK(~id, k0, k)
  ]
--[ Equ(x, h(~r0 XOR r1 XOR k))
  , Commit(<'R','T',<k,~r0,r1>>)
  , Running(<'T','R',<k,~r0,r1>>)
  , Accept(<'R','T',<r1, h(~r0 XOR r1 XOR k)>>)
  , Key(k0, 'R'), Key(k, 'R')
  , Update(h(k), 'R')
  , Update(k, 'R')
  , OutH(h(h(~r0 XOR r1 XOR k) XOR k XOR ~r0))	//for Out != h(SomeKey)
  , Out(<'R','T',h(h(~r0 XOR r1 XOR k) XOR k XOR ~r0)>)
  ]->
  [ Out(h(x XOR k XOR ~r0))
  , ReaderK(~id, k, h(k))	// k0 and k are updated in such a case
  ]

rule acceptreaderNew:		// the key k0 matches
  [ ReaderState1(~id, ~r0)
  , In(<r1, x>)			// x = h(~r0 XOR r1 XOR k0)
  , ReaderK(~id, k0, k)
  ]
--[ Equ(x, h(~r0 XOR r1 XOR k0))
  , Commit(<'R','T',<k0,~r0,r1>>)
  , Running(<'T','R',<k0,~r0,r1>>)
  , Accept(<'R','T',<r1,h(~r0 XOR r1 XOR k0)>>)
  , Key(k0, 'R'), Key(k, 'R')
  , Update(k0, 'R')
  , Update(k, 'R')
  , OutH(h(h(~r0 XOR r1 XOR k0) XOR k0 XOR ~r0))	//for Out != h(SomeKey)
  , Out(<'R','T',h(h(~r0 XOR r1 XOR k0) XOR k0 XOR ~r0)>)
  ]->
  [ Out(h(x XOR k0 XOR ~r0))
  , ReaderK(~id, k0, k)		// k0 and k do not change in that case (last message from last session got lost)
  ]

rule accepttag:
  [ TagState1(~id, k, ~r1, r0, m)
  , In(x)   // expected: h(h(r0 XOR ~r1 XOR k) XOR k XOR r0)
  , TagK(~id, k)
  ]
--[ Equ(x, h(m XOR k XOR r0))
  , Commit(<'T','R',<k,r0,~r1>>)
  , FinTag()
  , Key(k, 'T')
  , Update(h(k), 'T')
  , Accept(<'T','R',h(h(r0 XOR ~r1 XOR k) XOR k XOR r0)>)
  ]->
  [ TagK(~id, h(k)) ]		// Tag always updates its key k (he knows Reader did the same)


restriction Equ:
  "All x y #i. Equ(x,y)@i ==> x = y"

restriction onylOnce:
  "All x #i1 #i2. OnlyOnce(x)@i1 & OnlyOnce(x)@i2 ==> #i1 = #i2"

// PROVEN, quick manual proof that could be automatized very easily.
// --> only prioritize ReaderK() and TagK() goals and then full auto mode, autoprove with associated oracle (LAK_state-oracle)
// Git revision: 8265b38c9c418d1c0940fece192d673ce45bc9e4, branch: develop
// Compiled at: 2017-11-02 14:54:16.198059 UTC
lemma helpingUpdateKey[use_induction, reuse]: // usage of a key ---> key has been updated or created before
  "All k r #i. 
     Key(k, r)@i ==>
       ( (Ex #j. Update(k, r)@j & #j < #i))"
        // | (Ex #j. Create(k, r)@j & #j < #i))"

// PROVEN, instant autoproof
// Git revision: 8265b38c9c418d1c0940fece192d673ce45bc9e4, branch: develop
// Compiled at: 2017-11-02 14:54:16.198059 UTC
lemma helpingStackHash[use_induction, reuse]: // no Out(h(key))
  "(All k r #i. ((Key(k, r)@i ==> Ex k0. k = h(k0))))
 & (All k r #i. ((Update(k, r)@i ==> Ex k0. k = h(k0))))"

// lemma 2helpingStackHash[use_induction, reuse]: // no Out(h(key))
//   "// (All k r #i. Key(k, r)@i    ==>
//  //       (Ex #j. K(k) @j) )
//  // 
//  // & (All k r #i. Update(k, r)@i ==>
//  //       (Ex #j. K(k) @j) )
//   (All t #i. Commit(<'T','R',t>) @i  ==>
//        (Ex #j. Running(<'T','R',t>) @j))
//  & (All k r0 r1 #i. Commit(<'R','T',<k,r0,r1>>) @i  ==>
//        (Ex r11 #j. Running(<'R','T',<k,r0,r11>>) @j))
// "  //no agreement here on r1 or r0!!

// lemma helpingOutNotKey[use_induction, reuse]: // no Out(h(key))
//   "All k r #i. Key(k, r)@i ==> not(Ex #j. OutH(h(k))@j )"

// lemma 2helpingUpdateKey[use_induction, reuse]: // usage of a key ---> key has been updated or created before
//   "All k r #i. 
//      Update(k, r)@i ==>
//         ( (Ex #j. Update(k, r)@j & #j < #i)
//         | (Ex #j. Create(k, r)@j & #j < #i))"


lemma helpingSecrecy[use_induction, reuse]:	              // I thought this lemma would be easy to prove. It is not.
  "All k r #i. Key(k, r)@i ==> not(Ex #j. K(k)@j)"

lemma executable:
  exists-trace
  " (Ex #i. FinTag()@i)
  & (All x #i1 #i2. OnlyOnce(x)@i1 & OnlyOnce(x)@i2 ==> #i1 = #i2)"

lemma noninjectiveagreementTAG[use_induction]:
  "All t #i. 
    Commit(<'T','R',t>) @i
    ==> (Ex #j. Running(<'T','R',t>) @j)"

lemma noninjectiveagreementREADER[use_induction]:
  "All t #i. 
    Commit(<'R','T',t>) @i
    ==> (Ex #j. Running(<'R','T',t>) @j)"

end
