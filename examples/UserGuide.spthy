/*

Protocol:	Tutorial
Modeler: 	Simon Meier, Benedikt Schmidt
Date: 	        February 2012


Introduction
============

This tutorial assumes that you have a copy of our CSF'12 paper on "Automated
Analysis of Diffie-Hellman Protocols and Advanced Security Properties". Drop
us a mail, if you would like to receive a copy.

The input files for the tamarin prover have the extension .spthy, which is
short for 'security protocol theory'. A security protocol theory specifies

  1. the signature and equational theory to use for the message algebra,
  2. the set of set of multiset rewriting rules modeling the protocol and
     the adversary capabilities, and
  3. the guarded trace properties whose validity for this set of multiset
     rewriting rules we want to check.

We explain each of these parts where they occur in the following security
protocol theory. As you probably noticed comments are C-style: we use /*  */
for delimiting multi-line comments and // for line-comments.

Every security protocol theory starts with the following header.
*/

theory UserGuide
begin


// you can locally define flags
#define R1

// and test for the definedness
#ifdef R1
#ifdef L1
rule Test:
  [ In(<~x, ~y, y>) ] --[ Attack() ]-> [ Attack () ]
#endif
#endif


#ifdef L1
lemma test:
  "not (Ex #i. Attack() @ i) "

#endif

end

/*
// Public key infrastructure
rule Register_pk:
  [ Fr(~ltk) ] 
  --> 
  [ !Ltk($A, sk(~ltk)), !Pk($A, pk(~ltk)) ]

rule Get_pk:
  [ !Pk(A, pk) ] 
  --> 
  [ Out(pk) ]

rule Reveal_ltk:
    [ !Ltk(A, ltk) ]
  --[ LtkReveal(A) ]->
    [ Out(ltk) ]

/*
// Equality checking: Does not work because no message variable
// allowed in Fr facts.
rule Eq:
    [ Fr(<'Eq',x>) ] --> [ !Eq(x,x) ]

// Protocol
rule Init_1:
  [ Fr(~k), !Pk($C, pkC), !Pk($S, pkS) ]
  -->
  [ Init_1( $C, pkC, $S, pkS, ~k ), Out( encA{'1', $C, ~k}pkS ) ]

rule Init_2:
    [ Init_1( $C, pkC, $S, pkS, ~k )
    , In( encA{'2', $S, ~k}pkC )
    ]
  --[ SessKeyI( $C, $S, ~k ) ]->
    [] 

rule Serv_1:
    [ !Pk(C, pkC), !Pk($S, pkS), In( encA{'1', C, k}pkS ) ]
  --[ SessKeyS( C, $S, k ) ]->
    [ Out( encA{'2', $S, k}pkC ) ]
*/

/*
rule Init_1:
  [ Fr(~k), !Ltk($C, ltkC), !Pk($S, pkS) ]
  -->
  [ Init_1( $C, ltkC, $S, ~k ), Out( encA{'1', $C, ~k}pkS ) ]

rule Init_2:
    [ Init_1( $C, ltkC, $S, ~k )
    , In( m )
    , !Eq( decA{m}ltkC, <'2', $S, ~k> )
    ]
  --[ SessKeyI( $C, $S, ~k ) ]->
    [] 

rule Serv_1:
    [ !Ltk($S, ltkS), In( m ) ]
    -->
    [ 
  --[ SessKeyS( $S, snd(snd(decA{m}ltkS)) ) ]->
    [ Out( encA{'2', $S, snd(snd(decA{m}ltkS})) )     ]
*/

/*
lemma Init_secrecy:
  "not(
     Ex S k #ii #ik.
       SessKeyI(S, k) @ ii & 
       K(k) @ ik 
       &
       (All #ir. not(LtkReveal(S) @ ir) | ik < ir)
   )
  "

lemma Init_auth:
  "SessKeyI(S, k) @ ii 
   ==>
   (Ex #ir. LtkReveal(S) @ ir & ik < vr) |
   (Ex #is.  SessKeyS(S, k) @ is & is < ii)
  "
*/


end
