theory Blind_Signature
begin

/*
 * Protocol: Okamoto	
 * Modeler: 	
 * Date: 	
 * Source:	
 *
 * Status: 	
 */

/* We formalize the following protocol

  protocol FOO {
    Phase 1:
    1. V -> A: sign(blind(tdcommit(vote,r,td),b),skV)
    2. A -> V: sign(blind(tdcommit(vote,r,td),b),skA)
    Phase 2:
    3. V -> C: Private:< V,sign(tdcommit(vote,r,td),skA)>
    Phase 3
    5. V -> T: { vote, r, tdcommit(vote,r,td) }pkT
    6. T -> Pub: vote
  }
*/

builtins: signing

functions: blind/2, unblind/2, open/2, tdcommit/3, checksign/2, f/4

equations: checksign( sign(m,sk), pk(sk) ) = m,
           unblind( blind(m,b), b ) = m,
           unblind( sign( blind(m,b), sk), b ) = sign(m,sk),
           open( tdcommit(m,r,td), r ) = m,
           tdcommit( m2,f(m1,r,td,m2), td ) = tdcommit(m1,r,td),
           open( tdcommit(m1,r,td), f(m1,r,td,m2) )=m2,
           f(m1, f (m, r, td, m1), td, m2) = f (m, r, td, m2)    //The two last rules are needed for the convergence


// Public key infrastructure
rule Register_Voter_pk:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk($V, ~ltkV), !Pk($V, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Collect_pk:
  [ Fr(~ltkC) ] --[ ]-> [ !CollectLtk($C, ~ltkC), !CollectPk($C, pk(~ltkC)), Out(pk(~ltkC)) ]

rule Register_Admin_pk:
  [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(pk(~ltkA)) ]

rule Register_Timeliness_pk:
  [ Fr(~ltkT) ] --[ ]-> [ !TLtk($T, ~ltkT), !TPk($T, pk(~ltkT)), Out(pk(~ltkT)) ]

/*
rule Reveal_Voter_ltk:
  [ !Ltk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Collect_ltk:
  [ !CollectLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Adminltk:
  [ !AdminLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Timeliness_ltk:
  [ !TLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]
*/

//Rules

rule V_1:
  let x = tdcommit( ~vote , ~r, ~td )
      e = blind( x, ~b )
      s = sign ( e , ltkV )
  in
    [ Fr( ~r ), Fr( ~b ), Fr(~td), Fr( ~vote ), !Ltk( V, ltkV ) ]
  --[ Voted(~vote), Create_V_1(e)]->
    [ Out( < e , s , V> ), St_V_1( V, ~vote, ~r, ~b, ~td ) ]

rule A_1:
  let d = sign( e, ltkA )
      verif = verify(s, e, pkV)
  in
    [ In( < e , s , V>), !AdminLtk( A, ltkA ), !Pk( V, pkV ) ]
  --[ Eq( verif, true ),  Signature(e,V), In_A_1(e) ]->
    [ Out( < e , d > ) ]

rule V_2:    // Check Admin_Signature & Check the commit 
  let y = unblind(d,b)   // = sign(x,ltkA)
      x = tdcommit(vote,r,td)
      verif1 = verify( d, e, pkA )
      verif2 = verify( y, x, pkA )
  in
    [ In(< e, d>), St_V_1( V, vote, r, b, td),  !AdminPk(A, pkA) ]
  --[ Eq( verif1, true ), Eq(verif2,true), In_V_2( e ) ]->     
    [ P_Ch_Collector( x,y ) , St_V_2( V, A, vote, r, td ) ]

rule C_1:
    [ P_Ch_Collector( x,y ), !AdminPk(A, pkA)]
  --[ Eq( checksign(y,pkA), x )  ]->
    [ Out( <x,y> ) ]

rule V_3:
    [ In (<x,y>), St_V_2(V, A, vote, r, td )]
  --[  ]->
    [ P_Ch_Timeliness( vote, r, x ), St_V_3(V, A, vote, x )  ]

rule V_4:
    [ In (x1), St_V_3(V, A, vote, x2 )]
  --[ Eq( x1 , x2) ]->
    [  ]

rule T_1:
  let v = open( x, r)
  in
    [ P_Ch_Timeliness( vote, r, x ) ]
  --[ VotePublished( vote ) ]->
    [ Out( vote ) ]


lemma types [typing]:
  " (
  All e #i. In_A_1(e) @ i
  ==>
  ( (Ex #j. Create_V_1( e )@j & j<i )
  ) ) & (
  All e #i. In_V_2(e) @ i
  ==>
  ( (Ex #j. In_A_1(e)@j & j<i)
  ) ) "


axiom Equality:
"All x y #i. Eq(x,y) @i ==> x = y"

axiom OnlyOneVotPerVoter:
"not (Ex e1 e2 V #i #j. Signature(e1,V) @i & Signature(e2,V)@j & not(#i = #j) )"

lemma elligibility:
  " 
  All v #j.
  VotePublished (v) @ j
  ==> 
  ( ( Ex r b td V #i.  Signature( blind( tdcommit(v,r,td) ,b) ,V) @ i & #i < #j  )  )"

lemma test1:
  exists-trace
  " Ex v r b td V #i #j. VotePublished (v) @ #i & Signature( blind( tdcommit(v,r,td) ,b) ,V) @ j "

lemma test11:
  exists-trace
  " Ex v#i #j. VotePublished(v)@i & Voted(v)@j "

lemma test12:
  " 
  All v #j.
  VotePublished (v) @ j
  ==> 
  ( (Ex  #i.  Voted(v) @ i & #i < #j  )   )"

end
