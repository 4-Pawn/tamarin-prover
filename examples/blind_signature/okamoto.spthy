theory Blind_Signature
begin

/*
 * Protocol: Okamoto	
 * Modeler: 	
 * Date: 	
 * Source:	
 *
 * Status: 	
 */

/* We formalize the following protocol

  protocol FOO {
    Phase 1:
    1. V -> A: sign(blind(tdcommit(vote,r),b,td),skV)
    2. A -> V: sign(blind(tdcommit(vote,r),b,td),skA)
    Phase 2:
    3. V -> C: { V,sign(tdcommit(vote,r,td),skA) }pkC
    Phase 3
    5. V -> T: { vote, r, tdcommit(vote,r,td) }pkT
    6. T -> Pub: vote
  }
*/



builtins: asymmetric-encryption

functions: blind/2, sign/2, unblind/2, open/2, tdcommit/3, checksign/2, f/4, pk/1

equations: checksign( sign(m,sk), pk(sk) ) = m,
           unblind( blind(m,r), r ) = m,
           unblind( sign( blind(m,r), sk), r ) = sign(m,sk),
           open( tdcommit(m,r,td), r ) = m,
           tdcommit( m2,f(m1,r,td,m2), r ) = tdcommit(m1,r,td)


// Public key infrastructure
rule Register_Voter_pk:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk($V, ~ltkV), !Pk($V, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Collect_pk:
  [ Fr(~ltkC) ] --[ ]-> [ !CollectLtk($C, ~ltkC), !CollectPk($C, pk(~ltkC)), Out(pk(~ltkC)) ]

rule Register_Admin_pk:
  [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(pk(~ltkA)) ]

rule Register_Timeliness_pk:
  [ Fr(~ltkT) ] --[ ]-> [ !TLtk($T, ~ltkT), !TPk($T, pk(~ltkT)), Out(pk(~ltkT)) ]

rule Reveal_Voter_ltk:
  [ !Ltk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Collect_ltk:
  [ !CollectLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Adminltk:
  [ !AdminLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Timeliness_ltk:
  [ !TLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]


rule V_1:
  let m1 = sign (blind( tdcommit(~vote, ~r, ~td), ~b), ltkV)
  in
    [ Fr( ~vote ), Fr( ~r ), Fr( ~b ), Fr(~td), !Ltk( $V, ltkV ) ]
  --[ Elligible (~vote)]->
    [ Out( m1 ), St_V_1( $V, ~vote, ~r, ~b, ~td ) ]

rule A_1:
  let rm1 = sign (blind( tdcommit(~vote, ~r, ~td), ~b), ltkV)
      im1 = checksign( rm1 , pk(ltkV) )
      sm1 = sign ( im1 , ltkA )
  in
    [ In( rm1 ), !AdminLtk( $A, ltkA ), !Pk( $V, pk(ltkV) ) ]
  --[ Signature (~vote), Antiloop (sm1) ]->
    [ Out( sm1 ) ]

rule V_2:
  let m2 = sign( blind( tdcommit(vote, ~r, ~td ), ~b) , ltkA )
  in
    [ In( m2 ), St_V_1( $V, vote, ~r, ~b, ~td), !CollectPk( $C, pkC ), !AdminPk( $A, pk(ltkA) ) ]
  --[ ]->
    [ Out( aenc{ $V, unblind( m2, ~b ) }pkC ), St_V_2( $V, $A, vote, ~r, ~td) ]

rule C_1:
  let m = sign(tdcommit(~vote,~r,~td),ltkA)
  in
    [ In( aenc{ $V, m }pk(skC) ), !AdminPk( $A, pk(ltkA) ), !CollectLtk( $C, skC )]
  --[ Checksign(~vote)]->
    [ Out (tdcommit(~vote,~r,~td)), St_C_1($C, $A, $V, m ) ]

rule V_3:
    [ St_V_2( V, A, vote, ~r, ~td), !TPk( $T, pkT ) ]
  --[ ]->
    [ Out( aenc{ vote, ~r, tdcommit(vote,~r,~td) }pkT) ]

rule T_1:
    [ Private_Channel( aenc{ vote, ~r, tdcommit(vote,~r,td)}pkT ), In( tdcommit(vote2,~r2,td2) ), !Pk( $T, pkT ) ]
  --[ Verifycorrectness(vote,vote2),Voted (vote)]->
    [ Out(vote) ]


lemma elligibility:
  " // Voted(c)=>Elligible(c) before
  All vote #j.
  Voted(vote) @ j
  ==> 
  ( ( Ex #i.  Elligible(vote) @ i & #i < #j )  | (Ex #k A. RevLtk( A ) @ k ) )"
lemma test1:
  exists-trace
  " Ex k #i #j. Elligible (k) @ #i & Signature(k) @ j "

lemma test2:
  exists-trace
  " Ex k #i #j. Elligible (k) @ #i & Checksign(k) @ j "

lemma test3:
  exists-trace
  " Ex k #i #j. Elligible (k) @ #i & Voted(k) @ j "

axiom antiloop:
  "All mi mj #i #j.  Antiloop (mi)@i & Antiloop (mj)@j ==> (#i = #j) & (mi = mj)  "


end
