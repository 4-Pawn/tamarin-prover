theory Blind_Signature
begin

/*
 * Protocol: Okamoto	
 * Modeler: 	
 * Date: 	
 * Source:	
 *
 * Status: 	
 */

/* We formalize the following protocol

  protocol FOO {
    Phase 1:
    1. V -> A: sign(blind(tdcommit(vote,r,td),b),skV)
    2. A -> V: sign(blind(tdcommit(vote,r,td),b),skA)
    Phase 2:
    3. V -> C: Private:< V,sign(tdcommit(vote,r,td),skA)>
    Phase 3
    5. V -> T: { vote, r, tdcommit(vote,r,td) }pkT
    6. T -> Pub: vote
  }
*/

functions: blind/2, sign/2, unblind/2, open/2, tdcommit/3, checksign/2, f/4, pk/1

equations: checksign( sign(m,sk), pk(sk) ) = m,
           unblind( blind(m,b), b ) = m,
           unblind( sign( blind(m,b), sk), b ) = sign(m,sk),
           open( tdcommit(m,r,td), r ) = m,
           tdcommit( m2,f(m1,r,td,m2), td ) = tdcommit(m1,r,td),
           open( tdcommit(m1,r,td), f(m1,r,td,m2) )=m2,
           f(m1, f (m, r, td, m1), td, m2) = f (m, r, td, m2)    //The two last rules are needed for the convergence


// Public key infrastructure
rule Register_Voter_pk:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk($V, ~ltkV), !Pk($V, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Collect_pk:
  [ Fr(~ltkC) ] --[ ]-> [ !CollectLtk($C, ~ltkC), !CollectPk($C, pk(~ltkC)), Out(pk(~ltkC)) ]

rule Register_Admin_pk:
  [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(pk(~ltkA)) ]

rule Register_Timeliness_pk:
  [ Fr(~ltkT) ] --[ ]-> [ !TLtk($T, ~ltkT), !TPk($T, pk(~ltkT)), Out(pk(~ltkT)) ]

rule Reveal_Voter_ltk:
  [ !Ltk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Collect_ltk:
  [ !CollectLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Adminltk:
  [ !AdminLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Timeliness_ltk:
  [ !TLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]


rule V_1:
  let m1 = sign (blind( tdcommit(~vote, ~r, ~td), ~b), ltkV)
  in
    [ Fr( ~vote ), Fr( ~r ), Fr( ~b ), Fr(~td), !Ltk( $V, ltkV ) ]
  --[ OUT_V( m1)]->
    [ Out( m1 ), St_V_1( $V, ~vote, ~r, ~b, ~td ) ]

rule A_1:
  let rm = sign (blind( tdcommit(vote, r, td), b), ltkV)
      sm = sign (blind( tdcommit(vote, r, td), b), ltkA )
  in
    [ In( rm ), !AdminLtk( $A, ltkA ), !Pk( $V, pk(ltkV) ) ]
  --[ Signature (vote), IN_A_v( vote, rm) ]->
    [ Out( sm ) ]

rule V_2:
  let rm = sign( blind( tdcommit(vote, r, td ), b), ltkA )
      sm = sign( tdcommit(vote, r, td ), ltkA )
  in
    [ In( m ), St_V_1( V, vote, r, b, td), !CollectPk( $C, pkC ), !AdminPk( $A, pk(ltkA) ) ]
  --[ ]->
    [ Private_Channel_1( V, sm ), St_V_2( V, $A, vote, r, td) ]

rule C_1:
  let m = sign(tdcommit(vote,r,td),ltkA)
  in
    [ Private_Channel_1( V, m), !AdminPk( $A, pk(ltkA) ), !CollectLtk( $C, skC )]
  --[ Checksign(vote)]->
    [ Out ( tdcommit( vote, r, td ) ), St_C_1( $C, $A, V, m ) ]

rule V_3:
    [ St_V_2( V, A, vote, r, td), !TPk( $T, pkT ) ]
  --[ ]->
    [ Private_Channel_2( vote, r, tdcommit(vote,r,td) ) ]

rule T_1:
    [ Private_Channel_2(vote, r, tdcommit(vote,r,td) ), In( tdcommit(vote2,r2,td2) ), !Pk( $T, pkT ) ]
  --[ Verifycorrectness(vote,vote2),Voted (vote)]->
    [ Out(vote) ]


// Avoid cycling with A_1
lemma types [typing]:
  " (All v m #i.
       IN_A_v( v, m) @ i
       ==>
       ( (Ex #j. KU(v) @ j & j < i)
       | (Ex #j V. RevLtk(V) @ j)
       | (Ex #j. OUT_V( m) @ j)
       )
    )"


lemma elligibility:
  " 
  All vote #j.
  Voted(vote) @ j
  ==> 
  ( ( Ex #i.  Signature(vote) @ i & #i < #j )  | (Ex #k A. RevLtk( A ) @ k ) )"

lemma test1:
  exists-trace
  " Ex k #i #j. Voted (k) @ #i & Signature(k) @ j "


end
