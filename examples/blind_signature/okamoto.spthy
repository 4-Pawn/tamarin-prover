theory Blind_Signature
begin

/*
 * Protocol: Okamoto	
 * Modeler: 	
 * Date: 	
 * Source:	
 *
 * Status: 	
 */

/* We formalize the following protocol

  protocol FOO {
    Phase 1:
    1. V -> A: sign(blind(tdcommit(vote,r),b,td),skV)
    2. A -> V: sign(blind(tdcommit(vote,r),b,td),skA)
    Phase 2:
    3. V -> C: { V,sign(tdcommit(vote,r,td),skA) }pkC
    Phase 3
    5. V -> T: { vote, r, tdcommit(vote,r,td) }pkT
    6. T -> Pub: vote
  }
*/

functions: blind/2, sign/2, unblind/2, open/2, tdcommit/3, checksign/2, f/3, pk/1

equations: checksign( sign(m,sk), pk(sk) ) = m,
           unblind( blind(m,b), b ) = m,
           unblind( sign( blind(m,b), sk), b ) = sign(m,sk),
           open( tdcommit(m,r,td), r ) = m,
           tdcommit( m2,f(m1,r,m2), td ) = tdcommit(m1,r,td)


// Public key infrastructure
rule Register_Voter_pk:
  [ Fr(~ltkV) ] --[ ]-> [ !Ltk($V, ~ltkV), !Pk($V, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Collect_pk:
  [ Fr(~ltkC) ] --[ ]-> [ !CollectLtk($C, ~ltkC), !CollectPk($C, pk(~ltkC)), Out(pk(~ltkC)) ]

rule Register_Admin_pk:
  [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(pk(~ltkA)) ]

rule Register_Timeliness_pk:
  [ Fr(~ltkT) ] --[ ]-> [ !TLtk($T, ~ltkT), !TPk($T, pk(~ltkT)), Out(pk(~ltkT)) ]

rule Reveal_Voter_ltk:
  [ !Ltk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Collect_ltk:
  [ !CollectLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Adminltk:
  [ !AdminLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

rule Reveal_Timeliness_ltk:
  [ !TLtk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]


rule V_1:
  let m1 = sign (blind( tdcommit(~vote, ~r, ~td), ~b), ltkV)
  in
    [ Fr( ~vote ), Fr( ~r ), Fr( ~b ), Fr(~td), !Ltk( $V, ltkV ) ]
  --[ Elligible (~vote)]->
    [ Out( m1 ), St_V_1( $V, ~vote, ~r, ~b, ~td ) ]

rule A_1:
  let rm = sign (blind( tdcommit(vote, r, td), b), ltkV)
      sm = sign (blind( tdcommit(vote, r, td), b), ltkA )
  in
    [ In( rm ), !AdminLtk( $A, ltkA ), !Pk( $V, pk(ltkV) ) ]
  --[ Signature (vote), Antiloop (sm) ]->
    [ Out( sm ) ]
/*
rule V_2:
  let rm = sign( blind( tdcommit(vote, r, td ), b), ltkA )
      sm = sign( tdcommit(vote, r, td ), ltkA )
  in
    [ In( m ), St_V_1( V, vote, r, b, td), !CollectPk( $C, pkC ), !AdminPk( $A, pk(ltkA) ) ]
  --[ ]->
    [ Private_Channel_1( V, sm ), St_V_2( V, $A, vote, r, td) ]

rule C_1:
  let m = sign(tdcommit(vote,r,td),ltkA)
  in
    [ Private_Channel_1( V, m), !AdminPk( $A, pk(ltkA) ), !CollectLtk( $C, skC )]
  --[ Checksign(vote)]->
    [ Out ( tdcommit( vote, r, td ) ), St_C_1( $C, $A, V, m ) ]

rule V_3:
    [ St_V_2( V, A, vote, r, td), !TPk( $T, pkT ) ]
  --[ ]->
    [ Private_Channel_2( vote, r, tdcommit(vote,r,td) ) ]

rule T_1:
    [ Private_Channel_2(vote, r, tdcommit(vote,r,td) ), In( tdcommit(vote2,r2,td2) ), !Pk( $T, pkT ) ]
  --[ Verifycorrectness(vote,vote2),Voted (vote)]->
    [ Out(vote) ]
*/
/*
lemma elligibility:
  " // Voted(c)=>Elligible(c) before
  All vote #j.
  Voted(vote) @ j
  ==> 
  ( ( Ex #i.  Elligible(vote) @ i & #i < #j )  | (Ex #k A. RevLtk( A ) @ k ) )"
lemma test1:
  exists-trace
  " Ex k #i #j. Elligible (k) @ #i & Signature(k) @ j "

lemma test2:
  exists-trace
  " Ex k #i #j. Elligible (k) @ #i & Checksign(k) @ j "

lemma test3:
  exists-trace
  " Ex k #i #j. Elligible (k) @ #i & Voted(k) @ j "
*/
axiom antiloop:
  "All mi mj #i #j.  Antiloop (mi)@i & Antiloop (mj)@j ==> (#i = #j) & (mi = mj)  "


end
