theory Chaum
begin

builtins: asymmetric-encryption

/*
 * Protocol: Chaum's On-line Protocol
 * Modeler: 	
 * Date: 	
 * Source:	
 *
 * Status: work	in progress
 */

functions: blind/2, sign/2, unblind/2, getmess/1, checksign/2
equations: getmess(sign(m,r)) = m, checksign(sign(m,k),pk(k)) = m, unblind(blind(m,r),r) = m , unblind(sign(blind(m,r),k),r) = sign(m,k)

 

// Public key infrastructure

rule Register_pk:
  [ Fr(~ltkA) ]
  -->
  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), Out(pk(~ltkA)) ]

rule Reveal_ltk:
  [ !Ltk(A, ltkA) ] --[ RevLtk(A) ]-> [ Out(ltkA) ]

/* We formalize the following protocol

  protocol Chaum {
    Withdrawal phase
    1. C -> B: <C, b=blind(x,r)>
    2. C <- B: sign(b,skB) + B:Debit + C:Check sign

    Payment and deposit phase
    3. C -> S: aenc{( x, bs )}pkS 
    4. B <- S: (x, sign(x,skB)) + check signature + check not yet deposited
  }
*/


/*Withdrawal Phase*/

rule C_1:
  let bld = blind(~x,~r)
  in
    [ Fr(~x), Fr(~r) ]
  --[ ]->
    [ Out( < $C, bld > ), St_C_1($C, ~x, ~r )]

rule B_1:
    [ In( <C, blind(~x,r)> ), !Ltk($B, ltkB) ]
  --[ Withdraw(~x) ]->
    [ St_B_1( $B, C, blind(~x,r) ), Out( sign( blind(~x,r), ltkB) ) ]

rule C_2:
  let bld = blind(x,r)
      bs = sign(bld,ltkB)
  in
    [ St_C_1(C, x, r ), In( bs ), !Pk(B, pk(ltkB)) ]
  --[ ]->
    [ St_C_2(C, x, r, bs ) ]

/* Payment and deposit phase */

rule C_3:
  let bld = blind(x,r)
      bs = sign(bld,ltkB)
      xs = sign(x,ltkB)
  in
    [ St_C_2(C, x, r, bs ), !Pk(B, pk(ltkB)), !Pk($S, pkS) ]
  --[   ]->
    [ Out( aenc{'1', x, xs }pkS ) ]

rule S_1:
  let xs = sign(x,ltkB)
  in
    [ !Ltk($S, ltkS), !Pk(B, pk(ltkB)), In( aenc{'1', x, xs }pk(ltkS)  ) ]
  --[ Spend (x) ]->
    [ Out( <x, xs> ) ]

rule B_2:
  let xs = sign(x,ltkB)
      bld = blind(x,r)
  in
    [ St_B_1( B, C, bld ), In(<x, xs> ) ]
  --[ ]->
    [ ]

lemma unforgeability:
  " // Spend(c)=>withdraw(c) before
  All c #j.
  Spend(c) @ j
  ==> 
  ( ( Ex #i.  Withdraw(c) @ i & #i < #j )  | (Ex #k A. RevLtk( A ) @ k ) )
  "

lemma doublespend:
  " not( Ex c #j #k. Spend(c) @ j & Spend(c) @ k & not (#j = #k) ) "

end

