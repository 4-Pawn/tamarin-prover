theory manual_3_key_agreement_proof_GDH_List begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman, multiset
functions: fst/1, g/0, list_to_mset/1, nil/0, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2

// looping facts with injective instances: StartGroup/3

axiom InEq_not_eq:
  "¬(∃ x #i. Ineq( x, x ) @ #i)"
  // safety formula

axiom IsLast:
  "∀ x A #i. (IsLast( x, A ) @ #i) ⇒ (∃ #j. Last( x, A ) @ #j)"

axiom MembersUnique:
  "∀ x A #i #j.
    ((Mem( x, A ) @ #i) ∧ (Mem( x, A ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) ChooseParticipants1:
   [ Fr( ~gid ) ]
  --[ Mem( ~gid, $I ), InEq( $I, $R ), Last( ~gid, $R ) ]->
   [ StartGroup( ~gid, $I, <$R, nil> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ChooseParticipants2:
   [ StartGroup( ~gid, $I, responders ) ]
  --[ Mem( ~gid, $R ), StepC( ) ]->
   [ StartGroup( ~gid, $I, <$R, responders> ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) StartGroup1:
   [ StartGroup( ~gid, $I, responders ) ]
  --[ Step( ), Started( ~gid, $I ) ]->
   [
   Initiator1( ~gid, $I, responders ),
   StartResponders( ~gid, $I, responders, <$I, nil> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) StartGroup2:
   [ StartResponders( ~gid, $I, <$R, notstarted>, started ) ]
  --[ Step( ), StepS( ), Started( ~gid, $R ) ]->
   [
   Responder1( ~gid, $R, $I, started, notstarted ),
   StartResponders( ~gid, $I, notstarted, <$R, started> )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

lemma startTest3:
  exists-trace
  "∃ #j1 #j2 #j3 A B C id.
    (((((Started( id, A ) @ #j1) ∧ (Started( id, B ) @ #j2)) ∧
       (Started( id, C ) @ #j3)) ∧
      (¬(A = B))) ∧
     (¬(A = C))) ∧
    (¬(B = C))"
/*
guarded formula characterizing all satisfying traces:
"∃ #j1 #j2 #j3 A B C id.
  (Started( id, A ) @ #j1) ∧
  (Started( id, B ) @ #j2) ∧
  (Started( id, C ) @ #j3)
 ∧
  (¬(A = B)) ∧ (¬(A = C)) ∧ (¬(B = C))"
*/
by sorry

lemma startTest4:
  exists-trace
  "∃ #j1 #j2 #j3 #j4 A B C D id.
    (((((((((Started( id, A ) @ #j1) ∧ (Started( id, B ) @ #j2)) ∧
           (Started( id, C ) @ #j3)) ∧
          (Started( id, D ) @ #j4)) ∧
         (¬(A = B))) ∧
        (¬(A = C))) ∧
       (¬(B = C))) ∧
      (¬(A = D))) ∧
     (¬(B = D))) ∧
    (¬(C = D))"
/*
guarded formula characterizing all satisfying traces:
"∃ #j1 #j2 #j3 #j4 A B C D id.
  (Started( id, A ) @ #j1) ∧
  (Started( id, B ) @ #j2) ∧
  (Started( id, C ) @ #j3) ∧
  (Started( id, D ) @ #j4)
 ∧
  (¬(A = B)) ∧
  (¬(A = C)) ∧
  (¬(B = C)) ∧
  (¬(A = D)) ∧
  (¬(B = D)) ∧
  (¬(C = D))"
*/
by sorry

rule (modulo E) Initiator:
   [ Initiator1( ~gid, $I, <$R, other> ), Fr( ~ei ) ]
  --[ Step( ) ]->
   [
   Initiator2( ~gid, ~ei, $I, <$R, other> ),
   AuthOut( <~gid, $I, $I, g> ), AuthOut( <~gid, $I, $R, g^~ei> ),
   Out( g^~ei )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Initiator2:
   [
   Initiator2( ~gid, ~ei, $I, responders ),
   AuthOut( <~gid, $S, $I, g^y> )
   ]
  --[
  Key( ~gid, $I, ($I+list_to_mset(responders)) ), IsLast( ~gid, $S ),
  Step( )
  ]->
   [ ]

  /*
  rule (modulo AC) Initiator2:
     [
     Initiator2( ~gid, ~ei, $I, responders ),
     AuthOut( <~gid, $S, $I, z> )
     ]
    --[
    Key( ~gid, $I, ($I+list_to_mset(responders)) ), IsLast( ~gid, $S ),
    Step( )
    ]->
     [ ]
    variants (modulo AC)
    1. z     = g^y.8
    
    2. z     = g
  */

rule (modulo E) Responder1:
   [
   Responder1( ~gid, $R, $I, <$S, before_missing>, after ), Fr( ~ec ),
   AuthOut( <~gid, $S, $S, g^y> )
   ]
  --[ Step( ) ]->
   [
   Responder2( ~gid, ~ec, $R, $I, $S, before_missing, <$S, nil>, after
   ),
   AuthOut( <~gid, $R, $S, g^y^~ec> )
   ]

  // loop breaker: [2]
  /*
  rule (modulo AC) Responder1:
     [
     Responder1( ~gid, $R, $I, <$S, before_missing>, after ), Fr( ~ec ),
     AuthOut( <~gid, $S, $S, z> )
     ]
    --[ Step( ) ]->
     [
     Responder2( ~gid, ~ec, $R, $I, $S, before_missing, <$S, nil>, after
     ),
     AuthOut( <~gid, $R, $S, z.1> )
     ]
    variants (modulo AC)
    1. ~ec   = ~ec.11
       z     = g^y.11
       z.1   = g^(~ec.11*y.11)
    
    2. ~ec   = ~ec.11
       z     = g
       z.1   = g^~ec.11
    
    3. ~ec   = ~x.11
       z     = g^inv(~x.11)
       z.1   = g
    
    4. ~ec   = ~x.11
       z     = g^inv((~x.11*x.12))
       z.1   = g^inv(x.12)
    
    5. ~ec   = ~x.11
       z     = g^(x.12*inv(~x.11))
       z.1   = g^x.12
    
    6. ~ec   = ~x.11
       z     = g^(x.13*inv((~x.11*x.12)))
       z.1   = g^(x.13*inv(x.12))
    // loop breaker: [2]
  */

rule (modulo E) Responder2:
   [
   Responder2( ~gid, ~ec, $R, $I, $S, <$KR, before_missing>,
               before_rcvd, after
   ),
   AuthOut( <~gid, $S, $KR, g^y> )
   ]
  --[ Loop( ~gid, $R, $S, $KR ), StepR( ) ]->
   [
   Responder2( ~gid, ~ec, $R, $I, $S, before_missing,
               <$KR, before_rcvd>, after
   ),
   AuthOut( <~gid, $R, $KR, g^y^~ec> )
   ]

  // loop breakers: [0,1]
  /*
  rule (modulo AC) Responder2:
     [
     Responder2( ~gid, ~ec, $R, $I, $S, <$KR, before_missing>,
                 before_rcvd, after
     ),
     AuthOut( <~gid, $S, $KR, z> )
     ]
    --[ Loop( ~gid, $R, $S, $KR ), StepR( ) ]->
     [
     Responder2( ~gid, ~ec, $R, $I, $S, before_missing,
                 <$KR, before_rcvd>, after
     ),
     AuthOut( <~gid, $R, $KR, z.1> )
     ]
    variants (modulo AC)
    1. ~ec   = ~ec.13
       z     = g^y.13
       z.1   = g^(~ec.13*y.13)
    
    2. ~ec   = ~ec.13
       z     = g
       z.1   = g^~ec.13
    
    3. ~ec   = ~x.13
       z     = g^inv(~x.13)
       z.1   = g
    
    4. ~ec   = ~x.13
       z     = g^inv((~x.13*x.14))
       z.1   = g^inv(x.14)
    
    5. ~ec   = ~x.13
       z     = g^(x.14*inv(~x.13))
       z.1   = g^x.14
    
    6. ~ec   = ~x.13
       z     = g^(x.15*inv((~x.13*x.14)))
       z.1   = g^(x.15*inv(x.14))
    // loop breakers: [0,1]
  */

rule (modulo E) Responder3:
   [
   Responder2( ~gid, ~ec, $R, $I, $S, nil, before_rcvd,
               <$KR, after_missing>
   ),
   AuthOut( <~gid, $S, $R, g^y> )
   ]
  --[ InEq( <$KR, after_missing>, nil ), Step( ) ]->
   [
   Responder3( ~gid, ~ec, $R, $I, before_rcvd, <$KR, after_missing> ),
   AuthOut( <~gid, $R, $KR, g^y^~ec> ), AuthOut( <~gid, $R, $R, g^y> )
   ]

  // loop breaker: [1]
  /*
  rule (modulo AC) Responder3:
     [
     Responder2( ~gid, ~ec, $R, $I, $S, nil, before_rcvd,
                 <$KR, after_missing>
     ),
     AuthOut( <~gid, $S, $R, z> )
     ]
    --[ InEq( <$KR, after_missing>, nil ), Step( ) ]->
     [
     Responder3( ~gid, ~ec, $R, $I, before_rcvd, <$KR, after_missing> ),
     AuthOut( <~gid, $R, $KR, z.1> ), AuthOut( <~gid, $R, $R, z> )
     ]
    variants (modulo AC)
    1. ~ec   = ~ec.12
       z     = g^y.12
       z.1   = g^(~ec.12*y.12)
    
    2. ~ec   = ~ec.12
       z     = g
       z.1   = g^~ec.12
    
    3. ~ec   = ~x.12
       z     = g^inv(~x.12)
       z.1   = g
    
    4. ~ec   = ~x.12
       z     = g^inv((~x.12*x.13))
       z.1   = g^inv(x.13)
    
    5. ~ec   = ~x.12
       z     = g^(x.13*inv(~x.12))
       z.1   = g^x.13
    
    6. ~ec   = ~x.12
       z     = g^(x.14*inv((~x.12*x.13)))
       z.1   = g^(x.14*inv(x.13))
    // loop breaker: [1]
  */

rule (modulo E) Responder3_last:
   [
   Responder2( ~gid, ~ec, $R, $I, $S, nil, before_rcvd, nil ),
   AuthOut( <~gid, $S, $R, g^y> )
   ]
  --[ Key( ~gid, $R, ($R+list_to_mset(before_rcvd)) ), Step( ) ]->
   [ ]

  /*
  rule (modulo AC) Responder3_last:
     [
     Responder2( ~gid, ~ec, $R, $I, $S, nil, before_rcvd, nil ),
     AuthOut( <~gid, $S, $R, z> )
     ]
    --[ Key( ~gid, $R, ($R+list_to_mset(before_rcvd)) ), Step( ) ]->
     [ ]
    variants (modulo AC)
    1. z     = g^y.9
    
    2. z     = g
  */

rule (modulo E) Responder4:
   [
   Responder3( ~gid, ~ec, $R, $I, p1, p2 ),
   AuthOut( <~gid, $S, $R, g^y> )
   ]
  --[
  Key( ~gid, $R, ($R+list_to_mset(p1)+list_to_mset(p2)) ),
  IsLast( ~gid, $S ), Step( )
  ]->
   [ ]

  /*
  rule (modulo AC) Responder4:
     [
     Responder3( ~gid, ~ec, $R, $I, p1, p2 ),
     AuthOut( <~gid, $S, $R, z> )
     ]
    --[
    Key( ~gid, $R, ($R+list_to_mset(p1)+list_to_mset(p2)) ),
    IsLast( ~gid, $S ), Step( )
    ]->
     [ ]
    variants (modulo AC)
    1. z     = g^y.10
    
    2. z     = g
  */

lemma test2:
  exists-trace
  "∃ #j1 #j2 A B id.
    ((Key( id, A, (A+list_to_mset(<B, nil>)) ) @ #j1) ∧
     (Key( id, B, (B+list_to_mset(<A, nil>)) ) @ #j2)) ∧
    (¬(A = B))"
/*
guarded formula characterizing all satisfying traces:
"∃ #j1 #j2 A B id.
  (Key( id, A, (A+list_to_mset(<B, nil>)) ) @ #j1) ∧
  (Key( id, B, (B+list_to_mset(<A, nil>)) ) @ #j2)
 ∧
  ¬(A = B)"
*/
by sorry // removed

lemma test3a:
  exists-trace
  "∃ #j1 #j2 #j3 A B C id.
    (((((Key( id, A, (A+list_to_mset(<C, B, nil>)) ) @ #j1) ∧
        (Key( id, B, (B+list_to_mset(<A, C, nil>)) ) @ #j2)) ∧
       (Key( id, C, (C+list_to_mset(<A, nil>)+list_to_mset(<B, nil>))
        ) @ #j3)) ∧
      (¬(A = B))) ∧
     (¬(A = C))) ∧
    (¬(B = C))"
/*
guarded formula characterizing all satisfying traces:
"∃ #j1 #j2 #j3 A B C id.
  (Key( id, A, (A+list_to_mset(<C, B, nil>)) ) @ #j1) ∧
  (Key( id, B, (B+list_to_mset(<A, C, nil>)) ) @ #j2) ∧
  (Key( id, C, (C+list_to_mset(<A, nil>)+list_to_mset(<B, nil>))
   ) @ #j3)
 ∧
  (¬(A = B)) ∧ (¬(A = C)) ∧ (¬(B = C))"
*/
simplify
solve( Key( id, A, (A+list_to_mset(<C, B, nil>)) ) @ #j1 )
  case Initiator2
  solve( Initiator2( ~gid, ~ei, $I, <C, B, nil> ) ▶₀ #j1 )
    case Initiator
    solve( StartGroup( ~gid, $I.1, <$R, B, nil> ) ▶₀ #vr.1 )
      case ChooseParticipants2
      solve( StartGroup( ~gid, $I.1, <B, nil> ) ▶₀ #vr.2 )
        case ChooseParticipants1
        solve( Key( ~gid, $S, ($S+list_to_mset(<$I, $R, nil>)) ) @ #j2 )
          case Initiator2
          by sorry
        next
          case Responder3_last
          solve( Responder2( ~gid, ~ec, $S, $I.1, $S.1, nil, <$I, $R, nil>,
                             nil
                 ) ▶₀ #j2 )
            case Responder2
            solve( Responder2( ~gid, ~ec, $S, $I.1, $S.1, <$I, nil>, <$R, nil>,
                               nil
                   ) ▶₀ #vr.3 )
              case Responder1
              solve( StartResponders( ~gid, $I.1, <$S, nil>, <$R, $I, nil>
                     ) ▶₀ #vr.5 )
                case StartGroup2
                solve( StartResponders( ~gid, $I.1, <$R, $S, nil>, <$I, nil>
                       ) ▶₀ #vr.6 )
                  case StartGroup1
                  solve( StartGroup( ~gid, $I, <$R, $S, nil> ) ▶₀ #vr.7 )
                    case ChooseParticipants2
                    solve( Key( ~gid, $R,
                                ($R+list_to_mset(<$I, nil>)+list_to_mset(<$S, nil>))
                           ) @ #j3 )
                      case Responder4_case_1
                      solve( Responder3( ~gid, ~ec.1, $R, $I.1, <$I, nil>, <$S, nil>
                             ) ▶₀ #j3 )
                        case Responder3
                        solve( Responder2( ~gid, ~ec.1, $R, $I.1, $S.1, nil, <$I, nil>,
                                           <$S, nil>
                               ) ▶₀ #vr.7 )
                          case Responder1
                          solve( StartResponders( ~gid, $I.1, <$R, $S, nil>, <$I, nil>
                                 ) ▶₀ #vr.9 )
                            case StartGroup1
                            solve( StartGroup( ~gid, $I, <$R, $S, nil> ) ▶₀ #vr.10 )
                              case ChooseParticipants2
                              solve( AuthOut( <~gid, $I, $I, z.9> ) ▶₂ #vr.8 )
                                case Initiator_case_1
                                solve( StartGroup( ~gid, $I, <$R.1, other> ) ▶₀ #vr.10 )
                                  case ChooseParticipants2
                                  solve( StartGroup( ~gid, $I, other ) ▶₀ #vr.11 )
                                    case ChooseParticipants1
                                    solve( AuthOut( <~gid, $I, $R, z.7> ) ▶₁ #vr.7 )
                                      case Initiator
                                      solve( StartGroup( ~gid, $I, <$R, other> ) ▶₀ #vr.10 )
                                        case ChooseParticipants2
                                        solve( AuthOut( <~gid, $R, $R, z.5> ) ▶₂ #vr.4 )
                                          case Initiator_case_1
                                          by sorry
                                        next
                                          case Initiator_case_2
                                          by sorry
                                        next
                                          case Responder1
                                          by sorry
                                        next
                                          case Responder2
                                          by sorry
                                        next
                                          case Responder3_case_1
                                          by sorry
                                        next
                                          case Responder3_case_2
                                          solve( Responder2( ~gid, ~ec.2, $R, $I.1, $S.1, nil,
                                                             before_rcvd, <$KR, after_missing>
                                                 ) ▶₀ #vr.9 )
                                            case Responder1
                                            solve( StartResponders( ~gid, $I.1,
                                                                    <$R, $KR, after_missing>,
                                                                    <$S.1, nil>
                                                   ) ▶₀ #vr.11 )
                                              case StartGroup1
                                              solve( StartGroup( ~gid, $I.1,
                                                                 <$R, $KR, after_missing>
                                                     ) ▶₀ #vr.12 )
                                                case ChooseParticipants2
                                                solve( AuthOut( <~gid, $R, $KR, z.1> ) ▶₁ #j2 )
                                                  case Initiator_case_1
                                                  by contradiction // from formulas
                                                next
                                                  case Initiator_case_2
                                                  by sorry
                                                next
                                                  case Responder1
                                                  by sorry
                                                next
                                                  case Responder2
                                                  by sorry
                                                next
                                                  case Responder3_case_1
                                                  solve( Responder2( ~gid, ~ec.2, $R, $I.1, $S, nil,
                                                                     before_rcvd,
                                                                     <$KR, after_missing>
                                                         ) ▶₀ #vr.9 )
                                                    case Responder1
                                                    solve( StartResponders( ~gid, $I.1,
                                                                            <$R, $KR, after_missing
                                                                            >,
                                                                            <$S, nil>
                                                           ) ▶₀ #vr.11 )
                                                      case StartGroup1
                                                      solve( StartGroup( ~gid, $S,
                                                                         <$R, $KR, after_missing>
                                                             ) ▶₀ #vr.12 )
                                                        case ChooseParticipants2
                                                        solve( AuthOut( <~gid, $R, $I, z.2>
                                                               ) ▶₁ #vr.3 )
                                                          case Initiator
                                                          by sorry
                                                        next
                                                          case Responder1
                                                          solve( StartResponders( ~gid, $I.1,
                                                                                  <$R, after>,
                                                                                  <$I, 
                                                                                   before_missing>
                                                                 ) ▶₀ #vr.10 )
                                                            case StartGroup1
                                                            solve( StartGroup( ~gid, $I, <$R, after>
                                                                   ) ▶₀ #vr.11 )
                                                              case ChooseParticipants2
                                                              solve( AuthOut( <~gid, $KR, $R, z.1>
                                                                     ) ▶₁ #j3 )
                                                                case Initiator_case_1
                                                                by contradiction // from formulas
                                                              next
                                                                case Initiator_case_2
                                                                by sorry
                                                              next
                                                                case Responder1
                                                                solve( StartResponders( ~gid, $I.1,
                                                                                        <$KR, after
                                                                                        >,
                                                                                        <$R, 
                                                                                         before_missing
                                                                                        >
                                                                       ) ▶₀ #vr.10 )
                                                                  case StartGroup1
                                                                  by sorry
                                                                next
                                                                  case StartGroup2
                                                                  solve( StartResponders( ~gid,
                                                                                          $I.1,
                                                                                          <$R, $KR, 
                                                                                           after>,
                                                                                          before_missing
                                                                         ) ▶₀ #vr.11 )
                                                                    case StartGroup1
                                                                    solve( StartGroup( ~gid, $I.1,
                                                                                       <$R, $KR, 
                                                                                        after>
                                                                           ) ▶₀ #vr.12 )
                                                                      case ChooseParticipants2
                                                                      solve( AuthOut( <~gid, $KR, 
                                                                                       $I, z>
                                                                             ) ▶₁ #j1 )
                                                                        case Initiator_case_1
                                                                        by contradiction
                                                                           // from formulas
                                                                      next
                                                                        case Initiator_case_2
                                                                        by sorry
                                                                      next
                                                                        case Responder1
                                                                        by sorry
                                                                      next
                                                                        case Responder2
                                                                        solve( Responder2( ~gid,
                                                                                           ~ec.2,
                                                                                           $KR,
                                                                                           $I.1, $S,
                                                                                           <$I, 
                                                                                            before_missing
                                                                                           >,
                                                                                           before_rcvd,
                                                                                           after
                                                                               ) ▶₀ #vr.9 )
                                                                          case Responder1
                                                                          solve( StartResponders( ~gid,
                                                                                                  $I.1,
                                                                                                  <
                                                                                                   $KR, 
                                                                                                   after
                                                                                                  >,
                                                                                                  <
                                                                                                   $S, 
                                                                                                   $I, 
                                                                                                   before_missing
                                                                                                  >
                                                                                 ) ▶₀ #vr.11 )
                                                                            case StartGroup2
                                                                            solve( StartResponders( ~gid,
                                                                                                    $I.1,
                                                                                                    <
                                                                                                     $S, 
                                                                                                     $KR, 
                                                                                                     after
                                                                                                    >,
                                                                                                    <
                                                                                                     $I, 
                                                                                                     before_missing
                                                                                                    >
                                                                                   ) ▶₀ #vr.12 )
                                                                              case StartGroup1
                                                                              solve( StartGroup( ~gid,
                                                                                                 $I,
                                                                                                 <
                                                                                                  $S, 
                                                                                                  $KR, 
                                                                                                  after
                                                                                                 >
                                                                                     ) ▶₀ #vr.13 )
                                                                                case ChooseParticipants2
                                                                                solve( StartGroup( ~gid,
                                                                                                   $I,
                                                                                                   <
                                                                                                    $KR, 
                                                                                                    after
                                                                                                   >
                                                                                       ) ▶₀ #vr.14 )
                                                                                  case ChooseParticipants1
                                                                                  SOLVED // trace found
                                                                                next
                                                                                  case ChooseParticipants2
                                                                                  by sorry
                                                                                qed
                                                                              qed
                                                                            next
                                                                              case StartGroup2
                                                                              by sorry
                                                                            qed
                                                                          qed
                                                                        next
                                                                          case Responder2
                                                                          by sorry
                                                                        qed
                                                                      next
                                                                        case Responder3_case_1
                                                                        by sorry
                                                                      next
                                                                        case Responder3_case_2
                                                                        by contradiction
                                                                           // from formulas
                                                                      qed
                                                                    qed
                                                                  next
                                                                    case StartGroup2
                                                                    by sorry
                                                                  qed
                                                                qed
                                                              next
                                                                case Responder2
                                                                by sorry
                                                              next
                                                                case Responder3_case_1
                                                                by sorry
                                                              next
                                                                case Responder3_case_2
                                                                by contradiction // from formulas
                                                              qed
                                                            qed
                                                          next
                                                            case StartGroup2
                                                            by sorry
                                                          qed
                                                        next
                                                          case Responder2
                                                          by sorry
                                                        next
                                                          case Responder3
                                                          by sorry
                                                        qed
                                                      qed
                                                    next
                                                      case StartGroup2
                                                      by sorry
                                                    qed
                                                  next
                                                    case Responder2
                                                    by sorry
                                                  qed
                                                next
                                                  case Responder3_case_2
                                                  by contradiction // from formulas
                                                qed
                                              qed
                                            next
                                              case StartGroup2
                                              by sorry
                                            qed
                                          next
                                            case Responder2
                                            by sorry
                                          qed
                                        qed
                                      qed
                                    next
                                      case Responder1
                                      by sorry
                                    next
                                      case Responder2
                                      by sorry
                                    next
                                      case Responder3
                                      by sorry
                                    qed
                                  next
                                    case ChooseParticipants2
                                    by sorry
                                  qed
                                qed
                              next
                                case Initiator_case_2
                                by sorry
                              next
                                case Responder1
                                by sorry
                              next
                                case Responder2
                                by sorry
                              next
                                case Responder3_case_1
                                by sorry
                              next
                                case Responder3_case_2
                                by sorry
                              qed
                            qed
                          next
                            case StartGroup2
                            by sorry
                          qed
                        next
                          case Responder2
                          by sorry
                        qed
                      qed
                    next
                      case Responder4_case_2
                      by sorry
                    qed
                  qed
                next
                  case StartGroup2
                  by sorry
                qed
              qed
            next
              case Responder2
              by sorry
            qed
          qed
        qed
      next
        case ChooseParticipants2
        by sorry
      qed
    qed
  qed
next
  case Responder3_last
  by sorry
qed

lemma test3:
  exists-trace
  "∃ #j A B C id.
    Key( id, C, (C+list_to_mset(<A, nil>)+list_to_mset(<B, nil>))
    ) @ #j"
/*
guarded formula characterizing all satisfying traces:
"∃ #j A B C id.
  (Key( id, C, (C+list_to_mset(<A, nil>)+list_to_mset(<B, nil>))
   ) @ #j)"
*/
by sorry

/* All well-formedness checks were successful. */

end