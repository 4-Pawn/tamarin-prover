theory Asokan_Ginzboorg_Multi
begin

builtins: multiset, symmetric-encryption, hashing, asymmetric-encryption        //, signing

functions: f/1 //key derivation function
         , one/0

// use this to simplify initially, restrict state space to single initial shared password
axiom Single_pw:
  "All #i #j pw1 pw2. Initpw(pw1) @ i & Initpw(pw2) @ j ==> #i = #j"

/* NEVER ACTUALLY USED THIS LEMMA
// only for the 'exists-trace' to remove some nonsense
axiom Single_pw_LeaderSend:
  "All #i #j pw1 pw2 e1 e2 sn1 sn2 shares1 shares2 recv1 recv2. 
             LeaderSend(pw1, e1, sn1, shares1, recv1) @i 
           & LeaderSend(pw2, e2, sn2, shares2, recv2) @j 
      ==> pw1 = pw2 & e1 = e2 & sn1 = sn2"
*/


// Arguments of InEq are not equal.
axiom InEq:
  "not (Ex #i x. InEq(x,x) @ i)"

// For each password only one group will be generated
axiom Single_group:
  "All #i #j pw e1 s1 e2 s2. LeaderInit(pw, e1, s1) @i & LeaderInit(pw, e2, s2) @j ==> #i = #j"

rule Initial_pw:
  [ Fr(~pw) ]
  --[ Initpw(~pw) ]->
  [ !Password(~pw) ]

rule Leader_1:
  [ !Password(pw), Fr(~e) , Fr(~sn) ]
  --[LeaderInit(pw, ~e, ~sn), SecretAsymmetricKey(~e) ]->
  [ Leader(pw, ~e, ~sn, ~sn, 'nil'), Out( senc(<'distAKey', pk(~e)>, pw) ) ]

rule Participant_i_1:
  [ !Password(pw), Fr(~ri), Fr(~si), In( senc(<'distAKey', pke>, pw) ) ]
  --[ParticipantI1(pw, ~ri, ~si, pke)]->
  [ Participant_i_1(pw, ~ri, ~si, pke), Out( senc(<'pwproof', aenc(<'skeyshare', ~ri, ~si>, pke)>, pw) ) ]

rule Leader_collect:
  [ Leader(pw, e, sn, shares, partners), In( senc(<'pwproof', aenc(<'skeyshare', ri, si>, pk(e))> , pw) ) ]
  --[ LeaderAdd(pw, e, shares, partners, ri, si) ]->
  [ Leader(pw, e, sn, shares + si, partners +ri) ]

rule Leader_done_collect:
  [ Leader(pw, e, sn, shares, partners) ]
  --[ LeaderDoneCollect(pw, e, shares, partners)
    , InEq(sn, shares) // this forces there to be at least 1 participant 
  ]->
  [ LeaderSend(pw, e, sn, shares, partners) ]

rule Leader_Send:
  [ LeaderSend(pw, e, sn, shares, partners + ri) ]
  --[ InEq('nil', ri), LeaderSend(pw, e, sn, shares, ri) ]->
  [ LeaderSend(pw, e, sn, shares, partners), Out( senc(<'distshare', shares>, ri) ) ]

rule Participant_i_accept:
  let allshares = shares + si
      K = f(allshares)
      H = h(allshares)
  in
  [ Participant_i_1(pw, ri, si, pke), In( senc(<'distshare', allshares>, ri) ) ]
  --[ Accept('participant', pw, pke, si, allshares, K) ]->
  [ Participant_i_Accepted(pw, pke, si, allshares, K) , Out( senc(<'confirm', si, H>, K) ) ]

rule Leader_done_sending:
  [ LeaderSend(pw, e, sn, shares, 'nil') ]
  --[LeaderDoneSending(pw, e, shares)]->
  [ LeaderWaitConfirm(pw, e, sn, shares) ]

rule Leader_accept:
  let allshares = shares + si + sn
      K = f(allshares)
      H = h(allshares)
  in
  [ LeaderWaitConfirm(pw, e, sn, allshares), In( senc(<'confirm', si, H> , K) ) ]
  --[ Accept('leader', pw, e, sn, allshares, K) ]->
  [ LeaderAccepted(pw, e, si, allshares, K) ]


lemma SecretAKey:
  "All #i e. SecretAsymmetricKey(e) @ i ==> not (Ex #j. KU(e) @j)"

/*
lemma SecretPW:
*/

lemma Secret:
  "All any pw e sn allshares k #i #j. Accept(any, pw, e, sn, allshares, k) @ i & KU(k) @ j ==> F"

lemma Sanity:
  exists-trace
  "Ex k sn e pw #i si1 #j1 si2 #j2. ///// allshares = si1 + si2 + sn
         Accept('leader',      pw, e,     sn,  si1 + si2 + sn, k) @i 
       & Accept('participant', pw, pk(e), si1, si1 + si2 + sn, k) @j1
       & Accept('participant', pw, pk(e), si2, si1 + si2 + sn, k) @j2
  "

end
