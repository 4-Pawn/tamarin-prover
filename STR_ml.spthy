theory STR_ml
begin

section{* *}

/*
 * Protocol: STR with JOIN only	(manual translation from ML code)
 * Source:      Communication-Efficient Group Key Agreement
 *              
 * Modeler: 	
 * Date: 	
 *
 * Model:       
 * Status: 	
 */

builtins: diffie-hellman, multiset

functions: blindedRandomOf/1, blindedKeyFor/1
functions: te/1, te_inv/1  // convert group element to exponent

equations: te_inv(te(x)) = x // te is not hiding

rule AuthOut:
  [ !AuthOut(x) ]
  -->
  [ Out(x) ]

/* Determine group participants */
rule StartGroupInit:
  [ Fr(~gid) ] -->
  [ StartGroup( $I             // the initiator
              , 1              // number of responders
              , <1,$R> + 'nil' // the list of responders (*)
              , ~gid)          // the group id, not secret
  , Out(~gid)
  ]

// (*) we encode lists [x1,..,xk] as multisets <i,x_1> + <i+1,x_2> + .. + <i+k,x_k> + 'nil'
// we also use pairs ([x_1, .., x_j], [x_{j+1},..,x_k])  to traverse a list

rule StartGroupExtend:
  let nextnum = num + 1
  in
  [ StartGroup( $I, num,     resps                , ~gid) ]
  -->
  [ StartGroup( $I, nextnum, resps + <nextnum, $R>, ~gid) ]



/* Start one Initiator and Responders */

rule StartGroup:
  [ StartGroup( $I, num, resps, ~gid) ]
  -->
  [ Initiator($I, resps, ~gid)
  , StartGroupResponders( 1      // number of responders that have been started
                        , $I     // the initiator
                        , 'nil'  // list of started responders
                        , resps  // list of responders that have not been started yet
                        , ~gid) ]

rule StartGroupResponders:
  let newstarted = started + <j,$R>
  in
  [ StartGroupResponders(j,     $I, started,    <j,$R> + notStarted, ~gid) ]
  -->
  [ StartGroupResponders(j + 1, $I, newstarted, notStarted,          ~gid)
  , Responder( $R
             , $I
             , j          // the index in the list / position in the three
             , started    // below
             , notStarted // above   
             , ~gid) ]



/* Responders */

rule Responder:
  [ Responder($R1, $I, j, below, above, ~gid)
  , Fr(~r) ]
  -->
  [ !AuthOut( < blindedRandomOf(j,~gid), 'g'^~r > )
  , ResponderBRSent($R1, $I, j, below + <j,$R1>, above, ~gid, ~r) ]

rule ResponderBKRecv:
  [ ResponderBRSent($R1, $I, j, below, above, ~gid, ~r)
  , !AuthOut( < blindedKeyFor(j,~gid), bk > )
  ]
  --> 
  [ ResponderLoop( $R1
                 , $I
                 , j      // index of $R1 in list
                 , j + 1  // index of first element of above
                 , below
                 , above
                 , ~gid
                 , bk ^ ~r) ]
  

rule ResponderLoop:
    [ ResponderLoop( $R1, $I, j, k, below, <k, $R2> + above, ~gid, key )
    , !AuthOut( < blindedRandomOf(k, ~gid), br > ) 
    ]
    --[ IKey( $I, below + <'zero',$I>, ~gid, key ) ]->
    [ ResponderLoop($R1, $I, j, k + 1, <k, $R2> + below, above, ~gid, br ^ te(key)) ]

rule ResponderDone:
  [ ResponderLoop($R1, $I, j, k_, below, 'nil', ~gid, key) ]
  --[ Key($R1, below + <'zero',$I>, ~gid, key ) ]-> []

/* Initiator */

rule Initiator:
  let key = br^~r  // here, ~r is an exponent and can be directly used
  in
  [ Initiator($I, resps + <1,$R1>, ~gid)
  , Fr(~r)
  , !AuthOut( < blindedRandomOf(1, ~gid), br> ) ]
  -->
  [ InitiatorLoop( $I
                 , 1 + 1            // index of first not-done
                 , <1,$R1> + 'nil'  // done
                 , resps            // not-done
                 , ~gid
                 , key)
  , !AuthOut( < blindedKeyFor(1, ~gid), 'g'^~r> ) ]

rule InitiatorLoop:
  let newkey = br^te(key) // here, key is a group element and has to be converted to
                         //
  in
  [ InitiatorLoop($I, j, handled, <j,$R1> + notHandled, ~gid, key)
  , !AuthOut( < blindedRandomOf(j, ~gid), br> ) ]
  --[ IKey($I, handled + <'zero',$I>, ~gid, key ) ]->
  [ !AuthOut( < blindedKeyFor(j, ~gid), 'g'^te(key)> )
  , InitiatorLoop($I, j + 1, <j,$R1> + handled, notHandled, ~gid, newkey) ]

rule InitiatorDone:
  [ InitiatorLoop($I, j_, handled, 'nil', ~gid, key) ]
  --[ Key($I, handled + <'zero',$I>, ~gid, key )
    , IKey($I, handled + <'zero',$I>, ~gid, key )
  ]-> []


lemma key_reachable_2:
  exists-trace
  "Ex #i1 I R1 gid key #i2.
         Key(I,  <'zero', I> + <1, R1> + 'nil', gid, key ) @ i1
       & Key(R1, <'zero', I> + <1, R1> + 'nil', gid, key ) @ i2
       & not (I = R1)
"


lemma key_reachable_3:
  exists-trace
  "Ex #i1 I R1 R2 gid key #i2 #i3.
         Key( I,  <'zero', I> + <1, R1> + <1+1, R2> + 'nil', gid, key ) @ i1
       & Key( R1, <'zero', I> + <1, R1> + <1+1, R2> + 'nil', gid, key ) @ i2
       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + 'nil', gid, key ) @ i3
       & not (I = R1)
       & not (R1 = R2)
       & not (I = R2)
"

lemma key_reachable_4:
  exists-trace
  "Ex #i1 I R1 R2 R3 gid key #i2 #i3 #i4.
         Key( I,  <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i1
       & Key( R1, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i2
       & Key( R2, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i3
       & Key( R3, <'zero', I> + <1, R1> + <1+1, R2> + <1+1+1, R3> + 'nil', gid, key ) @ i4
       & not (I = R1)
       & not (R1 = R2)
       & not (I = R2)
       & not (I = R3)
       & not (R1 = R3)
       & not (R2 = R3)
" 


lemma key_sececy[use_induction]:
  all-traces
  "not (Ex #i1 I group gid key #i2.
          IKey( I,  group, gid, key ) @ i1 & KU( key ) @ i2)"


end