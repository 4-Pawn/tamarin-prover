{-# LANGUAGE RecordWildCards #-}
-- Copyright   : (c) 2019 Robert Künnemann
-- License     : GPL v3 (see LICENSE)
--
-- Maintainer  : Robert Künnemann <robert@kunnemann.de>
-- Portability : GHC only
--
-- TODO
module Sapic.Facts (
     TransAction(..)
   , TransFact(..)
   , AnnotatedRule(..)
   , StateKind(..)
   , isSemiState
   , factToFact
   , actionToFact
   , toRule
) where
-- import Data.Maybe
-- import Data.Foldable
-- import Control.Exception
-- import Control.Monad.Fresh
-- import Control.Monad.Catch
-- import Sapic.Exceptions
import Theory
import Theory.Text.Parser
import Theory.Sapic
import Sapic.Annotation ()
-- import Theory.Model.Rule
-- import Theory.Model.Rule
-- import Data.Typeable
-- import Data.Text
import Data.Char
import qualified Data.Set as S
import Data.Color
-- import Control.Monad.Trans.FastFresh

data TransAction =  InitEmpty
  | InitId
  | StopId
  | EventEmpty
  | EventId
  | Predicate LNFact
  | NegPredicate LNFact
  | ProgressFrom ProcessPosition 
  | ProgressTo ProcessPosition ProcessPosition
  | Listen ProcessPosition LVar 
  | Receive ProcessPosition SapicTerm
  | IsIn SapicTerm LVar
  | IsNotSet SapicTerm
  | InsertA SapicTerm SapicTerm
  | DeleteA SapicTerm 
  | ChannelIn SapicTerm
  | Send ProcessPosition SapicTerm
  | LockA SapicTerm LVar
  | TamarinAct LNFact

data StateKind  = LState | PState | LSemiState | PSemiState

data TransFact =  Fr LVar | In SapicTerm 
            | Out SapicTerm
            | Message SapicTerm SapicTerm
            | Ack SapicTerm SapicTerm
            | State StateKind ProcessPosition (S.Set LVar)
            | MessageIDSender ProcessPosition
            | MessageIDReceiver ProcessPosition
            | TamarinFact LNFact

data AnnotatedRule ann = AnnotatedRule { 
      processName  :: Maybe String
    , process      :: AnProcess ann
    , position     :: ProcessPosition
    , prems        :: [TransFact]
    , acts         :: [TransAction]  
    , concs        :: [TransFact]
    , index        :: Int
}

-- data Fact t = Fact
--     { factTag         :: FactTag
--     , factAnnotations :: S.Set FactAnnotation
--     , factTerms       :: [t]
--     }
-- -- | A protocol fact denotes a fact generated by a protocol rule.
-- protoFact :: Multiplicity -> String -> [t] -> Fact t
-- protoFact multi name ts = Fact (ProtoFact multi name (length ts)) S.empty ts

isSemiState :: StateKind -> Bool
isSemiState LState = False
isSemiState PState = False
isSemiState LSemiState = True
isSemiState PSemiState = True

multiplicity :: StateKind -> Multiplicity
multiplicity LState = Linear
multiplicity LSemiState = Linear
multiplicity PState = Persistent
multiplicity PSemiState = Persistent

-- actionToFact :: TransAction -> Fact t
actionToFact InitEmpty = protoFact Linear "Init" []
  -- | InitId
  -- | StopId
  -- | EventEmpty
  -- | EventId
  -- | Predicate LNFact
  -- | NegPredicate LNFact
  -- | ProgressFrom ProcessPosition 
  -- | ProgressTo ProcessPosition ProcessPosition
  -- | Listen ProcessPosition LVar 
  -- | Receive ProcessPosition SapicTerm
  -- | Send ProcessPosition SapicTerm
actionToFact (LockA t v) = protoFact Linear (lockFactName v) [varTerm v ]
  -- | TamarinAct LNFact

-- | Term with variable for message id. Uniqueness ensured by process position.
varTermMID :: ProcessPosition -> VTerm c LVar
varTermMID p = varTerm $ LVar n s i
    where n = "mid_" ++ prettyPosition p
          s = LSortFresh
          i = 0 -- This is the message indexx. We could compute it from the position, but not sure if this makes things simpler.

-- Optimisation: have a diffeent Fact name for every (unique) locking variable 
lockFactName v = "Lock"++ (show $ lvarIdx v)

factToFact :: TransFact -> Fact SapicTerm
factToFact (Fr v) = freshFact $ varTerm (v)
factToFact (In t) = inFact t
factToFact (Out t) = outFact t
factToFact (Message t t') = protoFact Linear "Message" [t, t']
factToFact (Ack t t') = protoFact Linear "Ack" [t, t']
factToFact (MessageIDSender p) = protoFact Linear "MID_Sender" [ varTermMID p ]
factToFact (MessageIDReceiver p) = protoFact Linear "MID_Receiver" [ varTermMID p ]
factToFact (State kind p vars) = protoFact (multiplicity kind) (name kind ++ "_" ++ prettyPosition p) ts
    where
        name k = if isSemiState k then "semistate" else "state"
        ts = map varTerm (S.toList vars)
factToFact (TamarinFact f) = f


toRule :: AnnotatedRule ann -> Rule ProtoRuleEInfo
toRule AnnotatedRule{..} = -- this is a Record Wildcard
          Rule (ProtoRuleEInfo (StandRule name) attr) l r a (newVariables l r)
          where
            name = case processName of 
                Just s -> s
                Nothing -> stripNonAlphanumerical (prettySapicTopLevel process) ++ "_" ++ show index ++ "_" ++ prettyPosition position
            attr = [RuleColor $ RGB 0.3 0.3 0.3] -- TODO compute color from
            l = map factToFact prems
            a = map actionToFact acts
            r = map factToFact concs

stripNonAlphanumerical :: String -> String
stripNonAlphanumerical = filter (\x -> isLower x || isSpace x || isDigit x )
