theory GDH_List
begin

builtins: diffie-hellman, multiset

functions: nil/0, g/0, list_to_mset/1

axiom InEq_not_eq: "not (Ex x #i. Ineq(x,x)@i)"

// this is a pre-fix closed version of IsLast which does not interfere with the lemma "No_inverses":
axiom IsLast: "All x A #i. IsLast(x,A) @ i ==> Ex #j. Last(x,A) @ j & j < i"

axiom MembersUnique: "All x A #i #j. Mem(x,A) @ i & Mem(x,A) @ j ==> #i = #j"


/*************************************************************************/
/* Setup                                                                 */
/*************************************************************************/

rule ChooseParticipants1:
  [ Fr(~gid) ]
 --[ Mem(~gid,$I), InEq($I, $R)
   , Last(~gid, $R)
 ]-> // groups have initiator (first) and responders
  [ F_StartGroup(~gid, $I, <$R, nil>) ]

rule ChooseParticipants2:
  [ F_StartGroup(~gid, $I, responders) ]
 --[ Mem(~gid,$R), StepC() ]->
  [ F_StartGroup(~gid, $I, <$R,responders>) ]

rule StartGroup1:
  [ F_StartGroup(~gid, $I, responders) ]
 --[ Step() , Started(~gid, $I) ]->
  [ F_Initiator1(~gid, $I, responders)                   // fork initiator which is round 0 (represented as nil)
  , F_StartResponders(~gid, responders, <$I,nil>, 1) ] // loop for starting responders

rule StartGroup2:
  [ F_StartResponders(~gid, <$R,notstarted>, started, round) ]
 --[ Started(~gid, $R) ]->
  [ F_Responder1(~gid, $R, started, notstarted, round)
  , F_StartResponders(~gid, notstarted, <$R,started>, round+1) ]

/*************************************************************************/
/* Initiator                                                             */
/*************************************************************************/

rule Initiator:
  let responders = <$R,other> in
  [ F_Initiator1(~gid, $I, responders)
  , Fr(~ei) ]
--[ AOut(~gid, $I, $I), AOut(~gid, $I, $R) 
  , Nonce(nil, ~ei)     // add ~gid to ALL nonce action facts?
  , Exp(~gid, nil, 1)   // assuming 1 is the neutral element of the multiplication in the exponents
  , Exp(~gid, nil, ~ei) // duplicate of ExpLast needed for inductive proof of "no inverses in exponent"
  , ExpLast(~gid, nil, ~ei)
  ]->
  [ F_Initiator2(~gid, ~ei, $I, responders)
  , AuthOut(<~gid, $I, $I, g   >)    // from $I, key for $I
  , AuthOut(<~gid, $I, $R, g^~ei>)   // from $I, key for first responder $R
  , Out(g^~ei)
  ]

rule Initiator2:
  let Y = g^y in
  [ F_Initiator2(~gid, ~ei, $I, responders)
  , AuthOut(<~gid, $S, $I, Y>) ]  // $S unspecified, should be last(responders)
 --[ Key(~gid, $I, list_to_mset(responders) + $I)
   , Secret(~gid, Y^~ei)
//   , Exp(~gid, 'finalkey', y*~ei) // this seems unnecessary and potentially counter-productive
   , IsLast(~gid, $S)
   ]->
  [ ]

/*************************************************************************/
/* Responders                                                            */
/*************************************************************************/

rule Responder1:
  let Y = g^y in
  [ F_Responder1(~gid, $R, <$S, before_missing>, after, round)
  , Fr(~ec) 
  , AuthOut(<~gid, $S, $S, Y>) ]     // key for $S sent by $S
--[ AOut(~gid, $R, $S) 
  , Nonce(round,~ec)
  , Exp(~gid, round, y*~ec) 
  ]->
  [ F_Responder2(~gid, ~ec, $R, $S, before_missing, <$S, nil>, after, round)
  , AuthOut(<~gid, $R, $S, Y^~ec>)   // new key for $S sent by $R 
  , Out(Y^~ec) ]

rule Responder2:
  let Y = g^y in
  [ F_Responder2(~gid, ~ec, $R, $S, <$KR, before_missing>, before_rcvd, after, round)
  , AuthOut(<~gid, $S, $KR, Y>) ]     // key for $KR sent by $S
--[ AOut(~gid, $R, $KR) 
  , Exp(~gid, round, y*~ec)
  ]->
  [ F_Responder2(~gid, ~ec, $R, $S, before_missing, <$KR, before_rcvd>, after, round)
  , AuthOut(<~gid, $R, $KR, Y^~ec>)   // new key for $KR sent by $R
  , Out(Y^~ec) ]

rule Responder3:
  let Y = g^y 
      after = <$KR, after_missing>
  in
  [ F_Responder2(~gid, ~ec, $R, $S, nil, before_rcvd, after, round)
  , AuthOut(<~gid, $S, $R, Y>) ]      // key for $R sent by $S (groupkey last round)
--[ AOut(~gid, $R, $KR), AOut(~gid, $R, $R) 
  , Exp(~gid, round, y)     // this has been stated before (prior round, by sender of the message received here), but it needs to be stated again as otherwise an infinite loop is possible due to the second message (Y) being sent out
  , Exp(~gid, round, y*~ec) // duplicate of ExpLast needed for inductive proof of "no inverses in exponent"
  , ExpLast(~gid, round, y*~ec)
  ]->
  [ F_Responder3(~gid, ~ec, $R, before_rcvd, after, round)
  , AuthOut(<~gid, $R, $KR, Y^~ec>)   // group key this round - sent to next participant
  , AuthOut(<~gid, $R, $R, Y>)        // key for $R sent by $R
  , Out(Y^~ec) ]
  
rule Responder3_last:
  let Y = g^y in
  [ F_Responder2(~gid, ~ec, $R, $S, nil, before_rcvd, nil, round)
  , AuthOut(<~gid, $S, $R, Y>) ] // key for $R sent by $S (groupkey from last round)
--[ Key(~gid, $R, list_to_mset(before_rcvd) + $R ) 
  , ExpLast(~gid, round, y*~ec)
//  , Exp(~gid, round, y*~ec) // duplicate of ExpLast needed for inductive proof of "no inverses in exponent" // this seems unnecessary and potentially counter-productive
  , Secret(~gid, Y^~ec)
  , NonceRecv(~ec)
  ]->
  [ ]

rule Responder4:
  let Y = g^y in
  [ F_Responder3(~gid, ~ec, $R, p1, p2, round)
  , AuthOut(<~gid, $S, $R, Y>) ] // $S should be last ... 
 --[ Key(~gid, $R, list_to_mset(p1) + list_to_mset(p2) + $R )
   , Secret(~gid, Y^~ec)
   , NonceRecv(~ec) 
//   , Exp(~gid, 'finalkey', y*~ec) // this seems unnecessary and potentially counter-productive
   , IsLast(~gid, $S) ]->
  [ ]


// this should be a Lemma
axiom AOut_unique:
  "All #i #j id A B. AOut(id,A,B)@i & AOut(id,A,B)@j ==> #i = #j"

// TODO: not yet proven!
// get rid of non-trivial variants of rules due to inverses in exponents 
lemma No_inverses[use_induction,reuse]:
 all-traces
 "not (  (Ex #i x round id.   Exp(id, round, inv(x)  ) @ i)
       | (Ex #i x y round id. Exp(id, round, inv(x)*y) @ i))"



// powerful since whenever adv. knows product with factor ~x, then he also knows ~x.
//works!
lemma B[reuse]:
 all-traces
 "not (Ex round #i1 x #i2. Nonce(round, x ) @ i1 &  KU( x ) @ i2)"


/* TODO: GO ON HERE
In each round show:
 Exp(~gid, round,x) and Exp(~gid, round,y) ==>
   x = y | (Ex i1 i2 ~z1 ~z2 w. Nonce(i1,~z1) & Nonce(i2,~z2) & x * ~z1 = y * ~z2)
// for the above lemma consider having "Nonce" action in each of the rules using a fresh nonce

Show:
   All i x y round. ExpLast(~gid, round, x) & Exp(~gid, round,y) ==> Ex i ~z . Nonce(i,~z). x = y*~z 
*/


/*
lemma key_agreement_2:
  exists-trace
  "Ex #j1 #j2 A B  id. Key(id, A, list_to_mset(<B,nil>) + A) @ j1
                     & Key(id, B, list_to_mset(<A,nil>) + B) @ j2
                     & not (A = B)"

// A initiator
// B middle
// C last
lemma key_agreement_3:
  exists-trace
  "Ex #j1 #j2 #j3 A B C id. 
      Key(id, A, list_to_mset(<B,C,nil>) + A) @ j1
    & Key(id, B, list_to_mset(<A,nil>) + list_to_mset(<C,nil>)+ B) @ j2
    & Key(id, C, list_to_mset(<A,B,nil>) + C) @ j3
    & not (A = B)
    & not (A = C)
    & not (B = C)"

//note that this order is not the one they have been created at; creation order is: A(initiator), C(last), B2, B1, ... (rest in reverse order)
// A initiator
// B1 middle (before B2)
// B2 middle (after B1)
// C last
lemma key_agreement_4:
  exists-trace
  "Ex #j1 #jb1 #jb2 #j3 A B1 B2 C id. 
      Key(id, A, list_to_mset(<B1,B2,C,nil>) + A) @ j1
    & Key(id, B1, list_to_mset(<A,nil>) + list_to_mset(<B2,C,nil>)+ B1) @ jb1 
    & Key(id, B2, list_to_mset(<A,B1,nil>) + list_to_mset(<C,nil>)+ B2) @ jb2 
    & Key(id, C, list_to_mset(<A,B1,B2,nil>) + C) @ j3
    & not (A = B1)
    & not (A = B2)
    & not (A = C)
    & not (B1 = B2)
    & not (B1 = C)
    & not (B2 = C)"

// A initiator
// B1 middle (before B2)
// B2 middle (after B1, before B3)
// B3 middle (after B2)
// C last
lemma key_agreement_5:
  exists-trace
  "Ex #j1 #jb1 #jb2 #jb3 #j3 A B1 B2 B3 C id. 
      Key(id, A, list_to_mset(<B1,B2,B3,C,nil>) + A) @ j1
    & Key(id, B1, list_to_mset(<A,nil>) + list_to_mset(<B2,B3,C,nil>)+ B1) @ jb1 
    & Key(id, B2, list_to_mset(<A,B1,nil>) + list_to_mset(<B3,C,nil>)+ B2) @ jb2 
    & Key(id, B3, list_to_mset(<A,B1,B2,nil>) + list_to_mset(<C,nil>)+ B3) @ jb3 
    & Key(id, C, list_to_mset(<A,B1,B2,B3,nil>) + C) @ j3
    & not (A = B1)
    & not (A = B2)
    & not (A = B3)
    & not (A = C)
    & not (B1 = B2)
    & not (B1 = B3)
    & not (B1 = C)
    & not (B2 = B3)
    & not (B2 = C)
    & not (B3 = C)"

// A initiator
// B1 middle (before B2)
// B2 middle (after B1, before B3)
// B3 middle (after B2, before B4)
// B4 middle (after B3)
// C last
lemma key_agreement_6:
  exists-trace
  "Ex #j1 #jb1 #jb2 #jb3 #jb4 #j3 A B1 B2 B3 B4 C id. 
      Key(id, A, list_to_mset(<B1,B2,B3,B4,C,nil>) + A) @ j1
    & Key(id, B1, list_to_mset(<A,nil>) + list_to_mset(<B2,B3,B4,C,nil>)+ B1) @ jb1 
    & Key(id, B2, list_to_mset(<A,B1,nil>) + list_to_mset(<B3,B4,C,nil>)+ B2) @ jb2 
    & Key(id, B3, list_to_mset(<A,B1,B2,nil>) + list_to_mset(<B4,C,nil>)+ B3) @ jb3 
    & Key(id, B4, list_to_mset(<A,B1,B2,B3,nil>) + list_to_mset(<C,nil>)+ B4) @ jb4 
    & Key(id, C, list_to_mset(<A,B1,B2,B3,B4,nil>) + C) @ j3
    & not (A = B1)
    & not (A = B2)
    & not (A = B3)
    & not (A = B4)
    & not (A = C)
    & not (B1 = B2)
    & not (B1 = B3)
    & not (B1 = B4)
    & not (B1 = C)
    & not (B2 = B3)
    & not (B2 = B4)
    & not (B2 = C)
    & not (B3 = B4)
    & not (B3 = C)
    & not (B4 = C)"
*/




end
