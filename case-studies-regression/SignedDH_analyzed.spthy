theory SignedDH begin

 builtin: diffie-hellman

section{* Finite Variants of the Intruder Rules *}

 rule (modulo AC) isend:
    [ !KU( f_, x ) ] --[ K( x ) ]-> [ In( x ) ]
 
 rule (modulo AC) fst:
    [ !KD( f_.3, <x.1, x.2> ) ] --> [ !KD( f_.4, x.1 ) ]
 
 rule (modulo AC) snd:
    [ !KD( f_.3, <x.1, x.2> ) ] --> [ !KD( f_.4, x.2 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^x.4 ), !KU( f_.2, x.1 ) ]
   -->
    [ !KD( 'exp', x.3^(x.1*x.4) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^x.3 ), !KU( f_.2, inv(x.3) ) ]
   -->
    [ !KD( 'exp', x.4 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^inv(x.3) ), !KU( f_.2, x.3 ) ]
   -->
    [ !KD( 'exp', x.4 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^inv(x.5) ), !KU( f_.2, inv(x.3) ) ]
   -->
    [ !KD( 'exp', x.4^inv((x.3*x.5)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^inv((x.3*x.5)) ), !KU( f_.2, x.3 ) ]
   -->
    [ !KD( 'exp', x.4^inv(x.5) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^(x.3*x.5) ), !KU( f_.2, inv(x.3) ) ]
   -->
    [ !KD( 'exp', x.4^x.5 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^(x.5*inv(x.3)) ), !KU( f_.2, x.3 ) ]
   -->
    [ !KD( 'exp', x.4^x.5 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^x.4 ), !KU( f_.2, inv((x.4*x.5)) ) ]
   -->
    [ !KD( 'exp', x.3^inv(x.5) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^x.4 ), !KU( f_.2, (x.5*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.3^x.5 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^inv(x.4) ), !KU( f_.2, (x.3*x.4) ) ]
   -->
    [ !KD( 'exp', x.5^x.3 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^(x.5*inv(x.6)) ), !KU( f_.2, inv(x.3) ) ]
   -->
    [ !KD( 'exp', x.4^(x.5*inv((x.3*x.6))) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^inv(x.4) ), !KU( f_.2, (x.5*inv(x.6)) ) ]
   -->
    [ !KD( 'exp', x.3^(x.5*inv((x.4*x.6))) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.4^(x.5*inv((x.3*x.6))) ), !KU( f_.2, x.3 ) ]
   -->
    [ !KD( 'exp', x.4^(x.5*inv(x.6)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^inv((x.4*x.6)) ), !KU( f_.2, (x.3*x.4) ) ]
   -->
    [ !KD( 'exp', x.5^(x.3*inv(x.6)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.4*x.6) ), !KU( f_.2, inv((x.3*x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^(x.6*inv(x.3)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.4*x.6) ), !KU( f_.2, (x.3*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^(x.3*x.6) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.6*inv(x.4)) ), !KU( f_.2, (x.3*x.4) ) ]
   -->
    [ !KD( 'exp', x.5^(x.3*x.6) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^x.4 ), !KU( f_.2, (x.5*inv((x.4*x.6))) ) ]
   -->
    [ !KD( 'exp', x.3^(x.5*inv(x.6)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.6*inv(x.7)) ), !KU( f_.2, (x.3*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^((x.3*x.6)*inv((x.4*x.7))) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.4*inv(x.3)) ), !KU( f_.2, (x.3*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.5 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.4*inv(x.6)) ), !KU( f_.2, inv((x.3*x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^inv((x.3*x.6)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^inv((x.3*x.6)) ), !KU( f_.2, (x.3*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^inv((x.4*x.6)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.6*inv((x.4*x.7))) ), !KU( f_.2, (x.3*x.4) ) ]
   -->
    [ !KD( 'exp', x.5^((x.3*x.6)*inv(x.7)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^(x.4*x.5) ), !KU( f_.2, (x.6*inv((x.5*x.7))) ) ]
   -->
    [ !KD( 'exp', x.3^((x.4*x.6)*inv(x.7)) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^((x.4*x.6)*inv(x.3)) ), !KU( f_.2, (x.3*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^x.6 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.6^(x.5*inv(x.4)) ), !KU( f_.2, ((x.3*x.4)*inv(x.5)) ) ]
   -->
    [ !KD( 'exp', x.6^x.3 ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^((x.4*x.6)*inv(x.7)) ), !KU( f_.2, inv((x.3*x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^(x.6*inv((x.3*x.7))) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.6^inv((x.4*x.7)) ), !KU( f_.2, ((x.3*x.4)*inv(x.5)) ) ]
   -->
    [ !KD( 'exp', x.6^(x.3*inv((x.5*x.7))) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.4*inv((x.3*x.6))) ), !KU( f_.2, (x.3*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^inv(x.6) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^(x.4*inv(x.5)) ), !KU( f_.2, (x.5*inv((x.4*x.6))) ) ]
   -->
    [ !KD( 'exp', x.3^inv(x.6) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.3^(x.4*inv(x.5)) ), !KU( f_.2, (x.6*inv((x.4*x.7))) ) ]
   -->
    [ !KD( 'exp', x.3^(x.6*inv((x.5*x.7))) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^((x.5*x.7)*inv(x.4)) ),
    !KU( f_.2, ((x.3*x.4)*inv(x.5)) )
    ]
   -->
    [ !KD( 'exp', x.6^(x.3*x.7) ) ]
 
 rule (modulo AC) exp:
    [ !KD( 'noexp', x.5^(x.6*inv((x.3*x.7))) ), !KU( f_.2, (x.3*inv(x.4)) ) ]
   -->
    [ !KD( 'exp', x.5^(x.6*inv((x.4*x.7))) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.3^(x.4*inv(x.5)) ),
    !KU( f_.2, ((x.5*x.6)*inv((x.4*x.7))) )
    ]
   -->
    [ !KD( 'exp', x.3^(x.6*inv(x.7)) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.5^((x.4*x.6)*inv((x.3*x.7))) ),
    !KU( f_.2, (x.3*inv(x.4)) )
    ]
   -->
    [ !KD( 'exp', x.5^(x.6*inv(x.7)) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^(x.5*inv((x.4*x.7))) ),
    !KU( f_.2, ((x.3*x.4)*inv(x.5)) )
    ]
   -->
    [ !KD( 'exp', x.6^(x.3*inv(x.7)) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^((x.5*x.7)*inv(x.3)) ),
    !KU( f_.2, (x.3*inv((x.4*x.5))) )
    ]
   -->
    [ !KD( 'exp', x.6^(x.7*inv(x.4)) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^((x.5*x.7)*inv(x.8)) ),
    !KU( f_.2, (x.3*inv((x.4*x.5))) )
    ]
   -->
    [ !KD( 'exp', x.6^((x.3*x.7)*inv((x.4*x.8))) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^(x.7*inv((x.4*x.8))) ),
    !KU( f_.2, ((x.3*x.4)*inv(x.5)) )
    ]
   -->
    [ !KD( 'exp', x.6^((x.3*x.7)*inv((x.5*x.8))) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^(x.5*inv((x.3*x.7))) ),
    !KU( f_.2, (x.3*inv((x.4*x.5))) )
    ]
   -->
    [ !KD( 'exp', x.6^inv((x.4*x.7)) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.3^((x.4*x.5)*inv(x.6)) ),
    !KU( f_.2, ((x.6*x.7)*inv((x.5*x.8))) )
    ]
   -->
    [ !KD( 'exp', x.3^((x.4*x.7)*inv(x.8)) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^((x.5*x.7)*inv((x.4*x.8))) ),
    !KU( f_.2, ((x.3*x.4)*inv(x.5)) )
    ]
   -->
    [ !KD( 'exp', x.6^((x.3*x.7)*inv(x.8)) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.7^(x.6*inv((x.4*x.8))) ),
    !KU( f_.2, ((x.3*x.4)*inv((x.5*x.6))) )
    ]
   -->
    [ !KD( 'exp', x.7^(x.3*inv((x.5*x.8))) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.6^((x.5*x.7)*inv((x.3*x.8))) ),
    !KU( f_.2, (x.3*inv((x.4*x.5))) )
    ]
   -->
    [ !KD( 'exp', x.6^(x.7*inv((x.4*x.8))) ) ]
 
 rule (modulo AC) exp:
    [
    !KD( 'noexp', x.7^((x.6*x.8)*inv((x.4*x.9))) ),
    !KU( f_.2, ((x.3*x.4)*inv((x.5*x.6))) )
    ]
   -->
    [ !KD( 'exp', x.7^((x.3*x.8)*inv((x.5*x.9))) ) ]
 
 rule (modulo AC) inv:
    [ !KD( f_.1, inv(x.2) ) ] --> [ !KD( 'noexp', x.2 ) ]
 
 rule (modulo AC) fst:
    [ !KU( f_.1, x ) ] --> [ !KU( 'noexp', fst(x) ) ]
 
 rule (modulo AC) pair:
    [ !KU( f_.2, x ), !KU( f_.3, x.1 ) ] --> [ !KU( 'noexp', <x, x.1> ) ]
 
 rule (modulo AC) pk:
    [ !KU( f_.1, x ) ] --> [ !KU( 'noexp', pk(x) ) ]
 
 rule (modulo AC) sign:
    [ !KU( f_.2, x ), !KU( f_.3, x.1 ) ] --> [ !KU( 'noexp', sign(x, x.1) ) ]
 
 rule (modulo AC) snd:
    [ !KU( f_.1, x ) ] --> [ !KU( 'noexp', snd(x) ) ]
 
 rule (modulo AC) true:
    [ ] --> [ !KU( 'noexp', true() ) ]
 
 rule (modulo AC) verify:
    [ !KU( f_.3, x ), !KU( f_.4, x.1 ), !KU( f_.5, x.2 ) ]
   -->
    [ !KU( 'noexp', verify(x, x.1, x.2) ) ]
 
 rule (modulo AC) coerce:
    [ !KD( f_, x ) ] --> [ !KU( f_, x ) ]
 
 rule (modulo AC) pub:
    [ ] --> [ !KU( f_, $x ) ]
 
 rule (modulo AC) fresh:
    [ Fr( ~x ) ] --> [ !KU( f_, ~x ) ]
 
 rule (modulo AC) exp:
    [ !KU( 'noexp', x ), !KU( f_.2, x.1 ) ] --> [ !KU( 'exp', x^x.1 ) ]
 
 rule (modulo AC) inv:
    [ !KU( f_.1, x ) ] --> [ !KU( 'noexp', inv(x) ) ]

section{* The Signed Diffie-Hellman Protocol *}

rule (modulo E) Register_pk:
   [ Fr( ~ltk ) ] --> [ !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) ) ]
  /* has exactly the trivial AC variant */

rule (modulo E) Get_pk:
   [ !Pk( A, pk ) ] --> [ Out( pk ) ]
  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ltk:
   [ !Ltk( A, ltk ) ] --[ LtkReveal( A ) ]-> [ Out( ltk ) ]
  /* has exactly the trivial AC variant */

rule (modulo E) Init_1:
   [ Fr( ~ekI ), !Ltk( $I, ltkI ) ]
  -->
   [
   Init_1( $I, $R, ~ekI ),
   Out( <$I, $R, 'g'^~ekI, sign(<'1', $I, $R, 'g'^~ekI>, ltkI)> )
   ]
  /* has exactly the trivial AC variant */

rule (modulo E) Init_2:
   [
   Init_1( $I, $R, ~ekI ), !Pk( $R, pk(ltkR) ),
   In( <$R, $I, Y, sign(<'2', $R, $I, Y>, ltkR)> )
   ]
  --[ SessionKey( $I, $R, Y^~ekI ) ]->
   [ ]
  /*
  rule (modulo AC) Init_2:
     [
     Init_1( $I.3, $R.4, ~ekI ), !Pk( $R.4, pk(x.5) ),
     In( <$R.4, $I.3, x.2, sign(<'2', $R.4, $I.3, x.2>, x.5)> )
     ]
    --[ SessionKey( $I.3, $R.4, z.1 ) ]->
     [ ]
  
    variants (modulo AC)
    1. ~ekI  = ~ekI.29
       z.1   = z.30
       x.2   = z.30^inv(~ekI.29)
    
    2. ~ekI  = ~ekI.29
       z.1   = x.30^~ekI.29
       x.2   = x.30
    
    3. ~ekI  = ~ekI.30
       z.1   = x.31^x.32
       x.2   = x.31^(x.32*inv(~ekI.30))
    
    4. ~ekI  = ~ekI.30
       z.1   = x.31^inv(x.32)
       x.2   = x.31^inv((~ekI.30*x.32))
    
    5. ~ekI  = ~ekI.30
       z.1   = x.31^(~ekI.30*x.32)
       x.2   = x.31^x.32
    
    6. ~ekI  = ~ekI.31
       z.1   = x.32^(x.33*inv(x.34))
       x.2   = x.32^(x.33*inv((~ekI.31*x.34)))
  */

rule (modulo E) Resp:
   [
   !Pk( $I, pk(ltkI) ), !Ltk( $R, ltkR ), Fr( ~ekR ),
   In( <$I, $R, X, sign(<'1', $I, $R, X>, ltkI)> )
   ]
  --[ SessionKey( $I, $R, X^~ekR ) ]->
   [ Out( <$R, $I, 'g'^~ekR, sign(<'2', $R, $I, 'g'^~ekR>, ltkR)> ) ]
  /*
  rule (modulo AC) Resp:
     [
     !Pk( $I.3, pk(x.4) ), !Ltk( $R.5, ltkR.6 ), Fr( ~ekR ),
     In( <$I.3, $R.5, x.2, sign(<'1', $I.3, $R.5, x.2>, x.4)> )
     ]
    --[ SessionKey( $I.3, $R.5, z.1 ) ]->
     [
     Out( <$R.5, $I.3, 'g'^~ekR, sign(<'2', $R.5, $I.3, 'g'^~ekR>, ltkR.6)> )
     ]
  
    variants (modulo AC)
    1. ~ekR  = ~ekR.49
       z.1   = z.50
       x.2   = z.50^inv(~ekR.49)
    
    2. ~ekR  = ~ekR.49
       z.1   = x.50^~ekR.49
       x.2   = x.50
    
    3. ~ekR  = ~ekR.50
       z.1   = x.51^x.52
       x.2   = x.51^(x.52*inv(~ekR.50))
    
    4. ~ekR  = ~ekR.50
       z.1   = x.51^inv(x.52)
       x.2   = x.51^inv((~ekR.50*x.52))
    
    5. ~ekR  = ~ekR.50
       z.1   = x.51^(~ekR.50*x.52)
       x.2   = x.51^x.52
    
    6. ~ekR  = ~ekR.51
       z.1   = x.52^(x.53*inv(x.54))
       x.2   = x.52^(x.53*inv((~ekR.51*x.54)))
  */

lemma (modulo E) Perfect_Forward_Secrecy:
  "All I R.1 sessKey.2 #i.3 #k.4.
    ((SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)) ==>
    ((Ex #r.5. (LtkReveal( I ) @ #r.5) & (#r.5 < #i.3)) |
     (Ex #r.6. (LtkReveal( R.1 ) @ #r.6) & (#r.6 < #i.3)))"
/* proof based on the same lemma modulo AC */
/*
doubly-guarded formula characterizing all attacks:
"Ex I R.1 sessKey.2 #i.3 #k.4.
  (SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)
 &
  (All #r.5. (LtkReveal( I ) @ #r.5) ==> All. (#r.5 < #i.3) ==> F) &
  (All #r.6. (LtkReveal( R.1 ) @ #r.6) ==> All. (#r.6 < #i.3) ==> F)"
*/
/*
proof by induction possible over the formula:
"(Ex I R.1 sessKey.2 #i.3 #k.4.
   (SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)
  &
   (All #r.5. (LtkReveal( I ) @ #r.5) ==> All. (#r.5 < #i.3) ==> F) &
   (All #r.6. (LtkReveal( R.1 ) @ #r.6) ==> All. (#r.6 < #i.3) ==> F)) &
 (All I.7 R.8 sessKey.9 #i.10 #k.11.
   (SessionKey( I.7, R.8, sessKey.9 ) @ #i.10) & (K( sessKey.9 ) @ #k.11)
  ==>
   (Last(#k.11)) |
   (Last(#i.10)) |
   (Ex #r.12.
     (LtkReveal( I.7 ) @ #r.12)
    &
     (All. (Last(#r.12)) ==> F) & (Ex. (#r.12 < #i.10) & T)) |
   (Ex #r.13.
     (LtkReveal( R.8 ) @ #r.13)
    &
     (All. (Last(#r.13)) ==> F) & (Ex. (#r.13 < #i.10) & T)))"
*/
simplify
solve( SessionKey( I, R.1, sessKey.2 ) @ #i.3 )
  case Init_2
  solve( (#i.3, 0)[Init_1( $I.10, $R.11, ~ekI.7 )] )
    case Init_1
    solve( (#i.3, 1)[!Pk( $R.11, pk(x.12) )] )
      case Register_pk
      solve( KU((#vf.13, 0), sign(<'2', $R.11, $I.10, x.9>, ~ltk.31)) )
        case Resp
        solve( KU((#vf.47, 0), sign(<'1', $I.10, $R.11, x.45>, ~ltk.44)) )
          case Init_1
          solve( splitEqs(1) )
            case split_case_1
            solve( (#k.4, 0)[!KU( f_.5, 'g'^(~ekI.113*~ekR.114) )] )
              case Init_1
              by solve( (#vr.132, 1)[!KU( f_.133, ~ekR.155 )] )
            next
              case Resp
              by solve( (#vr.137, 1)[!KU( f_.138, ~ekI.163 )] )
            next
              case exp
              by solve( KU((#vr.118, 1), ~ekI.113) )
            qed
          next
            case split_case_2
            by contradiction // non-normal terms
          qed
        next
          case sign
          solve( (#vr.81, 1)[!KU( f_.83, ~ltk.44 )] )
            case Reveal_ltk
            by contradiction // cyclic
          qed
        qed
      next
        case sign
        solve( (#vr.37, 1)[!KU( f_.39, ~ltk.31 )] )
          case Reveal_ltk
          by contradiction // cyclic
        qed
      qed
    qed
  qed
next
  case Resp
  solve( (#i.3, 0)[!Pk( $I.10, pk(x.11) )] )
    case Register_pk
    solve( (#i.3, 1)[!Ltk( $R.12, ltkR.13 )] )
      case Register_pk
      solve( KU((#vf.14, 0), sign(<'1', $I.10, $R.12, x.9>, ~ltk.20)) )
        case Init_1
        solve( splitEqs(1) )
          case split_case_1
          solve( (#k.4, 0)[!KU( f_.5, 'g'^(~ekR.64*~ekI.65) )] )
            case Init_1
            by solve( (#vr.83, 1)[!KU( f_.84, ~ekR.105 )] )
          next
            case Resp
            by solve( (#vr.88, 1)[!KU( f_.89, ~ekI.115 )] )
          next
            case exp
            by solve( KU((#vr.69, 1), ~ekR.64) )
          qed
        next
          case split_case_2
          by contradiction // non-normal terms
        qed
      next
        case sign
        solve( (#vr.32, 1)[!KU( f_.34, ~ltk.20 )] )
          case Reveal_ltk
          by contradiction // cyclic
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.


analyzing: data/examples/SignedDH.spthy

------------------------------------------------------------------------------
analyzed: data/examples/SignedDH.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 3.891899s
  Perfect_Forward_Secrecy: complete proof (27 steps)

------------------------------------------------------------------------------

==============================================================================
summary of processed files:

analyzed: data/examples/SignedDH.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 3.891899s
  Perfect_Forward_Secrecy: complete proof (27 steps)

==============================================================================
*/
