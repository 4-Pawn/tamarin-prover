theory CSF11_RunningExample begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, sign/2, snd/1,
           true/0, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true()

text{* Running example from:

Stephanie Delaune, Steve Kremer, Mark D. Ryan, Graham Steel, "Formal Analysis
of Protocols Based on TPM State Registers," csf, pp.66-80, 2011 IEEE 24th
Computer Security Foundations Symposium, 2011.

Modeler: Simon Meier
Date:    June 2012
Status:  Working

*}

rule (modulo E) PCR_Init:
   [ Fr( ~aik ) ]
  --[ PCR_Init( 'pcr0', ~aik ), UniqueInit( ) ]->
   [ PCR( 'pcr0' ), !AIK( ~aik ), Out( pk(~aik) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) PCR_Extend:
   [ PCR( x ), In( y ) ]
  --[ PCR_Extend( x, y, h(<x, y>) ) ]->
   [ PCR( h(<x, y>) ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) PCR_CertKey:
   [ !AIK( aik ), !KeyTable( x, sk ) ]
  --[ PCR_CertKey_Inst( x ) ]->
   [ Out( sign(<'certkey', x, pk(sk)>, aik) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) PCR_Unbind:
   [ PCR( x ), !KeyTable( x, sk ), In( aenc(m, pk(sk)) ) ]
  --[ PCR_Unbind( x, sk, m ) ]->
   [ PCR( x ), Out( m ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Alice_Init:
   [
   Fr( ~s0 ), Fr( ~s1 ), !AIK( aik ), In( sign(<'certkey', x0, pk0>, aik) ),
   In( sign(<'certkey', x1, pk1>, aik) )
   ]
  --[ Ineq( x0, x1 ), Secrets( ~s0, ~s1 ) ]->
   [ Out( aenc(~s0, pk0) ), Out( aenc(~s1, pk1) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) MkKey:
   [ Fr( ~ska ) ] --> [ !KeyTable( h(<'pcr0', $a>), ~ska ) ]

  /* has exactly the trivial AC variant */

lemma (modulo E) types [typing]:
  all-traces
  "All m d1.1 d2.2 #i.3.
    (PCR_Unbind( d1.1, d2.2, m ) @ #i.3) ==>
    (((Ex f.4 #j.5. (!KU( f.4, m ) @ #j.5) & (#j.5 < #i.3)) |
      (Ex s.6 #j.7. Secrets( m, s.6 ) @ #j.7)) |
     (Ex s.8 #j.9. Secrets( s.8, m ) @ #j.9))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all counter-examples:
"Ex m d1.1 d2.2 #i.3.
  (PCR_Unbind( d1.1, d2.2, m ) @ #i.3)
 &
  (All f.4 #j.5. (!KU( f.4, m ) @ #j.5) ==> All . (#j.5 < #i.3) ==> F) &
  (All s.6 #j.7. (Secrets( m, s.6 ) @ #j.7) ==> F) &
  (All s.8 #j.9. (Secrets( s.8, m ) @ #j.9) ==> F)"
*/
induction
  case induction
  simplify
  solve( Disj(Last(#i)) |
             (Ex f.1 #j.2.
               (!KU( f.1, m ) @ #j.2)
              &
               (All . (Last(#j.2)) ==> F) & (#j.2 < #i)) |
             (Ex s.1 #j.2. (Secrets( m, s.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) |
             (Ex s.1 #j.2. (Secrets( s.1, m ) @ #j.2) & All . (Last(#j.2)) ==> F) )
    case case_1
    solve( (#i, 1)[!KeyTable( d1, d2 )] )
      case MkKey
      solve( !KU( f_, aenc(m, pk(~ska)) ) @ #vk )
        case Alice_Init_case_1
        by contradiction // from formulas
      next
        case Alice_Init_case_2
        by contradiction // from formulas
      next
        case PCR_Unbind
        solve( Disj(Ex f.2 #j.3.
                     (!KU( f.2, t ) @ #j.3)
                    &
                     (All . (Last(#j.3)) ==> F) & (#j.3 < #vr.1)) |
                   (Ex s.1 #j.2. (Secrets( t, s.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                   (Ex s.1 #j.2. (Secrets( s.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) )
          case case_1
          by contradiction // cyclic
        next
          case case_2
          by solve( (#vl, 0) ~~> (#vk, 0) )
        next
          case case_3
          by solve( (#vl, 0) ~~> (#vk, 0) )
        qed
      next
        case caenc
        by contradiction // from formulas
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  next
    case case_4
    by contradiction // from formulas
  qed
qed

lemma (modulo E) Unbind_PCR_Value [reuse, use_induction]:
  all-traces
  "All x sk.1 m.2 #i.3.
    (PCR_Unbind( x, sk.1, m.2 ) @ #i.3) ==>
    (((Ex aik.4 #j.5. PCR_Init( x, aik.4 ) @ #j.5) |
      (Ex y.6 xPrev.7 #j.8. PCR_Extend( xPrev.7, y.6, x ) @ #j.8)) |
     (Ex #i.9 #j.10.
       ((UniqueInit( ) @ #j.10) & (UniqueInit( ) @ #i.9)) &
       (not(#i.9 = #j.10))))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all counter-examples:
"Ex x sk.1 m.2 #i.3.
  (PCR_Unbind( x, sk.1, m.2 ) @ #i.3)
 &
  (All aik.4 #j.5. (PCR_Init( x, aik.4 ) @ #j.5) ==> F) &
  (All y.6 xPrev.7 #j.8. (PCR_Extend( xPrev.7, y.6, x ) @ #j.8) ==> F) &
  (All #i.9 #j.10.
    (UniqueInit( ) @ #j.10) & (UniqueInit( ) @ #i.9)
   ==>
    #i.9 = #j.10)"
*/
induction
  case induction
  simplify
  solve( Disj(Last(#i)) |
             (Ex aik.1 #j.2.
               (PCR_Init( x, aik.1 ) @ #j.2)
              &
               All . (Last(#j.2)) ==> F) |
             (Ex y.1 xPrev.2 #j.3.
               (PCR_Extend( xPrev.2, y.1, x ) @ #j.3)
              &
               All . (Last(#j.3)) ==> F) |
             (Ex #i #j.1.
               (UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)
              &
               (All . (Last(#j.1)) ==> F) &
               (All . (Last(#i)) ==> F) &
               (All . (#i = #j.1) ==> F)) )
    case case_1
    solve( (#i, 1)[!KeyTable( x, sk )] )
      case MkKey
      solve( !KU( f_, aenc(m, pk(~ska)) ) @ #vk )
        case Alice_Init_case_1
        solve( !KU( f_, sign(<'certkey', x0, pk(~ska)>, ~aik) ) @ #vk.1 )
          case PCR_CertKey
          solve( !KU( f_, sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.2 )
            case PCR_CertKey
            solve( (#i, 0)[PCR( h(<'pcr0', $a>) )] )
              case PCR_Extend
              by contradiction // from formulas
            next
              case PCR_Unbind
              solve( Disj(Ex aik.1 #j.2.
                           (PCR_Init( h(<'pcr0', $a>), aik.1 ) @ #j.2)
                          &
                           All . (Last(#j.2)) ==> F) |
                         (Ex y.1 xPrev.2 #j.3.
                           (PCR_Extend( xPrev.2, y.1, h(<'pcr0', $a>) ) @ #j.3)
                          &
                           All . (Last(#j.3)) ==> F) |
                         (Ex #i #j.1.
                           (UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)
                          &
                           (All . (Last(#j.1)) ==> F) &
                           (All . (Last(#i)) ==> F) &
                           (All . (#i = #j.1) ==> F)) )
                case case_2
                by contradiction // from formulas
              next
                case case_3
                by contradiction // from formulas
              qed
            qed
          next
            case csign
            by solve( !KU( f_.1, ~aik ) @ #vk.4 )
          qed
        next
          case csign
          by solve( !KU( f_.1, ~aik ) @ #vk.4 )
        qed
      next
        case Alice_Init_case_2
        solve( !KU( f_, sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.1 )
          case PCR_CertKey
          solve( !KU( f_, sign(<'certkey', x1, pk(~ska)>, ~aik) ) @ #vk.2 )
            case PCR_CertKey
            solve( (#i, 0)[PCR( h(<'pcr0', $a>) )] )
              case PCR_Extend
              by contradiction // from formulas
            next
              case PCR_Unbind
              solve( Disj(Ex aik.1 #j.2.
                           (PCR_Init( h(<'pcr0', $a>), aik.1 ) @ #j.2)
                          &
                           All . (Last(#j.2)) ==> F) |
                         (Ex y.1 xPrev.2 #j.3.
                           (PCR_Extend( xPrev.2, y.1, h(<'pcr0', $a>) ) @ #j.3)
                          &
                           All . (Last(#j.3)) ==> F) |
                         (Ex #i #j.1.
                           (UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)
                          &
                           (All . (Last(#j.1)) ==> F) &
                           (All . (Last(#i)) ==> F) &
                           (All . (#i = #j.1) ==> F)) )
                case case_2
                by contradiction // from formulas
              next
                case case_3
                by contradiction // from formulas
              qed
            qed
          next
            case csign
            by solve( !KU( f_.1, ~aik ) @ #vk.4 )
          qed
        next
          case csign
          by solve( !KU( f_.1, ~aik ) @ #vk.4 )
        qed
      next
        case caenc
        solve( !KU( f_.1, pk(~ska) ) @ #vk.2 )
          case cpk
          by solve( !KU( f_.1, ~ska ) @ #vk.3 )
        qed
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  next
    case case_4
    by contradiction // from formulas
  qed
qed

lemma (modulo E) secrecy:
  all-traces
  "((All #i #j.1.
      ((UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)) ==> (#i = #j.1)) &
    (All t.2 #e.3. (Ineq( t.2, t.2 ) @ #e.3) ==> (F))) ==>
   (not(Ex s0.4 s1.5 #i.6 #d0.7 #d1.8.
         ((Secrets( s0.4, s1.5 ) @ #i.6) & (K( s0.4 ) @ #d0.7)) &
         (K( s1.5 ) @ #d1.8)))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all counter-examples:
"(All #i #j.1.
   (UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)
  ==>
   #i = #j.1) &
 (All t.2 #e.3. (Ineq( t.2, t.2 ) @ #e.3) ==> F) &
 (Ex s0.4 s1.5 #i.6 #d0.7 #d1.8.
   (Secrets( s0.4, s1.5 ) @ #i.6) &
   (K( s0.4 ) @ #d0.7) &
   (K( s1.5 ) @ #d1.8)
  &
   T)"
*/
simplify
solve( (#i, 2)[!AIK( aik )] )
  case PCR_Init
  solve( !KU( f_, ~s0 ) @ #vk.2 )
    case Alice_Init
    solve( !KU( f_, ~s1 ) @ #vk.3 )
      case Alice_Init
      solve( !KU( f_.1, sign(<'certkey', x0, pk(x)>, ~aik) ) @ #vk.2 )
        case PCR_CertKey
        by solve( !KU( f_, ~ska ) @ #vk.4 )
      next
        case csign
        by solve( !KU( f_.2, ~aik ) @ #vk.7 )
      qed
    next
      case PCR_Unbind
      solve( Disj(Ex aik.1 #j.2.
                   (PCR_Init( h(<'pcr0', $a>), aik.1 ) @ #j.2)
                  &
                   T) |
                 (Ex y.1 xPrev.2 #j.3.
                   (PCR_Extend( xPrev.2, y.1, h(<'pcr0', $a>) ) @ #j.3)
                  &
                   T) |
                 (Ex #i #j.1.
                   (UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)
                  &
                   All . (#i = #j.1) ==> F) )
        case case_2
        solve( !KU( f_.1, sign(<'certkey', x0, pk(x)>, ~aik) ) @ #vk.2 )
          case PCR_CertKey
          by solve( !KU( f_, ~ska ) @ #vk.4 )
        next
          case csign
          by solve( !KU( f_.2, ~aik ) @ #vk.8 )
        qed
      next
        case case_3
        by contradiction // from formulas
      qed
    qed
  next
    case PCR_Unbind
    solve( Disj(Ex aik.1 #j.2.
                 (PCR_Init( h(<'pcr0', $a>), aik.1 ) @ #j.2)
                &
                 T) |
               (Ex y.1 xPrev.2 #j.3.
                 (PCR_Extend( xPrev.2, y.1, h(<'pcr0', $a>) ) @ #j.3)
                &
                 T) |
               (Ex #i #j.1.
                 (UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)
                &
                 All . (#i = #j.1) ==> F) )
      case case_2
      solve( !KU( f_, ~s1 ) @ #vk.3 )
        case Alice_Init
        solve( !KU( f_, sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.2 )
          case PCR_CertKey
          solve( !KU( f_, sign(<'certkey', x1, pk(x)>, ~aik) ) @ #vk.3 )
            case PCR_CertKey
            by solve( !KU( f_, ~ska.1 ) @ #vk.6 )
          next
            case csign
            by solve( !KU( f_.1, ~aik ) @ #vk.8 )
          qed
        next
          case csign
          by solve( !KU( f_.1, ~aik ) @ #vk.8 )
        qed
      next
        case PCR_Unbind
        solve( Disj(Ex aik.2 #j.3.
                     (PCR_Init( h(<'pcr0', $a.1>), aik.2 ) @ #j.3)
                    &
                     T) |
                   (Ex y.2 xPrev.3 #j.4.
                     (PCR_Extend( xPrev.3, y.2, h(<'pcr0', $a.1>) ) @ #j.4)
                    &
                     T) |
                   (Ex #i #j.1.
                     (UniqueInit( ) @ #j.1) & (UniqueInit( ) @ #i)
                    &
                     All . (#i = #j.1) ==> F) )
          case case_2
          solve( !KU( f_, sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.2 )
            case PCR_CertKey
            solve( !KU( f_, sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.3 )
              case PCR_CertKey
              solve( !KU( f_, aenc(~s0, pk(~ska.2)) ) @ #vk.4 )
                case Alice_Init
                solve( !KU( f_.1, aenc(~s1, pk(~ska.2)) ) @ #vk.6 )
                  case Alice_Init
                  solve( (#vr.1, 0)[PCR( h(<'pcr0', $a>) )] )
                    case PCR_Extend
                    solve( (#j, 0)[PCR( 'pcr0' )] )
                      case PCR_Init
                      solve( (#vr.3, 0)[PCR( h(<'pcr0', $a.1>) )] )
                        case PCR_Extend
                        solve( (#j.1, 0)[PCR( 'pcr0' )] )
                          case PCR_Init
                          by contradiction // from formulas
                        qed
                      next
                        case PCR_Unbind
                        solve( !KU( f_.2, aenc(m, pk(~ska.2)) ) @ #vk.8 )
                          case Alice_Init_case_1
                          solve( !KU( f_.2, sign(<'certkey', x0, pk(~ska.2)>, ~aik) ) @ #vk.9 )
                            case PCR_CertKey
                            solve( !KU( f_.2, sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.10 )
                              case PCR_CertKey
                              solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case csign
                              by solve( !KU( f_.3, ~aik ) @ #vk.12 )
                            qed
                          next
                            case csign
                            by solve( !KU( f_.2, ~aik ) @ #vk.12 )
                          qed
                        next
                          case Alice_Init_case_2
                          solve( !KU( f_.2, sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.9 )
                            case PCR_CertKey
                            solve( !KU( f_.2, sign(<'certkey', x1, pk(~ska.2)>, ~aik) ) @ #vk.10 )
                              case PCR_CertKey
                              solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case csign
                              by solve( !KU( f_.3, ~aik ) @ #vk.12 )
                            qed
                          next
                            case csign
                            by solve( !KU( f_.2, ~aik ) @ #vk.12 )
                          qed
                        next
                          case caenc
                          solve( !KU( f_.2, pk(~ska.2) ) @ #vk.10 )
                            case cpk
                            by solve( !KU( f_.3, ~ska.2 ) @ #vk.11 )
                          qed
                        qed
                      qed
                    qed
                  next
                    case PCR_Unbind
                    solve( !KU( f_.2, aenc(m, pk(~ska.2)) ) @ #vk.8 )
                      case Alice_Init_case_1
                      solve( !KU( f_.2, sign(<'certkey', x0, pk(~ska.2)>, ~aik) ) @ #vk.9 )
                        case PCR_CertKey
                        solve( !KU( f_.2, sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.10 )
                          case PCR_CertKey
                          solve( (#j, 0)[PCR( 'pcr0' )] )
                            case PCR_Init
                            solve( (#vr.3, 0)[PCR( h(<'pcr0', $a.1>) )] )
                              case PCR_Extend
                              solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case PCR_Unbind
                              solve( !KU( f_.2, aenc(m, pk(~ska.4)) ) @ #vk.11 )
                                case Alice_Init_case_1
                                solve( !KU( f_.2, sign(<'certkey', x0, pk(~ska.4)>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( f_.2, sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                qed
                              next
                                case Alice_Init_case_2
                                solve( !KU( f_.2, sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( f_.2, sign(<'certkey', x1, pk(~ska.4)>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                qed
                              next
                                case caenc
                                solve( !KU( f_.3, pk(~ska.4) ) @ #vk.13 )
                                  case cpk
                                  by solve( !KU( f_.3, ~ska.4 ) @ #vk.14 )
                                qed
                              qed
                            qed
                          qed
                        next
                          case csign
                          by solve( !KU( f_.3, ~aik ) @ #vk.12 )
                        qed
                      next
                        case csign
                        by solve( !KU( f_.2, ~aik ) @ #vk.12 )
                      qed
                    next
                      case Alice_Init_case_2
                      solve( !KU( f_.2, sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.9 )
                        case PCR_CertKey
                        solve( !KU( f_.2, sign(<'certkey', x1, pk(~ska.2)>, ~aik) ) @ #vk.10 )
                          case PCR_CertKey
                          solve( (#j, 0)[PCR( 'pcr0' )] )
                            case PCR_Init
                            solve( (#vr.3, 0)[PCR( h(<'pcr0', $a.1>) )] )
                              case PCR_Extend
                              solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                case PCR_Init
                                by contradiction // from formulas
                              qed
                            next
                              case PCR_Unbind
                              solve( !KU( f_.2, aenc(m, pk(~ska.4)) ) @ #vk.11 )
                                case Alice_Init_case_1
                                solve( !KU( f_.2, sign(<'certkey', x0, pk(~ska.4)>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( f_.2, sign(<'certkey', x1, pk1>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                qed
                              next
                                case Alice_Init_case_2
                                solve( !KU( f_.2, sign(<'certkey', x0, pk0>, ~aik) ) @ #vk.12 )
                                  case PCR_CertKey
                                  solve( !KU( f_.2, sign(<'certkey', x1, pk(~ska.4)>, ~aik) ) @ #vk.13 )
                                    case PCR_CertKey
                                    solve( (#j.1, 0)[PCR( 'pcr0' )] )
                                      case PCR_Init
                                      by contradiction // from formulas
                                    qed
                                  next
                                    case csign
                                    by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                  qed
                                next
                                  case csign
                                  by solve( !KU( f_.3, ~aik ) @ #vk.15 )
                                qed
                              next
                                case caenc
                                solve( !KU( f_.3, pk(~ska.4) ) @ #vk.13 )
                                  case cpk
                                  by solve( !KU( f_.3, ~ska.4 ) @ #vk.14 )
                                qed
                              qed
                            qed
                          qed
                        next
                          case csign
                          by solve( !KU( f_.3, ~aik ) @ #vk.12 )
                        qed
                      next
                        case csign
                        by solve( !KU( f_.2, ~aik ) @ #vk.12 )
                      qed
                    next
                      case caenc
                      solve( !KU( f_.2, pk(~ska.2) ) @ #vk.10 )
                        case cpk
                        by solve( !KU( f_.3, ~ska.2 ) @ #vk.11 )
                      qed
                    qed
                  qed
                next
                  case caenc
                  by contradiction // cyclic
                qed
              next
                case caenc
                by contradiction // cyclic
              qed
            next
              case csign
              by solve( !KU( f_.1, ~aik ) @ #vk.9 )
            qed
          next
            case csign
            by solve( !KU( f_.1, ~aik ) @ #vk.9 )
          qed
        next
          case case_3
          by contradiction // from formulas
        qed
      qed
    next
      case case_3
      by contradiction // from formulas
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.
 checking installation: OK.


analyzing: data/examples/related_work/TPM_DKRS_CSF11/RunningExample.spthy

------------------------------------------------------------------------------
analyzed: data/examples/related_work/TPM_DKRS_CSF11/RunningExample.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 1.441132s
  types (all-traces): verified (15 steps)
  Unbind_PCR_Value (all-traces): verified (28 steps)
  secrecy (all-traces): verified (99 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: data/examples/related_work/TPM_DKRS_CSF11/RunningExample.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 1.441132s
  types (all-traces): verified (15 steps)
  Unbind_PCR_Value (all-traces): verified (28 steps)
  secrecy (all-traces): verified (99 steps)

==============================================================================
*/
