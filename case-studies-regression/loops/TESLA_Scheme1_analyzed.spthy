theory TESLA_Scheme1 begin

// Function signature and definition of the equational theory E

functions: MAC/2, f/1, fst/1, pair/2, pk/1, sign/2, snd/1, true/0,
           verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true()

rule (modulo E) Generate_Keypair:
   [ Fr( ~ltk ) ]
  -->
   [ !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) ), Out( pk(~ltk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_Ltk:
   [ !Ltk( A, ltk ) ] --[ RevealLtk( A ) ]-> [ Out( ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sender_Setup:
   [ Fr( ~k1 ) ] --> [ Sender1( ~k1 ), !Sender0a( ~k1 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sender0a:
   [ !Sender0a( k1 ), In( <R, S, nR> ), !Ltk( S, ltkS ) ]
  -->
   [ Out( <S, R, f(k1), sign(<f(k1), nR>, ltkS)> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receiver0a:
   [ Fr( ~nR ) ] --> [ Out( <$R, $S, ~nR> ), Receiver0b( $R, $S, ~nR ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receiver0b:
   [ Receiver0b( R, S, nR ), !Pk( S, pkS ), In( <S, R, k2, signature> ) ]
  -->
   [ Receiver0b_check( S, k2, verify(signature, <k2, nR>, pkS) ) ]

  /*
  rule (modulo AC) Receiver0b:
     [ Receiver0b( R, S, nR ), !Pk( S, pkS ), In( <S, R, k2, signature> ) ]
    -->
     [ Receiver0b_check( S, k2, z ) ]
    variants (modulo AC)
    1. k2    = k2.8
       nR    = nR.8
       pkS   = pkS.8
       signature
             = signature.8
       z     = verify(signature.8, <k2.8, nR.8>, pkS.8)
    
    2. k2    = x.10
       nR    = x.9
       pkS   = pk(x.8)
       signature
             = sign(<x.10, x.9>, x.8)
       z     = true()
  */

rule (modulo E) Receiver0b_check:
   [ Receiver0b_check( S, k2, true() ) ] --> [ Receiver1( S, k2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Send1:
   [ Sender1( ~k1 ), Fr( ~m1 ), Fr( ~k2 ) ]
  --[ Sent( <'1', ~m1, f(~k2)> ) ]->
   [
   Sender( ~k1, ~k2 ),
   Out( <<'1', ~m1, f(~k2)>, MAC(<'1', ~m1, f(~k2)>, ~k1)> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Recv1:
   [ Receiver1( S, commit_k1 ), In( <<'1', m1, commit_k2>, mac1> ) ]
  --[ AssumeCommitNotExpired( commit_k1 ) ]->
   [ Receiver( S, <'1', m1, commit_k2>, mac1, commit_k1, commit_k2 ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) SendN:
   [ Sender( ~kOld, ~k ), Fr( ~m ), Fr( ~kNew ) ]
  --[ Sent( <'N', ~m, f(~kNew), ~kOld> ), CommitExpired( f(~kOld) ) ]->
   [
   Sender( ~k, ~kNew ),
   Out( <<'N', ~m, f(~kNew), ~kOld>, MAC(<'N', ~m, f(~kNew), ~kOld>, ~k)> )
   ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) RecvN:
   [
   In( <<'N', m, commit_kNew, kOld>, mac> ),
   Receiver( S, dataOld, MAC(dataOld, kOld), f(kOld), commit_k )
   ]
  --[ FromSender( S, dataOld ), AssumeCommitNotExpired( commit_k ) ]->
   [ Receiver( S, <'N', m, commit_kNew, kOld>, mac, commit_k, commit_kNew )
   ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

lemma authentic [use_induction]:
  all-traces
  "(∀ commit #i #j.
     ((AssumeCommitNotExpired( commit ) @ #i) ∧
      (CommitExpired( commit ) @ #j)) ⇒
     (#i < #j)) ⇒
   (∀ S m #i.
     (FromSender( S, m ) @ #i) ⇒
     ((∃ #j. (Sent( m ) @ #j) ∧ (#j < #i)) ∨
      (∃ #j. (RevealLtk( S ) @ #j) ∧ (#j < #i))))"
/*
guarded formula characterizing all counter-examples:
"(∀ commit #i #j.
   (AssumeCommitNotExpired( commit ) @ #i) ∧ (CommitExpired( commit ) @ #j)
  ⇒
   #i < #j) ∧
 (∃ S m #i.
   (FromSender( S, m ) @ #i)
  ∧
   (∀ #j. (Sent( m ) @ #j) ⇒ ¬(#j < #i)) ∧
   (∀ #j. (RevealLtk( S ) @ #j) ⇒ ¬(#j < #i)))"
*/
induction
  case empty_trace
  by contradiction // from formulas
next
  case non_empty_trace
  simplify
  solve( (∃ commit #i #j.
           (AssumeCommitNotExpired( commit ) @ #i) ∧ (CommitExpired( commit ) @ #j)
          ∧
           (¬(last(#j))) ∧ (¬(last(#i))) ∧ ((#i = #j) ∨ (#j < #i)))  ∥
         (∀ S m #i.
           (FromSender( S, m ) @ #i)
          ⇒
           (last(#i)) ∨
           (∃ #j. (Sent( m ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) ∨
           (∃ #j. (RevealLtk( S ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))) )
    case case_1
    by contradiction // from formulas
  next
    case case_2
    solve( (last(#i))  ∥
           (∃ #j. (Sent( m.1 ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i))  ∥
           (∃ #j. (RevealLtk( S ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #i)) )
      case case_1
      solve( Receiver( S, m.1, MAC(m.1, kOld), f(kOld), commit_k ) ▶₁ #i )
        case Recv1
        solve( !KU( sign(<f(kOld), ~nR>, ~ltk) ) @ #vk.22 )
          case Sender0a
          solve( !KU( ~k1 ) @ #vk.8 )
            case SendN
            solve( !KU( MAC(<'1', m1, commit_k>, ~k1) ) @ #vk.17 )
              case Send1
              by contradiction // from formulas
            next
              case cMAC
              by contradiction // cyclic
            qed
          qed
        next
          case csign
          solve( !KU( ~ltk ) @ #vk.24 )
            case Reveal_Ltk
            by contradiction // from formulas
          next
            case SendN
            solve( !KU( ~nR ) @ #vk.25 )
              case Receiver0a
              solve( !KU( MAC(<'1', m1, commit_k>, kOld) ) @ #vk.20 )
                case Send1
                by contradiction // from formulas
              next
                case cMAC
                solve( !KU( f(kOld) ) @ #vk.25 )
                  case Send1
                  solve( !KU( ~k2 ) @ #vk.17 )
                    case SendN
                    by contradiction // cyclic
                  qed
                next
                  case SendN
                  solve( !KU( ~kNew ) @ #vk.17 )
                    case SendN
                    by contradiction // cyclic
                  qed
                next
                  case Sender0a
                  solve( !KU( ~k1 ) @ #vk.17 )
                    case SendN
                    by contradiction // cyclic
                  qed
                next
                  case cf
                  solve( Sender( ~ltk, ~k ) ▶₀ #vr.5 )
                    case SendN
                    by solve( Sender( ~kOld.1, ~ltk ) ▶₀ #vr.12 )
                  qed
                qed
              qed
            next
              case SendN
              solve( !KU( MAC(<'1', m1, commit_k>, kOld) ) @ #vk.20 )
                case Send1
                by contradiction // from formulas
              next
                case cMAC
                solve( !KU( f(kOld) ) @ #vk.25 )
                  case Send1
                  solve( !KU( ~k2 ) @ #vk.17 )
                    case SendN
                    by contradiction // cyclic
                  qed
                next
                  case SendN
                  solve( !KU( ~kNew ) @ #vk.17 )
                    case SendN
                    by contradiction // cyclic
                  qed
                next
                  case Sender0a
                  solve( !KU( ~k1 ) @ #vk.17 )
                    case SendN
                    by contradiction // cyclic
                  qed
                next
                  case cf
                  solve( Sender( ~ltk, ~k ) ▶₀ #vr.5 )
                    case SendN
                    solve( Sender( ~nR, ~k.1 ) ▶₀ #vr.10 )
                      case SendN
                      by solve( Sender( ~kOld.1, ~ltk ) ▶₀ #vr.15 )
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      next
        case RecvN
        solve( (∃ #j. (Sent( dataOld ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr))  ∥
               (∃ #j. (RevealLtk( S ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr)) )
          case case_1
          solve( Sent( dataOld ) @ #j )
            case Send1
            solve( Sender1( ~k1 ) ▶₀ #j )
              case Sender_Setup
              solve( Receiver( S, <'1', ~m1, f(~k2)>, MAC(<'1', ~m1, f(~k2)>, kOld.1),
                               f(kOld.1), f(kOld)
                     ) ▶₁ #vr )
                case Recv1
                solve( !KU( ~k2 ) @ #vk.9 )
                  case SendN
                  solve( !KU( MAC(<'N', m.1, commit_k, kOld>, ~k2) ) @ #vk.16 )
                    case SendN
                    by contradiction // from formulas
                  next
                    case cMAC
                    by contradiction // cyclic
                  qed
                qed
              qed
            qed
          next
            case SendN
            solve( Receiver( S, <'N', ~m.2, f(~kNew), ~kOld.2>,
                             MAC(<'N', ~m.2, f(~kNew), ~kOld.2>, kOld.1), f(kOld.1), f(kOld)
                   ) ▶₁ #vr )
              case RecvN
              solve( (∃ #j. (Sent( dataOld ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1))  ∥
                     (∃ #j. (RevealLtk( S ) @ #j) ∧ (¬(last(#j))) ∧ (#j < #vr.1)) )
                case case_1
                solve( Sent( dataOld ) @ #j.1 )
                  case Send1
                  solve( Sender1( ~k1 ) ▶₀ #j.1 )
                    case Sender_Setup
                    solve( !KU( ~kNew ) @ #vk.11 )
                      case SendN
                      solve( !KU( MAC(<'N', m.1, commit_k, kOld>, ~kNew) ) @ #vk.18 )
                        case SendN
                        by contradiction // from formulas
                      next
                        case cMAC
                        by contradiction // cyclic
                      qed
                    qed
                  qed
                next
                  case SendN
                  solve( !KU( ~kNew ) @ #vk.11 )
                    case SendN
                    solve( !KU( MAC(<'N', m.1, commit_k, kOld>, ~kNew) ) @ #vk.18 )
                      case SendN
                      by contradiction // from formulas
                    next
                      case cMAC
                      by contradiction // cyclic
                    qed
                  qed
                qed
              next
                case case_2
                by contradiction // from formulas
              qed
            qed
          qed
        next
          case case_2
          by contradiction // from formulas
        qed
      qed
    next
      case case_2
      by contradiction // from formulas
    next
      case case_3
      by contradiction // from formulas
    qed
  qed
qed

lemma authentic_reachable [use_induction]:
  exists-trace
  "(∀ commit #i #j.
     ((AssumeCommitNotExpired( commit ) @ #i) ∧
      (CommitExpired( commit ) @ #j)) ⇒
     (#i < #j)) ∧
   (∃ S m #i. FromSender( S, m ) @ #i)"
/*
guarded formula characterizing all satisfying traces:
"(∀ commit #i #j.
   (AssumeCommitNotExpired( commit ) @ #i) ∧ (CommitExpired( commit ) @ #j)
  ⇒
   #i < #j) ∧
 (∃ S m #i. (FromSender( S, m ) @ #i))"
*/
induction
  case non_empty_trace
  simplify
  solve( (∃ commit #i #j.
           (AssumeCommitNotExpired( commit ) @ #i) ∧ (CommitExpired( commit ) @ #j)
          ∧
           (¬(last(#j))) ∧ (¬(last(#i))) ∧ ((#i = #j) ∨ (#j < #i)))  ∥
         (∀ S m #i. (FromSender( S, m ) @ #i) ⇒ last(#i)) )
    case case_2
    solve( Receiver( S, m.1, MAC(m.1, kOld), f(kOld), commit_k ) ▶₁ #i )
      case Recv1
      solve( !KU( sign(<f(kOld), ~nR>, ~ltk) ) @ #vk.22 )
        case Sender0a
        solve( !KU( ~k1 ) @ #vk.8 )
          case SendN
          solve( !KU( MAC(<'1', m1, commit_k>, ~k1) ) @ #vk.17 )
            case Send1
            solve( !KU( ~nR ) @ #vk.26 )
              case Receiver0a
              solve( !KU( ~m1 ) @ #vk.19 )
                case Send1
                solve( !KU( f(~k1) ) @ #vk.25 )
                  case Sender0a
                  solve( Sender( ~k1, ~k ) ▶₀ #vr.10 )
                    case Send1
                    solve( !KU( f(~k) ) @ #vk.23 )
                      case Send1
                      SOLVED // trace found
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.
 checking installation: OK.


analyzing: data/examples/loops/TESLA_Scheme1.spthy

------------------------------------------------------------------------------
analyzed: data/examples/loops/TESLA_Scheme1.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 1.224744s
  authentic (all-traces): verified (62 steps)
  authentic_reachable (exists-trace): verified (13 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: data/examples/loops/TESLA_Scheme1.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 1.224744s
  authentic (all-traces): verified (62 steps)
  authentic_reachable (exists-trace): verified (13 steps)

==============================================================================
*/
