theory RFID_Simple begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, fst/1, pair/2, pk/1, snd/1
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2

// looping facts with unique instances: Device_Alice/1

rule (modulo E) GenKey:
   [ Fr( ~sk ) ]
  --[ Device_Key( ~sk ) ]->
   [ Device_Init( ~sk ), Device_Alice( ~sk ), Out( pk(~sk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Alice:
   [ Device_Alice( sk ), Fr( ~x ), Fr( ~y ) ]
  --[ Exclusive( ~x, ~y ), Device_Use( sk ) ]->
   [ Device_Alice( sk ), Out( aenc(<~x, ~y>, pk(sk)) ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) DeviceToBob:
   [ Device_Init( sk ), Device_Alice( sk ) ]
  --[ ToBob( sk ) ]->
   [ Device_Select( sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Select_Left:
   [ Device_Select( sk ) ] --> [ !Device_Left( sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Select_Right:
   [ Device_Select( sk ) ] --> [ !Device_Right( sk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Decrypt_Left:
   [ !Device_Left( sk ), In( aenc(<x, y>, pk(sk)) ) ]
  --[ Access( x ) ]->
   [ Out( x ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Decrypt_Right:
   [ !Device_Right( sk ), In( aenc(<x, y>, pk(sk)) ) ]
  --[ Access( y ) ]->
   [ Out( y ) ]

  /* has exactly the trivial AC variant */

lemma (modulo E) types [typing]:
  all-traces
  "All m #i.1.
    (Access( m ) @ #i.1) ==>
    (((Ex f.2 #j.3. (!KU( f.2, m ) @ #j.3) & (#j.3 < #i.1)) |
      (Ex x.4 #j.5. Exclusive( x.4, m ) @ #j.5)) |
     (Ex y.6 #j.7. Exclusive( m, y.6 ) @ #j.7))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all counter-examples:
"Ex m #i.1.
  (Access( m ) @ #i.1)
 &
  (All f.2 #j.3. (!KU( f.2, m ) @ #j.3) ==> All . (#j.3 < #i.1) ==> F) &
  (All x.4 #j.5. (Exclusive( x.4, m ) @ #j.5) ==> F) &
  (All y.6 #j.7. (Exclusive( m, y.6 ) @ #j.7) ==> F)"
*/
induction
  case induction
  simplify
  solve( Disj(Last(#i)) |
             (Ex f.1 #j.2.
               (!KU( f.1, m ) @ #j.2)
              &
               (All . (Last(#j.2)) ==> F) & (#j.2 < #i)) |
             (Ex x.1 #j.2. (Exclusive( x.1, m ) @ #j.2) & All . (Last(#j.2)) ==> F) |
             (Ex y.1 #j.2. (Exclusive( m, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
    case case_1
    solve( Access( m ) @ #i )
      case Decrypt_Left
      solve( (#i, 0)[!Device_Left( sk )] )
        case Select_Left_case_1
        solve( !KU( f_, aenc(<m, y>, pk(~sk)) ) @ #vk )
          case Alice
          by contradiction // from formulas
        next
          case Decrypt_Left_case_1
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Left_case_2
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_1
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_2
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case caenc
          by contradiction // from formulas
        qed
      next
        case Select_Left_case_2
        solve( !KU( f_, aenc(<m, y>, pk(~sk)) ) @ #vk )
          case Alice
          by contradiction // from formulas
        next
          case Decrypt_Left_case_1
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Left_case_2
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_1
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_2
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case caenc
          by contradiction // from formulas
        qed
      qed
    next
      case Decrypt_Right
      solve( (#i, 0)[!Device_Right( sk )] )
        case Select_Right_case_1
        solve( !KU( f_, aenc(<x, m>, pk(~sk)) ) @ #vk )
          case Alice
          by contradiction // from formulas
        next
          case Decrypt_Left_case_1
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Left_case_2
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_1
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_2
          solve( Disj(Ex f.4 #j.5.
                       (!KU( f.4, t ) @ #j.5)
                      &
                       (All . (Last(#j.5)) ==> F) & (#j.5 < #vr.3)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case caenc
          by contradiction // from formulas
        qed
      next
        case Select_Right_case_2
        solve( !KU( f_, aenc(<x, m>, pk(~sk)) ) @ #vk )
          case Alice
          by contradiction // from formulas
        next
          case Decrypt_Left_case_1
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Left_case_2
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_1
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case Decrypt_Right_case_2
          solve( Disj(Ex f.5 #j.6.
                       (!KU( f.5, t ) @ #j.6)
                      &
                       (All . (Last(#j.6)) ==> F) & (#j.6 < #vr.4)) |
                     (Ex x.1 #j.2. (Exclusive( x.1, t ) @ #j.2) & All . (Last(#j.2)) ==> F) |
                     (Ex y.1 #j.2. (Exclusive( t, y.1 ) @ #j.2) & All . (Last(#j.2)) ==> F) )
            case case_1
            by contradiction // cyclic
          next
            case case_2
            by solve( (#vl, 0) ~~> (#vk, 0) )
          next
            case case_3
            by solve( (#vl, 0) ~~> (#vk, 0) )
          qed
        next
          case caenc
          by contradiction // from formulas
        qed
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  next
    case case_3
    by contradiction // from formulas
  next
    case case_4
    by contradiction // from formulas
  qed
qed

lemma (modulo E) Device_ToBob [use_induction]:
  all-traces
  "All sk #i.1.
    (Device_Use( sk ) @ #i.1) ==>
    (All #j.2. (ToBob( sk ) @ #j.2) ==> (#i.1 < #j.2))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all counter-examples:
"Ex sk #i.1.
  (Device_Use( sk ) @ #i.1)
 &
  Ex #j.2. (ToBob( sk ) @ #j.2) & All . (#i.1 < #j.2) ==> F"
*/
induction
  case induction
  simplify
  solve( Disj(Last(#i)) |
             (All #j.1. (ToBob( sk ) @ #j.1) ==> (Last(#j.1)) | (#i < #j.1)) )
    case case_1
    solve( (#j, 0)[Device_Init( sk )] )
      case GenKey
      solve( (#j, 1)[Device_Alice( ~sk )] )
        case Alice
        solve( (#i, 0)[Device_Alice( ~sk )] )
          case Alice
          by contradiction // non-unique facts (#vr.2,#j,#i)
        next
          case GenKey
          by contradiction // non-unique facts (#vr,#j,#i)
        qed
      next
        case GenKey
        solve( (#i, 0)[Device_Alice( ~sk )] )
          case Alice
          by contradiction // non-unique facts (#vr.1,#j,#i)
        qed
      qed
    qed
  next
    case case_2
    by contradiction // from formulas
  qed
qed

lemma (modulo E) Device_Init_Use_Set [reuse, use_induction]:
  all-traces
  "All sk #i.1.
    (Device_Use( sk ) @ #i.1) ==>
    ((All #j.2. (ToBob( sk ) @ #j.2) ==> (#i.1 < #j.2)) &
     (Ex #j.3. (Device_Key( sk ) @ #j.3) & (#j.3 < #i.1)))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all counter-examples:
"Ex sk #i.1.
  (Device_Use( sk ) @ #i.1)
 &
  (Ex #j.2. (ToBob( sk ) @ #j.2) & All . (#i.1 < #j.2) ==> F) |
  (All #j.3. (Device_Key( sk ) @ #j.3) ==> All . (#j.3 < #i.1) ==> F)"
*/
induction
  case induction
  simplify
  solve( Disj(Ex #j.1. (ToBob( sk ) @ #j.1) & All . (#i < #j.1) ==> F) |
             (All #j.1. (Device_Key( sk ) @ #j.1) ==> All . (#j.1 < #i) ==> F) )
    case case_1
    solve( Disj(Last(#i)) |
               ((All #j.1. (ToBob( sk ) @ #j.1) ==> (Last(#j.1)) | (#i < #j.1)) &
                (Ex #j.2.
                  (Device_Key( sk ) @ #j.2)
                 &
                  (All . (Last(#j.2)) ==> F) & (#j.2 < #i))) )
      case case_1
      solve( (#j, 0)[Device_Init( sk )] )
        case GenKey
        solve( (#j, 1)[Device_Alice( ~sk )] )
          case Alice
          solve( (#i, 0)[Device_Alice( ~sk )] )
            case Alice
            by contradiction // non-unique facts (#vr.2,#j,#i)
          next
            case GenKey
            by contradiction // non-unique facts (#vr,#j,#i)
          qed
        next
          case GenKey
          solve( (#i, 0)[Device_Alice( ~sk )] )
            case Alice
            by contradiction // non-unique facts (#vr,#vr.1,#j)
          qed
        qed
      qed
    next
      case case_2
      by contradiction // from formulas
    qed
  next
    case case_2
    solve( Disj(Last(#i)) |
               ((All #j.1. (ToBob( sk ) @ #j.1) ==> (Last(#j.1)) | (#i < #j.1)) &
                (Ex #j.2.
                  (Device_Key( sk ) @ #j.2)
                 &
                  (All . (Last(#j.2)) ==> F) & (#j.2 < #i))) )
      case case_1
      solve( (#i, 0)[Device_Alice( sk )] )
        case Alice
        by contradiction // from formulas
      next
        case GenKey
        by contradiction // from formulas
      qed
    next
      case case_2
      by contradiction // from formulas
    qed
  qed
qed

lemma (modulo E) reachability_left:
  exists-trace
  "Ex x y.1 #i.2 #j.3. (Exclusive( x, y.1 ) @ #i.2) & (K( x ) @ #j.3)"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all satisfying traces:
"Ex x y.1 #i.2 #j.3. (Exclusive( x, y.1 ) @ #i.2) & (K( x ) @ #j.3) & T"
*/
simplify
solve( !KU( f_, ~x ) @ #vk )
  case Decrypt_Left_case_2
  solve( !KU( f_, aenc(<~x, y.1>, pk(~sk.1)) ) @ #vk.1 )
    case Alice
    solve( (#i, 0)[Device_Alice( ~sk )] )
      case Alice
      solve( (#vr.3, 0)[Device_Alice( ~sk )] )
        case Alice
        solve( (#vr.4, 0)[Device_Alice( ~sk )] )
          case GenKey
          solve( (#vr.5, 0)[Device_Alice( ~sk )] )
            case GenKey
            SOLVED // trace found
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.
 checking installation: OK.


analyzing: data/examples/stateful/RFID_Simple.spthy

------------------------------------------------------------------------------
analyzed: data/examples/stateful/RFID_Simple.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 0.760547s
  types (all-traces): verified (85 steps)
  Device_ToBob (all-traces): verified (11 steps)
  Device_Init_Use_Set (all-traces): verified (17 steps)
  reachability_left (exists-trace): verified (8 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: data/examples/stateful/RFID_Simple.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 0.760547s
  types (all-traces): verified (85 steps)
  Device_ToBob (all-traces): verified (11 steps)
  Device_Init_Use_Set (all-traces): verified (17 steps)
  reachability_left (exists-trace): verified (8 steps)

==============================================================================
*/
