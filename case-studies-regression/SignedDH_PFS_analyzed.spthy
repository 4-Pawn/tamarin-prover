theory SignedDH begin

// Function signature and definition of the equational theory E

builtin: diffie-hellman
functions: fst/1, pair/2, pk/1, sign/2, snd/1, true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true()

section{* The Signed Diffie-Hellman Protocol *}

rule (modulo E) Register_pk:
   [ Fr( ~ltk ) ] --> [ !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Get_pk:
   [ !Pk( A, pk ) ] --> [ Out( pk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ltk:
   [ !Ltk( A, ltk ) ] --[ LtkReveal( A ) ]-> [ Out( ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_1:
   [ Fr( ~ekI ), !Ltk( $I, ltkI ) ]
  -->
   [
   Init_1( $I, $R, ~ekI ),
   Out( <$I, $R, 'g'^~ekI, sign(<'1', $I, $R, 'g'^~ekI>, ltkI)> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_2:
   [
   Init_1( $I, $R, ~ekI ), !Pk( $R, pk(ltkR) ),
   In( <$R, $I, Y, sign(<'2', $R, $I, Y>, ltkR)> )
   ]
  --[ SessionKey( $I, $R, Y^~ekI ) ]->
   [ ]

  /*
  rule (modulo AC) Init_2:
     [
     Init_1( $I.3, $R.4, ~ekI ), !Pk( $R.4, pk(x.5) ),
     In( <$R.4, $I.3, x.2, sign(<'2', $R.4, $I.3, x.2>, x.5)> )
     ]
    --[ SessionKey( $I.3, $R.4, z.1 ) ]->
     [ ]
  
    variants (modulo AC)
    1. ~ekI  = ~ekI.29
       z.1   = z.30
       x.2   = z.30^inv(~ekI.29)
    
    2. ~ekI  = ~ekI.29
       z.1   = x.30^~ekI.29
       x.2   = x.30
    
    3. ~ekI  = ~ekI.30
       z.1   = x.31^x.32
       x.2   = x.31^(x.32*inv(~ekI.30))
    
    4. ~ekI  = ~ekI.30
       z.1   = x.31^inv(x.32)
       x.2   = x.31^inv((~ekI.30*x.32))
    
    5. ~ekI  = ~ekI.30
       z.1   = x.31^(~ekI.30*x.32)
       x.2   = x.31^x.32
    
    6. ~ekI  = ~ekI.31
       z.1   = x.32^(x.33*inv(x.34))
       x.2   = x.32^(x.33*inv((~ekI.31*x.34)))
  */

rule (modulo E) Resp:
   [
   !Pk( $I, pk(ltkI) ), !Ltk( $R, ltkR ), Fr( ~ekR ),
   In( <$I, $R, X, sign(<'1', $I, $R, X>, ltkI)> )
   ]
  --[ SessionKey( $I, $R, X^~ekR ) ]->
   [ Out( <$R, $I, 'g'^~ekR, sign(<'2', $R, $I, 'g'^~ekR>, ltkR)> ) ]

  /*
  rule (modulo AC) Resp:
     [
     !Pk( $I.3, pk(x.4) ), !Ltk( $R.5, ltkR.6 ), Fr( ~ekR ),
     In( <$I.3, $R.5, x.2, sign(<'1', $I.3, $R.5, x.2>, x.4)> )
     ]
    --[ SessionKey( $I.3, $R.5, z.1 ) ]->
     [
     Out( <$R.5, $I.3, 'g'^~ekR, sign(<'2', $R.5, $I.3, 'g'^~ekR>, ltkR.6)> )
     ]
  
    variants (modulo AC)
    1. ~ekR  = ~ekR.49
       z.1   = z.50
       x.2   = z.50^inv(~ekR.49)
    
    2. ~ekR  = ~ekR.49
       z.1   = x.50^~ekR.49
       x.2   = x.50
    
    3. ~ekR  = ~ekR.50
       z.1   = x.51^x.52
       x.2   = x.51^(x.52*inv(~ekR.50))
    
    4. ~ekR  = ~ekR.50
       z.1   = x.51^inv(x.52)
       x.2   = x.51^inv((~ekR.50*x.52))
    
    5. ~ekR  = ~ekR.50
       z.1   = x.51^(~ekR.50*x.52)
       x.2   = x.51^x.52
    
    6. ~ekR  = ~ekR.51
       z.1   = x.52^(x.53*inv(x.54))
       x.2   = x.52^(x.53*inv((~ekR.51*x.54)))
  */

lemma (modulo E) Perfect_Forward_Secrecy:
  "All I R.1 sessKey.2 #i.3 #k.4.
    ((SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)) ==>
    ((Ex #r.5. (LtkReveal( I ) @ #r.5) & (#r.5 < #i.3)) |
     (Ex #r.6. (LtkReveal( R.1 ) @ #r.6) & (#r.6 < #i.3)))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all attacks:
"Ex I R.1 sessKey.2 #i.3 #k.4.
  (SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)
 &
  (All #r.5. (LtkReveal( I ) @ #r.5) ==> All. (#r.5 < #i.3) ==> F) &
  (All #r.6. (LtkReveal( R.1 ) @ #r.6) ==> All. (#r.6 < #i.3) ==> F)"
*/
simplify
solve( SessionKey( I, R.1, sessKey.2 ) @ #i.3 )
  case Init_2
  solve( (#i.3, 0)[Init_1( $I.10, $R.11, ~ekI.7 )] )
    case Init_1
    solve( (#i.3, 1)[!Pk( $R.11, pk(x.12) )] )
      case Register_pk
      solve( KU((#vf.13, 0), sign(<'2', $R.11, $I.10, x.9>, ~ltk.31)) )
        case Resp
        solve( KU((#vf.47, 0), sign(<'1', $I.10, $R.11, x.45>, ~ltk.44)) )
          case Init_1
          solve( splitEqs(1) )
            case split_case_1
            solve( (#k.4, 0)[!KU( f_.5, 'g'^(~ekI.113*~ekR.114) )] /* may loop */ )
              case Init_1
              by solve( (#vr.132, 1)[!KU( f_.133, ~ekR.155 )] /* may loop */ )
            next
              case Resp
              by solve( (#vr.137, 1)[!KU( f_.138, ~ekI.163 )] /* may loop */ )
            next
              case exp
              by solve( KU((#vr.118, 1), ~ekI.113) )
            qed
          next
            case split_case_2
            by contradiction // non-normal terms
          qed
        next
          case sign
          solve( (#vr.81, 1)[!KU( f_.83, ~ltk.44 )] /* may loop */ )
            case Reveal_ltk
            by contradiction // cyclic
          qed
        qed
      next
        case sign
        solve( (#vr.37, 1)[!KU( f_.39, ~ltk.31 )] /* may loop */ )
          case Reveal_ltk
          by contradiction // cyclic
        qed
      qed
    qed
  qed
next
  case Resp
  solve( (#i.3, 0)[!Pk( $I.10, pk(x.11) )] )
    case Register_pk
    solve( (#i.3, 1)[!Ltk( $R.12, ltkR.13 )] )
      case Register_pk
      solve( KU((#vf.14, 0), sign(<'1', $I.10, $R.12, x.9>, ~ltk.20)) )
        case Init_1
        solve( splitEqs(1) )
          case split_case_1
          solve( (#k.4, 0)[!KU( f_.5, 'g'^(~ekR.64*~ekI.65) )] /* may loop */ )
            case Init_1
            by solve( (#vr.83, 1)[!KU( f_.84, ~ekR.105 )] /* may loop */ )
          next
            case Resp
            by solve( (#vr.88, 1)[!KU( f_.89, ~ekI.115 )] /* may loop */ )
          next
            case exp
            by solve( KU((#vr.69, 1), ~ekR.64) )
          qed
        next
          case split_case_2
          by contradiction // non-normal terms
        qed
      next
        case sign
        solve( (#vr.32, 1)[!KU( f_.34, ~ltk.20 )] /* may loop */ )
          case Reveal_ltk
          by contradiction // cyclic
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.


analyzing: data/examples/csf12/SignedDH_PFS.spthy

------------------------------------------------------------------------------
analyzed: data/examples/csf12/SignedDH_PFS.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 3.398243s
  Perfect_Forward_Secrecy: complete proof (27 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: data/examples/csf12/SignedDH_PFS.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 3.398243s
  Perfect_Forward_Secrecy: complete proof (27 steps)

==============================================================================
*/
