theory KAS1 begin

// Function signature and definition of the equational theory E

functions: KDF/1, MAC/2, adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, snd/1
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2

section{* KAS1 *}

rule (modulo E) Register_pk:
   [ Fr( ~ltkA ) ]
  -->
   [ !Ltk( $A, ~ltkA ), !Pk( $A, pk(~ltkA) ), Out( pk(~ltkA) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_K1_1:
   [ Fr( ~m1 ), !Ltk( $I, ~lkI ), !Pk( $R, pkR ) ]
  --[ SidI( ~m1, $I, $R, <$I, $R, 'Init', aenc(~m1, pkR)> ) ]->
   [
   Init_1( ~m1, $I, $R, ~lkI, ~m1, aenc(~m1, pkR) ), !Ephk( ~m1, ~m1 ),
   Out( aenc(~m1, pkR) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Resp_K1_1:
   [ Fr( ~m2 ), In( c1 ), !Ltk( $R, ~lkR ), !Pk( $I, pkI ) ]
  --[
  SidR( ~m2, $R, $I, <$R, $I, 'Resp', ~m2, c1> ),
  Match( ~m2, <$I, $R, 'Init', c1> ),
  Match( ~m2, <$I, $R, 'Init', c1, ~m2> )
  ]->
   [
   Out( <~m2, 
         MAC(KDF(<adec(c1, ~lkR), $I, $R, ~m2, c1>), <'KC_1_V', $R, $I, ~m2, c1>)>
   ),
   !Sessk( ~m2, KDF(<adec(c1, ~lkR), $I, $R, ~m2, c1>) )
   ]

  /*
  rule (modulo AC) Resp_K1_1:
     [ Fr( ~m2 ), In( c1 ), !Ltk( $R, ~lkR ), !Pk( $I, pkI ) ]
    --[
    SidR( ~m2, $R, $I, <$R, $I, 'Resp', ~m2, c1> ),
    Match( ~m2, <$I, $R, 'Init', c1> ),
    Match( ~m2, <$I, $R, 'Init', c1, ~m2> )
    ]->
     [
     Out( <~m2, MAC(KDF(<z, $I, $R, ~m2, c1>), <'KC_1_V', $R, $I, ~m2, c1>)>
     ),
     !Sessk( ~m2, KDF(<z, $I, $R, ~m2, c1>) )
     ]
  
    variants (modulo AC)
    1. ~lkR  = ~lkR.11
       c1    = c1.13
       z     = adec(c1.13, ~lkR.11)
    
    2. ~lkR  = ~lkR.13
       c1    = aenc(z.17, pk(~lkR.13))
       z     = z.17
  */

rule (modulo E) Init_K1_2:
   [
   Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 ),
   In( <nonceB, 
        MAC(KDF(<~m1, $I, $R, nonceB, c1>), <'KC_1_V', $R, $I, nonceB, c1>)>
   )
   ]
  --[
  SidI( ~m1, $I, $R, <$I, $R, 'Init', c1, nonceB> ),
  Match( ~m1, <$R, $I, 'Resp', nonceB, c1> ),
  Accept( ~m1, $I, $R, KDF(<~m1, $I, $R, nonceB, c1>) )
  ]->
   [ !Sessk( ~m1, KDF(<~m1, $I, $R, nonceB, c1>) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sessk_reveal:
   [ !Sessk( ~tid, k ) ] --[ SesskRev( ~tid ) ]-> [ Out( k ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Ltk_reveal:
   [ !Ltk( $A, lkA ) ] --[ LtkRev( $A ) ]-> [ Out( lkA ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Ephk_reveal:
   [ !Ephk( ~s, ~ek ) ] --[ EphkRev( ~s ) ]-> [ Out( ~ek ) ]

  /* has exactly the trivial AC variant */

lemma (modulo E) KAS1_key_secrecy:
  all-traces
  "not(Ex #i1 #i2.1 s.2 A.3 B.4 k.5.
        (((((Accept( s.2, A.3, B.4, k.5 ) @ #i1) & (K( k.5 ) @ #i2.1)) &
           (not(Ex #i4.6. SesskRev( s.2 ) @ #i4.6))) &
          (not(Ex #i4.7. EphkRev( s.2 ) @ #i4.7))) &
         (All ss.8 #i4.9 #i5.10 C.11 D.12 ms.13.
           ((SidR( ss.8, C.11, D.12, ms.13 ) @ #i4.9) &
            (Match( s.2, ms.13 ) @ #i5.10)) ==>
           (((not(Ex #i6.14. SesskRev( ss.8 ) @ #i6.14)) &
             (not(Ex #i6.15. LtkRev( B.4 ) @ #i6.15))) &
            (not(Ex #i6.16 #i7.17.
                  (LtkRev( A.3 ) @ #i6.16) & (LtkRev( B.4 ) @ #i7.17)))))) &
        ((not(Ex ss.18 #i4.19 #i5.20 C.21 D.22 ms.23.
               (SidR( ss.18, C.21, D.22, ms.23 ) @ #i4.19) &
               (Match( s.2, ms.23 ) @ #i5.20))) ==>
         (not(Ex #i6.24. (LtkRev( B.4 ) @ #i6.24) & (#i6.24 < #i1)))))"
/* proof based on the same lemma modulo AC */
/*
guarded formula characterizing all counter-examples:
"Ex #i1 #i2.1 s.2 A.3 B.4 k.5.
  (Accept( s.2, A.3, B.4, k.5 ) @ #i1) & (K( k.5 ) @ #i2.1)
 &
  (All #i4.6. (SesskRev( s.2 ) @ #i4.6) ==> F) &
  (All #i4.7. (EphkRev( s.2 ) @ #i4.7) ==> F) &
  (All ss.8 #i4.9 #i5.10 C.11 D.12 ms.13.
    (SidR( ss.8, C.11, D.12, ms.13 ) @ #i4.9) &
    (Match( s.2, ms.13 ) @ #i5.10)
   ==>
    (All #i6.14. (SesskRev( ss.8 ) @ #i6.14) ==> F) &
    (All #i6.15. (LtkRev( B.4 ) @ #i6.15) ==> F) &
    (All #i6.16 #i7.17.
      (LtkRev( A.3 ) @ #i6.16) & (LtkRev( B.4 ) @ #i7.17)
     ==>
      F)) &
  ((Ex ss.18 #i4.19 #i5.20 C.21 D.22 ms.23.
     (SidR( ss.18, C.21, D.22, ms.23 ) @ #i4.19) &
     (Match( s.2, ms.23 ) @ #i5.20)
    &
     T) |
   (All #i6.24. (LtkRev( B.4 ) @ #i6.24) ==> All . (#i6.24 < #i1) ==> F))"
*/
simplify
solve( Disj(Ex ss.1 #i4.2 #i5.3 C.4 D.5 ms.6.
             (SidR( ss.1, C.4, D.5, ms.6 ) @ #i4.2) & (Match( ~m1, ms.6 ) @ #i5.3)
            &
             T) |
           (All #i6.1. (LtkRev( $R ) @ #i6.1) ==> All . (#i6.1 < #i1) ==> F) )
  case case_1
  solve( (#i1, 0)[Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 )] )
    case Init_K1_1
    solve( (#i4, 2)[!Ltk( $R.1, ~lkR )] )
      case Register_pk
      solve( (#i4, 3)[!Pk( $I.1, pkI )] )
        case Register_pk
        solve( Match( ~m1, <$R.1, $I.1, 'Resp', ~m2, c1> ) @ #i5 )
          case Init_K1_2
          solve( (#i5, 0)[Init_1( ~m1, $I.1, $R.1, ~lkI.1, ~m1, c1 )] )
            case Init_K1_1
            solve( splitEqs(1) )
              case split_case_1
              solve( !KU( f_, KDF(<~m1, $I, $R, ~m2, aenc(~m1, pk(~lkR))>) ) @ #vk.3 )
                case Sessk_reveal_case_1
                by contradiction // from formulas
              next
                case Sessk_reveal_case_2
                by contradiction // from formulas
              next
                case cKDF
                solve( !KU( f_.5, ~m1 ) @ #vk.7 )
                  case Ephk_reveal
                  by contradiction // from formulas
                next
                  case Init_K1_1
                  solve( !KU( f_.3, ~lkR ) @ #vk.12 )
                    case Ltk_reveal
                    by contradiction // from formulas
                  qed
                qed
              qed
            next
              case split_case_2
              solve( !KU( f_.4,
                          MAC(KDF(<~m1, $I, $R, ~m2, aenc(~m1, pk(~ltkA))>),
                              <'KC_1_V', $R, $I, ~m2, aenc(~m1, pk(~ltkA))>)
                     ) @ #vk.2 )
                case cMAC
                solve( !KU( f_, KDF(<~m1, $I, $R, ~m2, aenc(~m1, pk(~ltkA))>) ) @ #vk.4 )
                  case Sessk_reveal
                  by contradiction // cyclic
                next
                  case cKDF
                  solve( !KU( f_.11, ~m1 ) @ #vk.15 )
                    case Ephk_reveal
                    by contradiction // from formulas
                  next
                    case Init_K1_1
                    solve( !KU( f_.4, ~ltkA ) @ #vk.16 )
                      case Ltk_reveal
                      by contradiction // from formulas
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
next
  case case_2
  solve( (#i1, 0)[Init_1( ~m1, $I, $R, ~lkI, ~m1, c1 )] )
    case Init_K1_1
    solve( !KU( f_.3,
                MAC(KDF(<~m1, $I, $R, nonceB, aenc(~m1, pk(~ltkA))>),
                    <'KC_1_V', $R, $I, nonceB, aenc(~m1, pk(~ltkA))>)
           ) @ #vk.2 )
      case Resp_K1_1
      solve( !KU( f_, KDF(<~m1, $I, $R, ~m2, aenc(~m1, pk(~ltkA))>) ) @ #vk.3 )
        case Sessk_reveal_case_1
        by contradiction // from formulas
      next
        case Sessk_reveal_case_2
        by contradiction // from formulas
      next
        case cKDF
        solve( !KU( f_.4, ~m1 ) @ #vk.7 )
          case Ephk_reveal
          by contradiction // from formulas
        next
          case Init_K1_1
          solve( !KU( f_.3, ~ltkA ) @ #vk.12 )
            case Ltk_reveal
            by contradiction // from formulas
          qed
        qed
      qed
    next
      case cMAC
      solve( !KU( f_, KDF(<~m1, $I, $R, nonceB, aenc(~m1, pk(~ltkA))>)
             ) @ #vk.4 )
        case Sessk_reveal_case_1
        by contradiction // from formulas
      next
        case Sessk_reveal_case_2
        by contradiction // cyclic
      next
        case cKDF
        solve( !KU( f_.11, ~m1 ) @ #vk.15 )
          case Ephk_reveal
          by contradiction // from formulas
        next
          case Init_K1_1
          solve( !KU( f_.3, ~ltkA ) @ #vk.16 )
            case Ltk_reveal
            by contradiction // from formulas
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.
 checking installation: OK.


analyzing: data/examples/csf12/KAS1.spthy

------------------------------------------------------------------------------
analyzed: data/examples/csf12/KAS1.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 0.719276s
  KAS1_key_secrecy (all-traces): verified (38 steps)

------------------------------------------------------------------------------

==============================================================================
summary of summaries:

analyzed: data/examples/csf12/KAS1.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 0.719276s
  KAS1_key_secrecy (all-traces): verified (38 steps)

==============================================================================
*/
