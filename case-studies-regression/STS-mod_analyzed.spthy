theory STSmod begin

 unique_insts:

section{* Finite Variants of the Intruder Rules *}

 rule (modulo AC) isend:
    !KU( f_, x ) --[ K( x ) ]-> In( x )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, x.4 ) --> !KD( 'exp', x.2^(x.4*x.3) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, inv(x.3) ) --> !KD( 'exp', x.2 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, x.3 ) --> !KD( 'exp', x.2 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, inv(x.4) )
   -->
    !KD( 'exp', x.2^inv((x.4*x.3)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, x.4 )
   -->
    !KD( 'exp', x.2^x.3 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, inv(x.3) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, x.3 )
   -->
    !KD( 'exp', x.2^inv(x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, (x.4*inv(x.3)) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, inv((x.4*x.3)) )
   -->
    !KD( 'exp', x.2^inv(x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, (x.4*x.3) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, inv(x.5) )
   -->
    !KD( 'exp', x.2^(x.3*inv((x.5*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv(x.3) ), !KU( f_, (x.4*inv(x.5)) )
   -->
    !KD( 'exp', x.2^(x.4*inv((x.5*x.3))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, x.4 )
   -->
    !KD( 'exp', x.2^(x.3*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.5*x.4) )
   -->
    !KD( 'exp', x.2^(x.5*x.3) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, (x.5*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.5*x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, inv((x.5*x.3)) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, (x.5*x.3) )
   -->
    !KD( 'exp', x.2^(x.5*inv(x.4)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^x.3 ), !KU( f_, (x.4*inv((x.5*x.3))) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.5*inv(x.6)) )
   -->
    !KD( 'exp', x.2^((x.5*x.3)*inv((x.6*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.4*inv(x.3)) )
   -->
    !KD( 'exp', x.2 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, inv((x.5*x.3)) )
   -->
    !KD( 'exp', x.2^inv((x.5*x.4)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, (x.3*inv(x.5)) )
   -->
    !KD( 'exp', x.2^inv((x.5*x.4)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, (x.6*x.4) )
   -->
    !KD( 'exp', x.2^((x.6*x.3)*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.4*x.3) ), !KU( f_, (x.5*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^((x.5*x.4)*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ), !KU( f_, (x.5*inv(x.3)) )
   -->
    !KD( 'exp', x.2^x.4 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, (x.4*inv(x.3)) )
   -->
    !KD( 'exp', x.2^inv(x.5) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, ((x.5*x.4)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^x.5 )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.4*inv((x.5*x.3))) )
   -->
    !KD( 'exp', x.2^inv(x.5) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ), !KU( f_, inv((x.6*x.3)) )
   -->
    !KD( 'exp', x.2^(x.4*inv((x.6*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^inv((x.4*x.3)) ), !KU( f_, ((x.5*x.3)*inv(x.6)) )
   -->
    !KD( 'exp', x.2^(x.5*inv((x.6*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, (x.4*inv(x.6)) )
   -->
    !KD( 'exp', x.2^(x.3*inv((x.6*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, (x.5*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^(x.5*inv((x.6*x.4))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv(x.4)) ), !KU( f_, ((x.5*x.4)*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^(x.5*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ), !KU( f_, (x.5*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, (x.4*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^inv((x.6*x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, ((x.6*x.4)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.6*inv(x.5)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ), !KU( f_, (x.5*inv((x.6*x.3))) )
   -->
    !KD( 'exp', x.2^(x.4*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ), !KU( f_, ((x.6*x.5)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^(x.6*x.4) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ), !KU( f_, (x.6*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^((x.6*x.4)*inv((x.7*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ), !KU( f_, ((x.6*x.4)*inv(x.7)) )
   -->
    !KD( 'exp', x.2^((x.6*x.3)*inv((x.7*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv(x.5)) ),
    !KU( f_, ((x.6*x.5)*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^((x.6*x.4)*inv(x.7)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ),
    !KU( f_, ((x.7*x.5)*inv(x.3)) )
   -->
    !KD( 'exp', x.2^((x.7*x.4)*inv(x.6)) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^(x.3*inv((x.5*x.4))) ),
    !KU( f_, ((x.6*x.4)*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^(x.6*inv((x.7*x.5))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ),
    !KU( f_, (x.5*inv((x.7*x.3))) )
   -->
    !KD( 'exp', x.2^(x.4*inv((x.7*x.6))) )
 
 rule (modulo AC) Exp:
    !KD( 'noexp', x.2^((x.4*x.3)*inv((x.6*x.5))) ),
    !KU( f_, ((x.7*x.5)*inv((x.8*x.3))) )
   -->
    !KD( 'exp', x.2^((x.7*x.4)*inv((x.8*x.6))) )
 
 rule (modulo AC) Inv:
    !KD( f_, inv(x.1) ) --> !KD( 'noexp', x.1 )
 
 rule (modulo AC) snd:
    !KD( f_, <x.1, x.2> ) --> !KD( 'noexp', x.2 )
 
 rule (modulo AC) fst:
    !KD( f_, <x.1, x.2> ) --> !KD( 'noexp', x.1 )
 
 rule (modulo AC) adec:
    !KD( f1_, aenc(x.3, pk(x.2)) ), !KU( f2_, x.2 ) --> !KD( 'noexp', x.3 )
 
 rule (modulo AC) sdec:
    !KD( f1_, senc(x.3, x.2) ), !KU( f2_, x.2 ) --> !KD( 'noexp', x.3 )
 
 rule (modulo AC) verify:
    !KD( f1_, sign(x.3, x.2) ), !KU( f2_, pk(x.2) ) --> !KD( 'noexp', x.3 )
 
 rule (modulo AC) Exp:
    !KU( 'noexp', x ), !KU( f_, x.1 ) --> !KU( 'exp', x^x.1 )
 
 rule (modulo AC) Unit:
   --> !KU( 'noexp', one() )
 
 rule (modulo AC) h:
    !KU( f_, x ) --> !KU( 'noexp', h(x) )
 
 rule (modulo AC) pk:
    !KU( f_, x ) --> !KU( 'noexp', pk(x) )
 
 rule (modulo AC) snd:
    !KU( f_, x ) --> !KU( 'noexp', snd(x) )
 
 rule (modulo AC) fst:
    !KU( f_, x ) --> !KU( 'noexp', fst(x) )
 
 rule (modulo AC) senc:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', senc(x, x.1) )
 
 rule (modulo AC) aenc:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', aenc(x, x.1) )
 
 rule (modulo AC) adec:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', adec(x.1, x) )
 
 rule (modulo AC) sdec:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', sdec(x.1, x) )
 
 rule (modulo AC) sign:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', sign(x, x.1) )
 
 rule (modulo AC) verify:
    !KU( f1_, x ), !KU( f2_, x.1 ) --> !KU( 'noexp', verify(x.1, x) )
 
 rule (modulo AC) coerce:
    !KD( f_, x ) --> !KU( f_, x )
 
 rule (modulo AC) pub:
   --> !KU( f_, $x )
 
 rule (modulo AC) gen_fresh:
    Fr( ~x ) --> !KU( 'noexp', ~x )

section{* The Station-To-Station Protocol, modified version *}

rule (modulo E) Register_pk:
   Fr( ~ltk ) --> !Ltk( $A, ~ltk ), !Pk( $A, pk(~ltk) )
  /* has exactly the trivial AC variant */

rule (modulo E) Get_pk:
   !Pk( A, pk ) --> Out( pk )
  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ltk:
   !Ltk( A, ltk ) --[ LtkReveal( A ) ]-> Out( ltk )
  /* has exactly the trivial AC variant */

rule (modulo E) Init_1:
   Fr( ~ekI ), !Ltk( $I, ltkI )
  -->
   Init_1( $I, $R, ltkI, ~ekI ), Out( <$I, $R, 'g'^~ekI> )
  /* has exactly the trivial AC variant */

rule (modulo E) Init_2:
   Init_1( $I, $R, ltkI, ~ekI ), !Pk( $R, pk(ltkR) ),
   In( <$R, $I, Y, sign(<'1', h(<$I, 'g'^~ekI, Y>)>, ltkR)> )
  --[ SessionKey( $I, $R, h(Y^~ekI) ) ]->
   Out( <$I, $R, sign(<'2', h(<$R, 'g'^~ekI, Y>)>, ltkI)> )
  /*
  rule (modulo AC) Init_2:
     Init_1( $I.3, $R.4, ltkI.5, ~ekI ), !Pk( $R.4, pk(x.6) ),
     In( <$R.4, $I.3, x.2, sign(<'1', h(<$I.3, 'g'^~ekI, x.2>)>, x.6)> )
    --[ SessionKey( $I.3, $R.4, h(x.1) ) ]->
     Out( <$I.3, $R.4, sign(<'2', h(<$R.4, 'g'^~ekI, x.2>)>, ltkI.5)> )
  
    variants (modulo AC)
    1. ~ekI  = ~ekI.55
       x.1   = x.56
       x.2   = x.56^inv(~ekI.55)
    
    2. ~ekI  = ~ekI.55
       x.1   = x.56^~ekI.55
       x.2   = x.56
    
    3. ~ekI  = ~ekI.56
       x.1   = x.57^x.58
       x.2   = x.57^(x.58*inv(~ekI.56))
    
    4. ~ekI  = ~ekI.56
       x.1   = x.57^inv(x.58)
       x.2   = x.57^inv((~ekI.56*x.58))
    
    5. ~ekI  = ~ekI.56
       x.1   = x.57^(~ekI.56*x.58)
       x.2   = x.57^x.58
    
    6. ~ekI  = ~ekI.57
       x.1   = x.58^(x.59*inv(x.60))
       x.2   = x.58^(x.59*inv((~ekI.57*x.60)))
  */

rule (modulo E) Resp_1:
   !Pk( $I, pk(ltkI) ), !Ltk( $R, ltkR ), Fr( ~ekR ), In( <$I, $R, X> )
  -->
   Resp_1( $I, $R, ltkI, ltkR, ~ekR, X ),
   Out( <$R, $I, 'g'^~ekR, sign(<'1', h(<$I, X, 'g'^~ekR>)>, ltkR)> )
  /* has exactly the trivial AC variant */

rule (modulo E) Resp_2:
   Resp_1( $I, $R, ltkI, ltkR, ~ekR, X ),
   In( <$I, $R, X, sign(<'2', h(<$R, X, 'g'^~ekR>)>, ltkI)> )
  --[ SessionKey( $I, $R, h(X^~ekR) ) ]->
  /*
  rule (modulo AC) Resp_2:
     Resp_1( $I.3, $R.4, ltkI.5, ltkR.6, ~ekR, X.1 ),
     In( <$I.3, $R.4, X.1, sign(<'2', h(<$R.4, X.1, 'g'^~ekR>)>, ltkI.5)> )
    --[ SessionKey( $I.3, $R.4, h(x.2) ) ]->
  
    variants (modulo AC)
    1. ~ekR  = ~ekR.33
       X.1   = X.34
       x.2   = X.34^~ekR.33
    
    2. ~ekR  = ~ekR.33
       X.1   = x.34^inv(~ekR.33)
       x.2   = x.34
    
    3. ~ekR  = ~ekR.34
       X.1   = x.35^x.36
       x.2   = x.35^(~ekR.34*x.36)
    
    4. ~ekR  = ~ekR.34
       X.1   = x.35^inv((~ekR.34*x.36))
       x.2   = x.35^inv(x.36)
    
    5. ~ekR  = ~ekR.34
       X.1   = x.35^(x.36*inv(~ekR.34))
       x.2   = x.35^x.36
    
    6. ~ekR  = ~ekR.35
       X.1   = x.36^(x.37*inv((~ekR.35*x.38)))
       x.2   = x.36^(x.37*inv(x.38))
  */

lemma (modulo E) Perfect_Forward_Secrecy:
  "All I R.1 sessKey.2 #i.3 #k.4.
    ((SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)) ==>
    ((Ex #r.5. (LtkReveal( I ) @ #r.5) & (#r.5 < #i.3)) |
     (Ex #r.6. (LtkReveal( R.1 ) @ #r.6) & (#r.6 < #i.3)))"
/* proof based on the same lemma modulo AC */
/*
doubly-guarded formula characterizing all attacks:
"Ex I R.1 sessKey.2 #i.3 #k.4.
  (SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)
 &
  (All #r.5. (LtkReveal( I ) @ #r.5) ==> All. (#r.5 < #i.3) ==> F) &
  (All #r.6. (LtkReveal( R.1 ) @ #r.6) ==> All. (#r.6 < #i.3) ==> F)"
*/
/*
proof by induction possible over the formula:
"(Ex I R.1 sessKey.2 #i.3 #k.4.
   (SessionKey( I, R.1, sessKey.2 ) @ #i.3) & (K( sessKey.2 ) @ #k.4)
  &
   (All #r.5. (LtkReveal( I ) @ #r.5) ==> All. (#r.5 < #i.3) ==> F) &
   (All #r.6. (LtkReveal( R.1 ) @ #r.6) ==> All. (#r.6 < #i.3) ==> F)) &
 (All I.7 R.8 sessKey.9 #i.10 #k.11.
   (SessionKey( I.7, R.8, sessKey.9 ) @ #i.10) & (K( sessKey.9 ) @ #k.11)
  ==>
   (Last(#k.11)) |
   (Last(#i.10)) |
   (Ex #r.12.
     (LtkReveal( I.7 ) @ #r.12)
    &
     (All. (Last(#r.12)) ==> F) & (Ex. (#r.12 < #i.10) & T)) |
   (Ex #r.13.
     (LtkReveal( R.8 ) @ #r.13)
    &
     (All. (Last(#r.13)) ==> F) & (Ex. (#r.13 < #i.10) & T)))"
*/
simplify
solve( SessionKey( I, R.1, sessKey.2 ) @ #i.3 )
  case Init_2
  solve( (#i.3, 0)[Init_1( $I.10, $R.11, ltkI.12, ~ekI.7 )] )
    case Init_1
    solve( (#i.3, 1)[!Pk( $R.11, pk(x.13) )] )
      case Register_pk
      solve( KU((#vf.14, 0), sign(<'1', h(<$I.10, 'g'^~ekI.7, x.9>)>,
                                  ~ltk.33)) )
        case Resp_1
        solve( splitEqs(1) )
          case split_case_1
          solve( (#k.4, 0)[!KU( f_.5, h('g'^(~ekI.76*~ekR.77)) )] )
            case h
            solve( (#vr.80, 0)[!KU( f_.81, 'g'^(~ekI.76*~ekR.77) )] )
              case Exp
              by solve( KU((#vr.86, 1), ~ekI.76) )
            next
              case Init_1
              by solve( (#vr.97, 1)[!KU( f_.98, ~ekR.116 )] )
            next
              case Resp_1
              by solve( (#vr.102, 1)[!KU( f_.103, ~ekI.127 )] )
            qed
          qed
        next
          case split_case_2
          by contradiction // non-normal terms
        qed
      next
        case sign
        solve( (#vr.39, 1)[!KU( f2_.41, ~ltk.33 )] )
          case Reveal_ltk
          by contradiction // cyclic
        qed
      qed
    qed
  qed
next
  case Resp_2
  solve( (#i.3, 0)[Resp_1( $I.10, $R.11, ltkI.12, ltkR.13, ~ekR.7, X.8 )] )
    case Resp_1
    solve( KU((#vf.14, 0), sign(<'2', h(<$R.11, X.8, 'g'^~ekR.7>)>,
                                ~ltk.24)) )
      case Init_2
      solve( KU((#vf.53, 0), sign(<'1', h(<$I.10, 'g'^~ekI.45, 'g'^~ekR.7>)>,
                                  ~ltk.51)) )
        case Resp_1
        solve( splitEqs(1) )
          case split_case_1
          solve( (#k.4, 0)[!KU( f_.5, h('g'^(~ekR.122*~ekI.123)) )] )
            case h
            solve( (#vr.126, 0)[!KU( f_.127, 'g'^(~ekR.122*~ekI.123) )] )
              case Exp
              by solve( KU((#vr.132, 1), ~ekR.122) )
            next
              case Init_1
              by solve( (#vr.143, 1)[!KU( f_.144, ~ekR.161 )] )
            next
              case Resp_1
              by solve( (#vr.148, 1)[!KU( f_.149, ~ekI.174 )] )
            qed
          qed
        next
          case split_case_2
          by contradiction // non-normal terms
        qed
      next
        case sign
        solve( (#vr.87, 1)[!KU( f2_.89, ~ltk.51 )] )
          case Reveal_ltk
          by contradiction // cyclic
        qed
      qed
    next
      case sign
      solve( (#vr.43, 1)[!KU( f2_.45, ~ltk.24 )] )
        case Reveal_ltk
        by contradiction // cyclic
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end
/* Output
maude tool: 'maude'
 checking version: 2.6. OK.


analyzing: data/examples/STS-mod.spthy

------------------------------------------------------------------------------
analyzed: data/examples/STS-mod.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 7.404399s
  Perfect_Forward_Secrecy: complete proof (28 steps)

------------------------------------------------------------------------------

==============================================================================
summary of processed files:

analyzed: data/examples/STS-mod.spthy

  output:          case-studies/temp-analysis.spthy
  processing time: 7.404399s
  Perfect_Forward_Secrecy: complete proof (28 steps)

==============================================================================
*/
