maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: OK.
SAPIC tool: 'sapic'
Checking availablity ... OK.

theory Yubikey begin

// Function signature and definition of the equational theory E

functions: S/1, fst/1, myzero/0, pair/2, sdec/2, senc/2, snd/1
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2

/* looping facts with injective instances: Server/3, Y_counter/2 */

section{* The Yubikey-Protocol *}

rule (modulo E) InitSucc:
   [ In( myzero ), In( S(myzero) ) ]
  --[ Theory( ), IsSucc( myzero, S(myzero) ), IsZero( myzero ) ]->
   [ !Succ( myzero, S(myzero) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) StepSucc:
   [ In( y ), In( S(y) ), !Succ( x, y ) ]
  --[ Theory( ), IsSucc( y, S(y) ) ]->
   [ !Succ( y, S(y) ) ]

  // loop breaker: [2]
  /* has exactly the trivial AC variant */

rule (modulo E) SimpleSmaller:
   [ !Succ( x, y ) ]
  --[ Theory( ), IsSmaller( x, y ) ]->
   [ !Smaller( x, y ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) ZExtendedSmaller:
   [ !Smaller( x, y ), !Succ( y, z ) ]
  --[ Theory( ), IsSmaller( x, z ) ]->
   [ !Smaller( x, z ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) BuyANewYubikey:
   [ Fr( ~k ), Fr( ~pid ), Fr( ~sid ) ]
  --[
  Protocol( ), Init( ~pid, ~k ), ExtendedInit( ~pid, ~sid, ~k ),
  IsZero( myzero )
  ]->
   [
   !Y( ~pid, ~sid ), Y_counter( ~pid, myzero ),
   Server( ~pid, ~sid, myzero ), !SharedKey( ~pid, ~k ), Out( ~pid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Yubikey_Plugin:
   [ Y_counter( pid, sc ), !Smaller( sc, Ssc ) ]
  --[ Yubi( pid, Ssc ) ]->
   [ Y_counter( pid, Ssc ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

rule (modulo E) Yubikey_PressButton:
   [
   !Y( pid, sid ), Y_counter( pid, tc ), !SharedKey( pid, k ),
   !Succ( tc, Stc ), Fr( ~npr ), Fr( ~nonce )
   ]
  --[
  YubiPress( pid, tc ), YubiOTP( pid, senc(<sid, tc, ~npr>, k) ),
  YubiSid( pid, sid, k )
  ]->
   [ Y_counter( pid, Stc ), Out( <pid, ~nonce, senc(<sid, tc, ~npr>, k)> ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) Server_ReceiveOTP_NewSession:
   [
   Server( pid, sid, otc ), In( <pid, nonce, senc(<sid, tc, ~pr>, k)> ),
   !SharedKey( pid, k ), !Smaller( otc, tc )
   ]
  --[
  Login( pid, sid, tc, senc(<sid, tc, ~pr>, k) ),
  LoginCounter( pid, otc, tc )
  ]->
   [ Server( pid, sid, tc ) ]

  // loop breaker: [0]
  /* has exactly the trivial AC variant */

restriction transitivity:
  "∀ #t1 #t2 a b c.
    ((IsSmaller( a, b ) @ #t1) ∧ (IsSmaller( b, c ) @ #t2)) ⇒
    (∃ #t3. IsSmaller( a, c ) @ #t3)"

restriction smaller_implies_unequal:
  "¬(∃ a #t. IsSmaller( a, a ) @ #t)"
  // safety formula

restriction theory_before_protocol:
  "∀ #i #j. ((Theory( ) @ #i) ∧ (Protocol( ) @ #j)) ⇒ (#i < #j)"
  // safety formula

lemma Login_reachable:
  exists-trace "∃ #i pid sid x otp1. Login( pid, sid, x, otp1 ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ #i pid sid x otp1. (Login( pid, sid, x, otp1 ) @ #i)"
*/
by sorry

0

(0 + 0)

0

(0 || 0)

!test

Robert

(test || test2)

(Robert || Kuennemann)

let testprocess = 0

let p2 = (0 || 0)

let p3 = ((test || (0 + Apfel)) || !Baum)

lemma one_count_foreach_login [reuse, use_induction]:
  all-traces
  "∀ pid sid x otp #t2.
    (Login( pid, sid, x, otp ) @ #t2) ⇒
    (∃ #t1. (YubiPress( pid, x ) @ #t1) ∧ (#t1 < #t2))"
/*
guarded formula characterizing all counter-examples:
"∃ pid sid x otp #t2.
  (Login( pid, sid, x, otp ) @ #t2)
 ∧
  ∀ #t1. (YubiPress( pid, x ) @ #t1) ⇒ ¬(#t1 < #t2)"
*/
by sorry

lemma slightly_weaker_invariant [reuse, use_induction]:
  all-traces
  "∀ pid otc1 tc1 otc2 tc2 #t1 #t2.
    ((LoginCounter( pid, otc1, tc1 ) @ #t1) ∧
     (LoginCounter( pid, otc2, tc2 ) @ #t2)) ⇒
    ((((#t1 < #t2) ∧ (∃ #t3. IsSmaller( tc1, tc2 ) @ #t3)) ∨ (#t2 < #t1)) ∨
     (#t1 = #t2))"
/*
guarded formula characterizing all counter-examples:
"∃ pid otc1 tc1 otc2 tc2 #t1 #t2.
  (LoginCounter( pid, otc1, tc1 ) @ #t1) ∧
  (LoginCounter( pid, otc2, tc2 ) @ #t2)
 ∧
  (((¬(#t1 < #t2)) ∨ (∀ #t3. (IsSmaller( tc1, tc2 ) @ #t3) ⇒ ⊥))) ∧
  (¬(#t2 < #t1)) ∧
  (¬(#t1 = #t2))"
*/
induction
  case empty_trace
  by contradiction
next
  case non_empty_trace
  simplify
  solve( (∀ pid otc1 tc1 otc2 tc2 #t1 #t2.
           (LoginCounter( pid, otc1, tc1 ) @ #t1) ∧
           (LoginCounter( pid, otc2, tc2 ) @ #t2)
          ⇒
           ((last(#t2)) ∨
            (last(#t1)) ∨
            ((#t1 < #t2) ∧ (∃ #t3. (IsSmaller( tc1, tc2 ) @ #t3) ∧ ¬(last(#t3)))) ∨
            (#t2 < #t1) ∨
            (#t1 = #t2)))  ∥
         (∃ #t1 #t2 a b c.
           (IsSmaller( a, b ) @ #t1) ∧ (IsSmaller( b, c ) @ #t2)
          ∧
           (¬(last(#t2))) ∧
           (¬(last(#t1))) ∧
           (∀ #t3. (IsSmaller( a, c ) @ #t3) ⇒ last(#t3))) )
    case case_1
    solve( (last(#t2))  ∥ (last(#t1))  ∥
           ((#t1 < #t2) ∧ (∃ #t3. (IsSmaller( tc1, tc2 ) @ #t3) ∧ ¬(last(#t3))))  ∥
           (#t2 < #t1)  ∥ (#t1 = #t2) )
      case case_1
      solve( Server( pid, sid, otc1 ) ▶₀ #t1 )
        case BuyANewYubikey
        solve( Server( ~pid, sid.1, otc2 ) ▶₀ #t2 )
          case 
          by sorry /* unannotated */
        next
          case BuyANewYubikey
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_1
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_2
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_3
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_4
          by sorry
        qed
      next
        case Server_ReceiveOTP_NewSession_case_1
        solve( Server( ~pid, sid.1, otc2 ) ▶₀ #t2 )
          case 
          by sorry /* unannotated */
        next
          case BuyANewYubikey
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_1
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_2
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_3
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_4
          by sorry
        qed
      next
        case Server_ReceiveOTP_NewSession_case_2
        solve( Server( ~pid, sid.1, otc2 ) ▶₀ #t2 )
          case 
          by sorry /* unannotated */
        next
          case BuyANewYubikey
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_1
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_2
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_3
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_4
          by sorry
        qed
      next
        case Server_ReceiveOTP_NewSession_case_3
        solve( Server( ~pid, sid.1, otc2 ) ▶₀ #t2 )
          case 
          by sorry /* unannotated */
        next
          case BuyANewYubikey
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_1
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_2
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_3
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_4
          by sorry
        qed
      next
        case Server_ReceiveOTP_NewSession_case_4
        solve( Server( ~pid, sid.1, otc2 ) ▶₀ #t2 )
          case 
          by sorry /* unannotated */
        next
          case BuyANewYubikey
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_1
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_2
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_3
          by sorry
        next
          case Server_ReceiveOTP_NewSession_case_4
          by sorry
        qed
      qed
    next
      case case_2
      by contradiction
    next
      case case_3
      by contradiction
    next
      case case_4
      by contradiction
    next
      case case_5
      by contradiction
    qed
  next
    case case_2
    by sorry
  qed
qed

lemma no_replay:
  all-traces
  "¬(∃ #i #j pid sid x otp1 otp2.
      ((Login( pid, sid, x, otp1 ) @ #i) ∧ (Login( pid, sid, x, otp2 ) @ #j)) ∧
      (¬(#i = #j)))"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j pid sid x otp1 otp2.
  (Login( pid, sid, x, otp1 ) @ #i) ∧ (Login( pid, sid, x, otp2 ) @ #j)
 ∧
  ¬(#i = #j)"
*/
by sorry

lemma injective_correspondance:
  all-traces
  "∀ pid sid x otp #t2.
    (Login( pid, sid, x, otp ) @ #t2) ⇒
    (∃ #t1.
      ((YubiPress( pid, x ) @ #t1) ∧ (#t1 < #t2)) ∧
      (∀ otp2 #t3. (Login( pid, sid, x, otp2 ) @ #t3) ⇒ (#t3 = #t2)))"
/*
guarded formula characterizing all counter-examples:
"∃ pid sid x otp #t2.
  (Login( pid, sid, x, otp ) @ #t2)
 ∧
  ∀ #t1.
   (YubiPress( pid, x ) @ #t1)
  ⇒
   ((¬(#t1 < #t2)) ∨
    (∃ otp2 #t3. (Login( pid, sid, x, otp2 ) @ #t3) ∧ ¬(#t3 = #t2)))"
*/
by sorry

lemma Login_invalidates_smaller_counters:
  all-traces
  "∀ pid otc1 tc1 otc2 tc2 #t1 #t2 #t3.
    (((LoginCounter( pid, otc1, tc1 ) @ #t1) ∧
      (LoginCounter( pid, otc2, tc2 ) @ #t2)) ∧
     (IsSmaller( tc1, tc2 ) @ #t3)) ⇒
    (#t1 < #t2)"
/*
guarded formula characterizing all counter-examples:
"∃ pid otc1 tc1 otc2 tc2 #t1 #t2 #t3.
  (LoginCounter( pid, otc1, tc1 ) @ #t1) ∧
  (LoginCounter( pid, otc2, tc2 ) @ #t2) ∧
  (IsSmaller( tc1, tc2 ) @ #t3)
 ∧
  ¬(#t1 < #t2)"
*/
by sorry

/* All well-formedness checks were successful. */

end

==============================================================================
summary of summaries:

analyzed: /home/johannes/hiwi/tamarin-accountability/examples/testParser/Yubikey.spthy

  Login_reachable (exists-trace): analysis incomplete (1 steps)
  one_count_foreach_login (all-traces): analysis incomplete (1 steps)
  slightly_weaker_invariant (all-traces): analysis incomplete (46 steps)
  no_replay (all-traces): analysis incomplete (1 steps)
  injective_correspondance (all-traces): analysis incomplete (1 steps)
  Login_invalidates_smaller_counters (all-traces): analysis incomplete (1 steps)

==============================================================================
