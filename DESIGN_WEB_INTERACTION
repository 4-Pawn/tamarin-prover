Purpose: Design of the Interaction that our Webserver should achieve
Author:  Simon Meier <simon.meier@inf.ethz.ch>
Date:    2011/03/02



Basic Principles
================

User Interaction
----------------

  1. We differentiate between changing the view of a theory (view-changes) and
     changing the theory itself (state-changes).

  2. Forward and backwards buttons of the browser implement undo and redo.
     => only state-changes change the browser history
     => failure while performing a state-change results in a report and no
        change in the browser history.
     => state-changes are cancelable once they take longer than a specified
        amount of time (counts as failure, but no display of error message).

  3. Left-click on an element executes the most sensible action.

  4. Right-click on an element provides a context-menu (or a context-popup)
     with all actions available on that element.

  5. Configuration options (e.g., bounds and timeouts for automatic proof
     search) are stored per session. In the first version, we can store this
     per server instance, as it is thought to be used in single-user mode.

  6. A theory display page consists of a theory index (left frame), the
     main display (central frame), the debug display (right frame), and 
     an overview display (top frame).
  
     Moreover, there is an optional selected proof. Its corresponding text in the
     theory index is highlighted.


Definitions
-----------

  - A /proof state/ is a special purpose representation of a logical formula
    whose validity we must show. (In the code this is a 'Sequent'.)

  - A /proof method/ is a mapping from a proof-state to an equivalent
    disjunction of proof states.

  - A /proof step/ is a proof method possibly annotated with the proof state it
    is applied to. A proof step is /sound/ iff its proof method is not 'Sorry'
    and it is annotated with a proof state that its proof method can be applied
    to.

  - A /proof/ is a tree of proof steps. A proof is /sound/ iff each of its
    steps is sound and the subproofs of a proof step cover all proof states
    generated by the proof steps' method.

  - A proof-state is /trivial/ iff it can be solved with the 'Contradiction' or
    the 'Simplify' proof method.

  Note: It might be beneficial, if we associate a name to every result of the
  application of a proof method. These names can then be used to associate
  sub-proofs with the proof-states generated by the proof method of their
  parent.
  
  
Display Info
------------

  font weight:       indicates current proof step
  foreground color:  indicates status of a proof step 
                      * unannotated
                      * unsound
                      * superfluous (the other steps already cover all cases)
                      * sound
  background color:  inidicates status of subproof starting there
                      * sound
                      * unsound

  - I'm sure there are better possibilities (symbols, numbers, ...)

  - Practice will tell, if a special marking of the 'Sorry' steps is
    beneficial.


Available actions
=================

  General principles:
    - Simplification and searching for contradictions is always done by default
      => only non-deterministic choice is delegated to the user.


Replace Proof Method
--------------------

  - called mostly from links in the main display of a proof state
  - only goal solving and clause resolutions (implemented such that given the
    name of a clause all its productive consequences are added.)


  This is the main work-horse for constructing security proofs. The idea is
  that the 'Sorry' steps are replaced one by one with goal solving or
  clause-resolution steps and newly emerging trivial proof-states are solved
  automatically, while newly emerging non-trivial proof-states are displayed
  with their open goals and possible forward resolutions. The current proof is
  always set to the next not 'sound' proof step hat requires attention by the
  user.


Replace Subproof
----------------

  - automatic proving of the proof-state. Right-click on subproof and select
    'auto prove' or 'auto prove (config)'.


Edit theory
-----------

  - serializes the current theory and allows the user to edit it; e.g., to add
    a new property or to uncomment a protocol rule.

